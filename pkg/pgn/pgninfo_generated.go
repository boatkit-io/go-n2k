// Code generated by "cmd/pgngen"; DO NOT EDIT.
package pgn


import (
	"fmt"
	
	"github.com/boatkit-io/tugboat/pkg/units"
)

func nullableUnit[T any, U any, V float32|uint16|int16|uint32](u U, v *V, newer func(u U, v float32) T) *T {
	if v == nil {
		return nil
	}
	ov := newer(u, float32(*v))
	return &ov
}

// PgnInfo instances describe known NMEA 2000 messages.
type PgnInfo struct {
	// Id needed to distinguish pgns with KeyValue fields
	Id string
	// PGN (Parameter Group Number) identifies the Message
	PGN uint32
	// Description of the message.
	Description string
	// Fast if not single.
	Fast bool
	// ManId identifies the Manufacturer for Proprietary PGNs
	ManId ManufacturerCodeConst
	// Decoder is a function that generates golang data from the messsage data.
	Decoder func(MessageInfo, *DataStream) (any, error)
	// Instance is a zero instance of the struct used for testing
	// Fields is a map of field descriptions needed at runtime to deal with variable pgn fields
	Fields map[int]*FieldDescriptor
	// The following fields are used for testing only.
	// Instance is a zero instance of the struct used for testing
	Instance             any
	// Repeating1CountField is the field that contains the count of repeating1 fields
	Repeating1CountField uint8
	// Repeating2CountField is the field that contains the count of repeating2 fields
	Repeating2CountField uint8
	
}

// FieldDescriptor instances describe a PGN field.
type FieldDescriptor struct {
	Name              string
	BitLength         uint16
	BitOffset         uint16
	BitLengthVariable bool
	CanboatType       string
	Resolution        float32
	Unit              string
	BitLookupName     string
    Match             int

	
	// The following fields are used for testing only. Uncomment to use.
	Id                string
	GolangType        string
	RangeMax          float64
	RangeMin          float64
	DomainMin         float64
	DomainMax         float64
	Signed            bool
	Offset            int64
	Order             uint8
	
}

// Spit out global consts

type LightingCommandConst uint8
const (
	Idle	LightingCommandConst = 0
	DetectDevices	LightingCommandConst = 1
	Reboot	LightingCommandConst = 2
	FactoryReset	LightingCommandConst = 3
	PoweringUp	LightingCommandConst = 4
)

func (e LightingCommandConst) GoString() string {return e.String() }
func (e LightingCommandConst) String() string {
	switch e {
		case 0:
			return "Idle"
		case 1:
			return "Detect Devices"
		case 2:
			return "Reboot"
		case 3:
			return "Factory Reset"
		case 4:
			return "Powering Up"
	default:
		return fmt.Sprintf("%s(%d)", "LightingCommandConst", int(e))
	}
}

type IndustryCodeConst uint8
const (
	Global	IndustryCodeConst = 0
	Highway	IndustryCodeConst = 1
	Agriculture	IndustryCodeConst = 2
	Construction	IndustryCodeConst = 3
	Marine	IndustryCodeConst = 4
	Industrial	IndustryCodeConst = 5
)

func (e IndustryCodeConst) GoString() string {return e.String() }
func (e IndustryCodeConst) String() string {
	switch e {
		case 0:
			return "Global"
		case 1:
			return "Highway"
		case 2:
			return "Agriculture"
		case 3:
			return "Construction"
		case 4:
			return "Marine"
		case 5:
			return "Industrial"
	default:
		return fmt.Sprintf("%s(%d)", "IndustryCodeConst", int(e))
	}
}

type ManufacturerCodeConst uint16
const (
	ARKSEnterprisesInc	ManufacturerCodeConst = 69
	FWMurphyEnovationControls	ManufacturerCodeConst = 78
	TwinDisc	ManufacturerCodeConst = 80
	KohlerPowerSystems	ManufacturerCodeConst = 85
	HemisphereGPSInc	ManufacturerCodeConst = 88
	BEPMarine	ManufacturerCodeConst = 116
	Airmar	ManufacturerCodeConst = 135
	Maretron	ManufacturerCodeConst = 137
	Lowrance	ManufacturerCodeConst = 140
	MercuryMarine	ManufacturerCodeConst = 144
	NautibusElectronicGmbH	ManufacturerCodeConst = 147
	BlueWaterData	ManufacturerCodeConst = 148
	Westerbeke	ManufacturerCodeConst = 154
	OffshoreSystemsUKLtd	ManufacturerCodeConst = 161
	EvinrudeBRP	ManufacturerCodeConst = 163
	CPACSystemsAB	ManufacturerCodeConst = 165
	XantrexTechnologyInc	ManufacturerCodeConst = 168
	YanmarMarine	ManufacturerCodeConst = 172
	VolvoPenta	ManufacturerCodeConst = 174
	HondaMarine	ManufacturerCodeConst = 175
	CarlingTechnologiesIncMoritzAerospace	ManufacturerCodeConst = 176
	BeedeInstruments	ManufacturerCodeConst = 185
	FloscanInstrumentCoInc	ManufacturerCodeConst = 192
	Nobletec	ManufacturerCodeConst = 193
	MysticValleyCommunications	ManufacturerCodeConst = 198
	Actia	ManufacturerCodeConst = 199
	HondaMarine_2	ManufacturerCodeConst = 200
	DisenosYTechnologia	ManufacturerCodeConst = 201
	DigitalSwitchingSystems	ManufacturerCodeConst = 211
	XintexAtena	ManufacturerCodeConst = 215
	EMMINETWORKSL	ManufacturerCodeConst = 224
	HondaMarine_3	ManufacturerCodeConst = 225
	ZF	ManufacturerCodeConst = 228
	Garmin	ManufacturerCodeConst = 229
	YachtMonitoringSolutions	ManufacturerCodeConst = 233
	SailormadeMarineTelemetryTetraTechnologyLTD	ManufacturerCodeConst = 235
	Eride	ManufacturerCodeConst = 243
	HondaMarine_4	ManufacturerCodeConst = 250
	HondaMotorCompanyLTD	ManufacturerCodeConst = 257
	Groco	ManufacturerCodeConst = 272
	Actisense	ManufacturerCodeConst = 273
	AmphenolLTWTechnology	ManufacturerCodeConst = 274
	Navico	ManufacturerCodeConst = 275
	HamiltonJet	ManufacturerCodeConst = 283
	SeaRecovery	ManufacturerCodeConst = 285
	CoelmoSRLItaly	ManufacturerCodeConst = 286
	BEPMarine_2	ManufacturerCodeConst = 295
	EmpirBus	ManufacturerCodeConst = 304
	NovAtel	ManufacturerCodeConst = 305
	SleipnerMotorAS	ManufacturerCodeConst = 306
	MBWTechnologies	ManufacturerCodeConst = 307
	FischerPanda	ManufacturerCodeConst = 311
	ICOM	ManufacturerCodeConst = 315
	Qwerty	ManufacturerCodeConst = 328
	Dief	ManufacturerCodeConst = 329
	BoeningAutomationstechnologieGmbHAndCoKG	ManufacturerCodeConst = 341
	KoreanMaritimeUniversity	ManufacturerCodeConst = 345
	ThraneAndThrane	ManufacturerCodeConst = 351
	Mastervolt	ManufacturerCodeConst = 355
	FischerPandaGenerators	ManufacturerCodeConst = 356
	VictronEnergy	ManufacturerCodeConst = 358
	RollsRoyceMarine	ManufacturerCodeConst = 370
	ElectronicDesign	ManufacturerCodeConst = 373
	NorthernLights	ManufacturerCodeConst = 374
	Glendinning	ManufacturerCodeConst = 378
	BAndG	ManufacturerCodeConst = 381
	RosePointNavigationSystems	ManufacturerCodeConst = 384
	JohnsonOutdoorsMarineElectronicsIncGeonav	ManufacturerCodeConst = 385
	Capi2	ManufacturerCodeConst = 394
	BeyondMeasure	ManufacturerCodeConst = 396
	LivorsiMarine	ManufacturerCodeConst = 400
	ComNav	ManufacturerCodeConst = 404
	Chetco	ManufacturerCodeConst = 409
	FusionElectronics	ManufacturerCodeConst = 419
	StandardHorizon	ManufacturerCodeConst = 421
	TrueHeadingAB	ManufacturerCodeConst = 422
	EgersundMarineElectronicsAS	ManufacturerCodeConst = 426
	EmTrakMarineElectronics	ManufacturerCodeConst = 427
	TohatsuCoJP	ManufacturerCodeConst = 431
	DigitalYacht	ManufacturerCodeConst = 437
	ComarSystemsLimited	ManufacturerCodeConst = 438
	Cummins	ManufacturerCodeConst = 440
	VDOAkaContinentalCorporation	ManufacturerCodeConst = 443
	ParkerHannifinAkaVillageMarineTech	ManufacturerCodeConst = 451
	AlltekMarineElectronicsCorp	ManufacturerCodeConst = 459
	SANGIORGIOSEIN	ManufacturerCodeConst = 460
	VeethreeElectronicsAndMarine	ManufacturerCodeConst = 466
	HumminbirdMarineElectronics	ManufacturerCodeConst = 467
	SITEXMarineElectronics	ManufacturerCodeConst = 470
	SeaCrossMarineAB	ManufacturerCodeConst = 471
	GMEAkaStandardCommunicationsPtyLTD	ManufacturerCodeConst = 475
	HumminbirdMarineElectronics_2	ManufacturerCodeConst = 476
	OceanSatBV	ManufacturerCodeConst = 478
	ChetcoDigitialInstruments	ManufacturerCodeConst = 481
	Watcheye	ManufacturerCodeConst = 493
	LcjCapteurs	ManufacturerCodeConst = 499
	AttwoodMarine	ManufacturerCodeConst = 502
	NaviopSRL	ManufacturerCodeConst = 503
	VesperMarineLtd	ManufacturerCodeConst = 504
	MarinesoftCoLTD	ManufacturerCodeConst = 510
	NoLandEngineering	ManufacturerCodeConst = 517
	TransasUSA	ManufacturerCodeConst = 518
	NationalInstrumentsKorea	ManufacturerCodeConst = 529
	OnwaMarine	ManufacturerCodeConst = 532
	MarinecraftSouthKorea	ManufacturerCodeConst = 571
	McMurdoGroupAkaOroliaLTD	ManufacturerCodeConst = 573
	Advansea	ManufacturerCodeConst = 578
	KVH	ManufacturerCodeConst = 579
	SanJoseTechnology	ManufacturerCodeConst = 580
	YachtControl	ManufacturerCodeConst = 583
	SuzukiMotorCorporation	ManufacturerCodeConst = 586
	USCoastGuard	ManufacturerCodeConst = 591
	ShipModuleAkaCustomware	ManufacturerCodeConst = 595
	AquaticAV	ManufacturerCodeConst = 600
	AventicsGmbH	ManufacturerCodeConst = 605
	Intellian	ManufacturerCodeConst = 606
	SamwonIT	ManufacturerCodeConst = 612
	ArltTecnologies	ManufacturerCodeConst = 614
	BavariaYacts	ManufacturerCodeConst = 637
	DiverseYachtServices	ManufacturerCodeConst = 641
	WemaUSADbaKUS	ManufacturerCodeConst = 644
	Garmin_2	ManufacturerCodeConst = 645
	ShenzhenJiuzhouHimunication	ManufacturerCodeConst = 658
	RockfordCorp	ManufacturerCodeConst = 688
	JLAudio	ManufacturerCodeConst = 704
	Autonnic	ManufacturerCodeConst = 715
	YachtDevices	ManufacturerCodeConst = 717
	REAPSystems	ManufacturerCodeConst = 734
	AuElectronicsGroup	ManufacturerCodeConst = 735
	LxNav	ManufacturerCodeConst = 739
	DaeMyung	ManufacturerCodeConst = 743
	Woosung	ManufacturerCodeConst = 744
	ClarionUS	ManufacturerCodeConst = 773
	HMISystems	ManufacturerCodeConst = 776
	OceanSignal	ManufacturerCodeConst = 777
	Seekeeper	ManufacturerCodeConst = 778
	PolyPlanar	ManufacturerCodeConst = 781
	FischerPandaDE	ManufacturerCodeConst = 785
	BroydaIndustries	ManufacturerCodeConst = 795
	CanadianAutomotive	ManufacturerCodeConst = 796
	TidesMarine	ManufacturerCodeConst = 797
	Lumishore	ManufacturerCodeConst = 798
	StillWaterDesignsAndAudio	ManufacturerCodeConst = 799
	BJTechnologiesBeneteau	ManufacturerCodeConst = 802
	GillSensors	ManufacturerCodeConst = 803
	BlueWaterDesalination	ManufacturerCodeConst = 811
	FLIR	ManufacturerCodeConst = 815
	UndheimSystems	ManufacturerCodeConst = 824
	TeamSurv	ManufacturerCodeConst = 838
	FellMarine	ManufacturerCodeConst = 844
	Oceanvolt	ManufacturerCodeConst = 847
	Prospec	ManufacturerCodeConst = 862
	DataPanelCorp	ManufacturerCodeConst = 868
	L3Technologies	ManufacturerCodeConst = 890
	RhodanMarineSystems	ManufacturerCodeConst = 894
	NexfourSolutions	ManufacturerCodeConst = 896
	ASAElectronics	ManufacturerCodeConst = 905
	MarinesCoSouthKorea	ManufacturerCodeConst = 909
	NauticOn	ManufacturerCodeConst = 911
	Ecotronix	ManufacturerCodeConst = 930
	TimbolierIndustries	ManufacturerCodeConst = 962
	TJCMicro	ManufacturerCodeConst = 963
	CoxPowertrain	ManufacturerCodeConst = 968
	BlueSeas	ManufacturerCodeConst = 969
	TeleflexMarineSeaStarSolutions	ManufacturerCodeConst = 1850
	Raymarine	ManufacturerCodeConst = 1851
	Navionics	ManufacturerCodeConst = 1852
	JapanRadioCo	ManufacturerCodeConst = 1853
	NorthstarTechnologies	ManufacturerCodeConst = 1854
	Furuno	ManufacturerCodeConst = 1855
	Trimble	ManufacturerCodeConst = 1856
	Simrad	ManufacturerCodeConst = 1857
	Litton	ManufacturerCodeConst = 1858
	KvasarAB	ManufacturerCodeConst = 1859
	MMP	ManufacturerCodeConst = 1860
	VectorCantech	ManufacturerCodeConst = 1861
	YamahaMarine	ManufacturerCodeConst = 1862
	FariaInstruments	ManufacturerCodeConst = 1863
)

func (e ManufacturerCodeConst) GoString() string {return e.String() }
func (e ManufacturerCodeConst) String() string {
	switch e {
		case 69:
			return "ARKS Enterprises, Inc."
		case 78:
			return "FW Murphy/Enovation Controls"
		case 80:
			return "Twin Disc"
		case 85:
			return "Kohler Power Systems"
		case 88:
			return "Hemisphere GPS Inc"
		case 116:
			return "BEP Marine"
		case 135:
			return "Airmar"
		case 137:
			return "Maretron"
		case 140:
			return "Lowrance"
		case 144:
			return "Mercury Marine"
		case 147:
			return "Nautibus Electronic GmbH"
		case 148:
			return "Blue Water Data"
		case 154:
			return "Westerbeke"
		case 161:
			return "Offshore Systems (UK) Ltd."
		case 163:
			return "Evinrude/BRP"
		case 165:
			return "CPAC Systems AB"
		case 168:
			return "Xantrex Technology Inc."
		case 172:
			return "Yanmar Marine"
		case 174:
			return "Volvo Penta"
		case 175:
			return "Honda Marine"
		case 176:
			return "Carling Technologies Inc. (Moritz Aerospace)"
		case 185:
			return "Beede Instruments"
		case 192:
			return "Floscan Instrument Co. Inc."
		case 193:
			return "Nobletec"
		case 198:
			return "Mystic Valley Communications"
		case 199:
			return "Actia"
		case 200:
			return "Honda Marine"
		case 201:
			return "Disenos Y Technologia"
		case 211:
			return "Digital Switching Systems"
		case 215:
			return "Xintex/Atena"
		case 224:
			return "EMMI NETWORK S.L."
		case 225:
			return "Honda Marine"
		case 228:
			return "ZF"
		case 229:
			return "Garmin"
		case 233:
			return "Yacht Monitoring Solutions"
		case 235:
			return "Sailormade Marine Telemetry/Tetra Technology LTD"
		case 243:
			return "Eride"
		case 250:
			return "Honda Marine"
		case 257:
			return "Honda Motor Company LTD"
		case 272:
			return "Groco"
		case 273:
			return "Actisense"
		case 274:
			return "Amphenol LTW Technology"
		case 275:
			return "Navico"
		case 283:
			return "Hamilton Jet"
		case 285:
			return "Sea Recovery"
		case 286:
			return "Coelmo SRL Italy"
		case 295:
			return "BEP Marine"
		case 304:
			return "Empir Bus"
		case 305:
			return "NovAtel"
		case 306:
			return "Sleipner Motor AS"
		case 307:
			return "MBW Technologies"
		case 311:
			return "Fischer Panda"
		case 315:
			return "ICOM"
		case 328:
			return "Qwerty"
		case 329:
			return "Dief"
		case 341:
			return "Boening Automationstechnologie GmbH & Co. KG"
		case 345:
			return "Korean Maritime University"
		case 351:
			return "Thrane and Thrane"
		case 355:
			return "Mastervolt"
		case 356:
			return "Fischer Panda Generators"
		case 358:
			return "Victron Energy"
		case 370:
			return "Rolls Royce Marine"
		case 373:
			return "Electronic Design"
		case 374:
			return "Northern Lights"
		case 378:
			return "Glendinning"
		case 381:
			return "B & G"
		case 384:
			return "Rose Point Navigation Systems"
		case 385:
			return "Johnson Outdoors Marine Electronics Inc Geonav"
		case 394:
			return "Capi 2"
		case 396:
			return "Beyond Measure"
		case 400:
			return "Livorsi Marine"
		case 404:
			return "ComNav"
		case 409:
			return "Chetco"
		case 419:
			return "Fusion Electronics"
		case 421:
			return "Standard Horizon"
		case 422:
			return "True Heading AB"
		case 426:
			return "Egersund Marine Electronics AS"
		case 427:
			return "em-trak Marine Electronics"
		case 431:
			return "Tohatsu Co, JP"
		case 437:
			return "Digital Yacht"
		case 438:
			return "Comar Systems Limited"
		case 440:
			return "Cummins"
		case 443:
			return "VDO (aka Continental-Corporation)"
		case 451:
			return "Parker Hannifin aka Village Marine Tech"
		case 459:
			return "Alltek Marine Electronics Corp"
		case 460:
			return "SAN GIORGIO S.E.I.N"
		case 466:
			return "Veethree Electronics & Marine"
		case 467:
			return "Humminbird Marine Electronics"
		case 470:
			return "SI-TEX Marine Electronics"
		case 471:
			return "Sea Cross Marine AB"
		case 475:
			return "GME aka Standard Communications Pty LTD"
		case 476:
			return "Humminbird Marine Electronics"
		case 478:
			return "Ocean Sat BV"
		case 481:
			return "Chetco Digitial Instruments"
		case 493:
			return "Watcheye"
		case 499:
			return "Lcj Capteurs"
		case 502:
			return "Attwood Marine"
		case 503:
			return "Naviop S.R.L."
		case 504:
			return "Vesper Marine Ltd"
		case 510:
			return "Marinesoft Co. LTD"
		case 517:
			return "NoLand Engineering"
		case 518:
			return "Transas USA"
		case 529:
			return "National Instruments Korea"
		case 532:
			return "Onwa Marine"
		case 571:
			return "Marinecraft (South Korea)"
		case 573:
			return "McMurdo Group aka Orolia LTD"
		case 578:
			return "Advansea"
		case 579:
			return "KVH"
		case 580:
			return "San Jose Technology"
		case 583:
			return "Yacht Control"
		case 586:
			return "Suzuki Motor Corporation"
		case 591:
			return "US Coast Guard"
		case 595:
			return "Ship Module aka Customware"
		case 600:
			return "Aquatic AV"
		case 605:
			return "Aventics GmbH"
		case 606:
			return "Intellian"
		case 612:
			return "SamwonIT"
		case 614:
			return "Arlt Tecnologies"
		case 637:
			return "Bavaria Yacts"
		case 641:
			return "Diverse Yacht Services"
		case 644:
			return "Wema U.S.A dba KUS"
		case 645:
			return "Garmin"
		case 658:
			return "Shenzhen Jiuzhou Himunication"
		case 688:
			return "Rockford Corp"
		case 704:
			return "JL Audio"
		case 715:
			return "Autonnic"
		case 717:
			return "Yacht Devices"
		case 734:
			return "REAP Systems"
		case 735:
			return "Au Electronics Group"
		case 739:
			return "LxNav"
		case 743:
			return "DaeMyung"
		case 744:
			return "Woosung"
		case 773:
			return "Clarion US"
		case 776:
			return "HMI Systems"
		case 777:
			return "Ocean Signal"
		case 778:
			return "Seekeeper"
		case 781:
			return "Poly Planar"
		case 785:
			return "Fischer Panda DE"
		case 795:
			return "Broyda Industries"
		case 796:
			return "Canadian Automotive"
		case 797:
			return "Tides Marine"
		case 798:
			return "Lumishore"
		case 799:
			return "Still Water Designs and Audio"
		case 802:
			return "BJ Technologies (Beneteau)"
		case 803:
			return "Gill Sensors"
		case 811:
			return "Blue Water Desalination"
		case 815:
			return "FLIR"
		case 824:
			return "Undheim Systems"
		case 838:
			return "TeamSurv"
		case 844:
			return "Fell Marine"
		case 847:
			return "Oceanvolt"
		case 862:
			return "Prospec"
		case 868:
			return "Data Panel Corp"
		case 890:
			return "L3 Technologies"
		case 894:
			return "Rhodan Marine Systems"
		case 896:
			return "Nexfour Solutions"
		case 905:
			return "ASA Electronics"
		case 909:
			return "Marines Co (South Korea)"
		case 911:
			return "Nautic-on"
		case 930:
			return "Ecotronix"
		case 962:
			return "Timbolier Industries"
		case 963:
			return "TJC Micro"
		case 968:
			return "Cox Powertrain"
		case 969:
			return "Blue Seas"
		case 1850:
			return "Teleflex Marine (SeaStar Solutions)"
		case 1851:
			return "Raymarine"
		case 1852:
			return "Navionics"
		case 1853:
			return "Japan Radio Co"
		case 1854:
			return "Northstar Technologies"
		case 1855:
			return "Furuno"
		case 1856:
			return "Trimble"
		case 1857:
			return "Simrad"
		case 1858:
			return "Litton"
		case 1859:
			return "Kvasar AB"
		case 1860:
			return "MMP"
		case 1861:
			return "Vector Cantech"
		case 1862:
			return "Yamaha Marine"
		case 1863:
			return "Faria Instruments"
	default:
		return fmt.Sprintf("%s(%d)", "ManufacturerCodeConst", int(e))
	}
}

type AisMessageIdConst uint8
const (
	ScheduledClassAPositionReport	AisMessageIdConst = 1
	AssignedScheduledClassAPositionReport	AisMessageIdConst = 2
	InterrogatedClassAPositionReport	AisMessageIdConst = 3
	BaseStationReport	AisMessageIdConst = 4
	StaticAndVoyageRelatedData	AisMessageIdConst = 5
	BinaryAddressedMessage	AisMessageIdConst = 6
	BinaryAcknowledgement	AisMessageIdConst = 7
	BinaryBroadcastMessage	AisMessageIdConst = 8
	StandardSARAircraftPositionReport	AisMessageIdConst = 9
	UTCDateInquiry	AisMessageIdConst = 10
	UTCDateResponse	AisMessageIdConst = 11
	SafetyRelatedAddressedMessage	AisMessageIdConst = 12
	SafetyRelatedAcknowledgement	AisMessageIdConst = 13
	SatetyRelatedBroadcastMessage	AisMessageIdConst = 14
	Interrogation	AisMessageIdConst = 15
	AssignmentModeCommand	AisMessageIdConst = 16
	DGNSSBroadcastBinaryMessage	AisMessageIdConst = 17
	StandardClassBPositionReport	AisMessageIdConst = 18
	ExtendedClassBPositionReport	AisMessageIdConst = 19
	DataLinkManagementMessage	AisMessageIdConst = 20
	ATONReport	AisMessageIdConst = 21
	ChannelManagement	AisMessageIdConst = 22
	GroupAssignmentCommand	AisMessageIdConst = 23
	StaticDataReport	AisMessageIdConst = 24
	SingleSlotBinaryMessage	AisMessageIdConst = 25
	MultipleSlotBinaryMessage	AisMessageIdConst = 26
	PositionReportForLongRangeApplications	AisMessageIdConst = 27
)

func (e AisMessageIdConst) GoString() string {return e.String() }
func (e AisMessageIdConst) String() string {
	switch e {
		case 1:
			return "Scheduled Class A position report"
		case 2:
			return "Assigned scheduled Class A position report"
		case 3:
			return "Interrogated Class A position report"
		case 4:
			return "Base station report"
		case 5:
			return "Static and voyage related data"
		case 6:
			return "Binary addressed message"
		case 7:
			return "Binary acknowledgement"
		case 8:
			return "Binary broadcast message"
		case 9:
			return "Standard SAR aircraft position report"
		case 10:
			return "UTC/date inquiry"
		case 11:
			return "UTC/date response"
		case 12:
			return "Safety related addressed message"
		case 13:
			return "Safety related acknowledgement"
		case 14:
			return "Satety related broadcast message"
		case 15:
			return "Interrogation"
		case 16:
			return "Assignment mode command"
		case 17:
			return "DGNSS broadcast binary message"
		case 18:
			return "Standard Class B position report"
		case 19:
			return "Extended Class B position report"
		case 20:
			return "Data link management message"
		case 21:
			return "ATON report"
		case 22:
			return "Channel management"
		case 23:
			return "Group assignment command"
		case 24:
			return "Static data report"
		case 25:
			return "Single slot binary message"
		case 26:
			return "Multiple slot binary message"
		case 27:
			return "Position report for long range applications"
	default:
		return fmt.Sprintf("%s(%d)", "AisMessageIdConst", int(e))
	}
}

type ShipTypeConst uint8
const (
	Unavailable	ShipTypeConst = 0
	WingInGround	ShipTypeConst = 20
	WingInGroundHazardCatX	ShipTypeConst = 21
	WingInGroundHazardCatY	ShipTypeConst = 22
	WingInGroundHazardCatZ	ShipTypeConst = 23
	WingInGroundHazardCatOS	ShipTypeConst = 24
	WingInGroundNoAdditionalInformation	ShipTypeConst = 29
	Fishing	ShipTypeConst = 30
	Towing	ShipTypeConst = 31
	TowingExceeds200mOrWiderThan25m	ShipTypeConst = 32
	EngagedInDredgingOrUnderwaterOperations	ShipTypeConst = 33
	EngagedInDivingOperations	ShipTypeConst = 34
	EngagedInMilitaryOperations	ShipTypeConst = 35
	Sailing	ShipTypeConst = 36
	Pleasure	ShipTypeConst = 37
	HighSpeedCraft	ShipTypeConst = 40
	HighSpeedCraftHazardCatX	ShipTypeConst = 41
	HighSpeedCraftHazardCatY	ShipTypeConst = 42
	HighSpeedCraftHazardCatZ	ShipTypeConst = 43
	HighSpeedCraftHazardCatOS	ShipTypeConst = 44
	HighSpeedCraftNoAdditionalInformation	ShipTypeConst = 49
	PilotVessel	ShipTypeConst = 50
	SAR	ShipTypeConst = 51
	Tug	ShipTypeConst = 52
	PortTender	ShipTypeConst = 53
	AntiPollution	ShipTypeConst = 54
	LawEnforcement	ShipTypeConst = 55
	Spare	ShipTypeConst = 56
	Spare2	ShipTypeConst = 57
	Medical	ShipTypeConst = 58
	ShipsAndAircraftOfStatesNotPartiesToAnArmedConflict	ShipTypeConst = 59
	PassengerShip	ShipTypeConst = 60
	PassengerShipHazardCatX	ShipTypeConst = 61
	PassengerShipHazardCatY	ShipTypeConst = 62
	PassengerShipHazardCatZ	ShipTypeConst = 63
	PassengerShipHazardCatOS	ShipTypeConst = 64
	PassengerShipNoAdditionalInformation	ShipTypeConst = 69
	CargoShip	ShipTypeConst = 70
	CargoShipHazardCatX	ShipTypeConst = 71
	CargoShipHazardCatY	ShipTypeConst = 72
	CargoShipHazardCatZ	ShipTypeConst = 73
	CargoShipHazardCatOS	ShipTypeConst = 74
	CargoShipNoAdditionalInformation	ShipTypeConst = 79
	Tanker	ShipTypeConst = 80
	TankerHazardCatX	ShipTypeConst = 81
	TankerHazardCatY	ShipTypeConst = 82
	TankerHazardCatZ	ShipTypeConst = 83
	TankerHazardCatOS	ShipTypeConst = 84
	TankerNoAdditionalInformation	ShipTypeConst = 89
	Other	ShipTypeConst = 90
	OtherHazardCatX	ShipTypeConst = 91
	OtherHazardCatY	ShipTypeConst = 92
	OtherHazardCatZ	ShipTypeConst = 93
	OtherHazardCatOS	ShipTypeConst = 94
	OtherNoAdditionalInformation	ShipTypeConst = 99
)

func (e ShipTypeConst) GoString() string {return e.String() }
func (e ShipTypeConst) String() string {
	switch e {
		case 0:
			return "Unavailable"
		case 20:
			return "Wing In Ground"
		case 21:
			return "Wing In Ground (hazard cat X)"
		case 22:
			return "Wing In Ground (hazard cat Y)"
		case 23:
			return "Wing In Ground (hazard cat Z)"
		case 24:
			return "Wing In Ground (hazard cat OS)"
		case 29:
			return "Wing In Ground (no additional information)"
		case 30:
			return "Fishing"
		case 31:
			return "Towing"
		case 32:
			return "Towing exceeds 200m or wider than 25m"
		case 33:
			return "Engaged in dredging or underwater operations"
		case 34:
			return "Engaged in diving operations"
		case 35:
			return "Engaged in military operations"
		case 36:
			return "Sailing"
		case 37:
			return "Pleasure"
		case 40:
			return "High speed craft"
		case 41:
			return "High speed craft (hazard cat X)"
		case 42:
			return "High speed craft (hazard cat Y)"
		case 43:
			return "High speed craft (hazard cat Z)"
		case 44:
			return "High speed craft (hazard cat OS)"
		case 49:
			return "High speed craft (no additional information)"
		case 50:
			return "Pilot vessel"
		case 51:
			return "SAR"
		case 52:
			return "Tug"
		case 53:
			return "Port tender"
		case 54:
			return "Anti-pollution"
		case 55:
			return "Law enforcement"
		case 56:
			return "Spare"
		case 57:
			return "Spare #2"
		case 58:
			return "Medical"
		case 59:
			return "Ships and aircraft of States not parties to an armed conflict"
		case 60:
			return "Passenger ship"
		case 61:
			return "Passenger ship (hazard cat X)"
		case 62:
			return "Passenger ship (hazard cat Y)"
		case 63:
			return "Passenger ship (hazard cat Z)"
		case 64:
			return "Passenger ship (hazard cat OS)"
		case 69:
			return "Passenger ship (no additional information)"
		case 70:
			return "Cargo ship"
		case 71:
			return "Cargo ship (hazard cat X)"
		case 72:
			return "Cargo ship (hazard cat Y)"
		case 73:
			return "Cargo ship (hazard cat Z)"
		case 74:
			return "Cargo ship (hazard cat OS)"
		case 79:
			return "Cargo ship (no additional information)"
		case 80:
			return "Tanker"
		case 81:
			return "Tanker (hazard cat X)"
		case 82:
			return "Tanker (hazard cat Y)"
		case 83:
			return "Tanker (hazard cat Z)"
		case 84:
			return "Tanker (hazard cat OS)"
		case 89:
			return "Tanker (no additional information)"
		case 90:
			return "Other"
		case 91:
			return "Other (hazard cat X)"
		case 92:
			return "Other (hazard cat Y)"
		case 93:
			return "Other (hazard cat Z)"
		case 94:
			return "Other (hazard cat OS)"
		case 99:
			return "Other (no additional information)"
	default:
		return fmt.Sprintf("%s(%d)", "ShipTypeConst", int(e))
	}
}

type DeviceClassConst uint8
const (
	ReservedFor2000Use	DeviceClassConst = 0
	SystemTools	DeviceClassConst = 10
	SafetySystems	DeviceClassConst = 20
	InternetworkDevice	DeviceClassConst = 25
	ElectricalDistribution	DeviceClassConst = 30
	ElectricalGeneration	DeviceClassConst = 35
	SteeringAndControlSurfaces	DeviceClassConst = 40
	Propulsion	DeviceClassConst = 50
	Navigation	DeviceClassConst = 60
	Communication	DeviceClassConst = 70
	SensorCommunicationInterface	DeviceClassConst = 75
	InstrumentationGeneralSystems	DeviceClassConst = 80
	ExternalEnvironment	DeviceClassConst = 85
	InternalEnvironment	DeviceClassConst = 90
	DeckCargoFishingEquipmentSystems	DeviceClassConst = 100
	HumanInterface	DeviceClassConst = 110
	Display	DeviceClassConst = 120
	Entertainment	DeviceClassConst = 125
)

func (e DeviceClassConst) GoString() string {return e.String() }
func (e DeviceClassConst) String() string {
	switch e {
		case 0:
			return "Reserved for 2000 Use"
		case 10:
			return "System tools"
		case 20:
			return "Safety systems"
		case 25:
			return "Internetwork device"
		case 30:
			return "Electrical Distribution"
		case 35:
			return "Electrical Generation"
		case 40:
			return "Steering and Control surfaces"
		case 50:
			return "Propulsion"
		case 60:
			return "Navigation"
		case 70:
			return "Communication"
		case 75:
			return "Sensor Communication Interface"
		case 80:
			return "Instrumentation/general systems"
		case 85:
			return "External Environment"
		case 90:
			return "Internal Environment"
		case 100:
			return "Deck + cargo + fishing equipment systems"
		case 110:
			return "Human Interface"
		case 120:
			return "Display"
		case 125:
			return "Entertainment"
	default:
		return fmt.Sprintf("%s(%d)", "DeviceClassConst", int(e))
	}
}

type RepeatIndicatorConst uint8
const (
	Initial	RepeatIndicatorConst = 0
	FirstRetransmission	RepeatIndicatorConst = 1
	SecondRetransmission	RepeatIndicatorConst = 2
	FinalRetransmission	RepeatIndicatorConst = 3
)

func (e RepeatIndicatorConst) GoString() string {return e.String() }
func (e RepeatIndicatorConst) String() string {
	switch e {
		case 0:
			return "Initial"
		case 1:
			return "First retransmission"
		case 2:
			return "Second retransmission"
		case 3:
			return "Final retransmission"
	default:
		return fmt.Sprintf("%s(%d)", "RepeatIndicatorConst", int(e))
	}
}

type TxRxModeConst uint8
const (
	TxATxBRxARxB	TxRxModeConst = 0
	TxARxARxB	TxRxModeConst = 1
	TxBRxARxB	TxRxModeConst = 2
)

func (e TxRxModeConst) GoString() string {return e.String() }
func (e TxRxModeConst) String() string {
	switch e {
		case 0:
			return "Tx A/Tx B, Rx A/Rx B"
		case 1:
			return "Tx A, Rx A/Rx B"
		case 2:
			return "Tx B, Rx A/Rx B"
	default:
		return fmt.Sprintf("%s(%d)", "TxRxModeConst", int(e))
	}
}

type StationTypeConst uint8
const (
	AllTypesOfMobileStation	StationTypeConst = 0
	AllTypesOfClassBMobileStation	StationTypeConst = 2
	SARAirborneMobileStation	StationTypeConst = 3
	AtoNStation	StationTypeConst = 4
	ClassBCSShipborneMobileStation	StationTypeConst = 5
	InlandWaterways	StationTypeConst = 6
	RegionalUse7	StationTypeConst = 7
	RegionalUse8	StationTypeConst = 8
	RegionalUse9	StationTypeConst = 9
)

func (e StationTypeConst) GoString() string {return e.String() }
func (e StationTypeConst) String() string {
	switch e {
		case 0:
			return "All types of mobile station"
		case 2:
			return "All types of Class B mobile station"
		case 3:
			return "SAR airborne mobile station"
		case 4:
			return "AtoN station"
		case 5:
			return "Class B CS shipborne mobile station"
		case 6:
			return "Inland waterways"
		case 7:
			return "Regional use 7"
		case 8:
			return "Regional use 8"
		case 9:
			return "Regional use 9"
	default:
		return fmt.Sprintf("%s(%d)", "StationTypeConst", int(e))
	}
}

type ReportingIntervalConst uint8
const (
	AsGivenByTheAutonomousMode	ReportingIntervalConst = 0
	A10Min	ReportingIntervalConst = 1
	A6Min	ReportingIntervalConst = 2
	A3Min	ReportingIntervalConst = 3
	A1Min	ReportingIntervalConst = 4
	A30Sec	ReportingIntervalConst = 5
	A15Sec	ReportingIntervalConst = 6
	A10Sec	ReportingIntervalConst = 7
	A5Sec	ReportingIntervalConst = 8
	A2SecNotApplicableToClassBCS	ReportingIntervalConst = 9
	NextShorterReportingInterval	ReportingIntervalConst = 10
	NextLongerReportingInterval	ReportingIntervalConst = 11
)

func (e ReportingIntervalConst) GoString() string {return e.String() }
func (e ReportingIntervalConst) String() string {
	switch e {
		case 0:
			return "As given by the autonomous mode"
		case 1:
			return "A10 min"
		case 2:
			return "A6 min"
		case 3:
			return "A3 min"
		case 4:
			return "A1 min"
		case 5:
			return "A30 sec"
		case 6:
			return "A15 sec"
		case 7:
			return "A10 sec"
		case 8:
			return "A5 sec"
		case 9:
			return "A2 sec (not applicable to Class B CS)"
		case 10:
			return "Next shorter reporting interval"
		case 11:
			return "Next longer reporting interval"
	default:
		return fmt.Sprintf("%s(%d)", "ReportingIntervalConst", int(e))
	}
}

type AisTransceiverConst uint8
const (
	ChannelAVDLReception	AisTransceiverConst = 0
	ChannelBVDLReception	AisTransceiverConst = 1
	ChannelAVDLTransmission	AisTransceiverConst = 2
	ChannelBVDLTransmission	AisTransceiverConst = 3
	OwnInformationNotBroadcast	AisTransceiverConst = 4
	Reserved	AisTransceiverConst = 5
)

func (e AisTransceiverConst) GoString() string {return e.String() }
func (e AisTransceiverConst) String() string {
	switch e {
		case 0:
			return "Channel A VDL reception"
		case 1:
			return "Channel B VDL reception"
		case 2:
			return "Channel A VDL transmission"
		case 3:
			return "Channel B VDL transmission"
		case 4:
			return "Own information not broadcast"
		case 5:
			return "Reserved"
	default:
		return fmt.Sprintf("%s(%d)", "AisTransceiverConst", int(e))
	}
}

type AisAssignedModeConst uint8
const (
	AutonomousAndContinuous	AisAssignedModeConst = 0
	AssignedMode	AisAssignedModeConst = 1
)

func (e AisAssignedModeConst) GoString() string {return e.String() }
func (e AisAssignedModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous and continuous"
		case 1:
			return "Assigned mode"
	default:
		return fmt.Sprintf("%s(%d)", "AisAssignedModeConst", int(e))
	}
}

type AtonTypeConst uint8
const (
	DefaultTypeOfAtoNNotSpecified	AtonTypeConst = 0
	ReferencePoint	AtonTypeConst = 1
	RACON	AtonTypeConst = 2
	FixedStructureOffShore	AtonTypeConst = 3
	ReservedForFutureUse	AtonTypeConst = 4
	FixedLightWithoutSectors	AtonTypeConst = 5
	FixedLightWithSectors	AtonTypeConst = 6
	FixedLeadingLightFront	AtonTypeConst = 7
	FixedLeadingLightRear	AtonTypeConst = 8
	FixedBeaconCardinalN	AtonTypeConst = 9
	FixedBeaconCardinalE	AtonTypeConst = 10
	FixedBeaconCardinalS	AtonTypeConst = 11
	FixedBeaconCardinalW	AtonTypeConst = 12
	FixedBeaconPortHand	AtonTypeConst = 13
	FixedBeaconStarboardHand	AtonTypeConst = 14
	FixedBeaconPreferredChannelPortHand	AtonTypeConst = 15
	FixedBeaconPreferredChannelStarboardHand	AtonTypeConst = 16
	FixedBeaconIsolatedDanger	AtonTypeConst = 17
	FixedBeaconSafeWater	AtonTypeConst = 18
	FixedBeaconSpecialMark	AtonTypeConst = 19
	FloatingAtoNCardinalN	AtonTypeConst = 20
	FloatingAtoNCardinalE	AtonTypeConst = 21
	FloatingAtoNCardinalS	AtonTypeConst = 22
	FloatingAtoNCardinalW	AtonTypeConst = 23
	FloatingAtoNPortHandMark	AtonTypeConst = 24
	FloatingAtoNStarboardHandMark	AtonTypeConst = 25
	FloatingAtoNPreferredChannelPortHand	AtonTypeConst = 26
	FloatingAtoNPreferredChannelStarboardHand	AtonTypeConst = 27
	FloatingAtoNIsolatedDanger	AtonTypeConst = 28
	FloatingAtoNSafeWater	AtonTypeConst = 29
	FloatingAtoNSpecialMark	AtonTypeConst = 30
	FloatingAtoNLightVesselLANBYRigs	AtonTypeConst = 31
)

func (e AtonTypeConst) GoString() string {return e.String() }
func (e AtonTypeConst) String() string {
	switch e {
		case 0:
			return "Default: Type of AtoN not specified"
		case 1:
			return "Reference point"
		case 2:
			return "RACON"
		case 3:
			return "Fixed structure off-shore"
		case 4:
			return "Reserved for future use"
		case 5:
			return "Fixed light: without sectors"
		case 6:
			return "Fixed light: with sectors"
		case 7:
			return "Fixed leading light front"
		case 8:
			return "Fixed leading light rear"
		case 9:
			return "Fixed beacon: cardinal N"
		case 10:
			return "Fixed beacon: cardinal E"
		case 11:
			return "Fixed beacon: cardinal S"
		case 12:
			return "Fixed beacon: cardinal W"
		case 13:
			return "Fixed beacon: port hand"
		case 14:
			return "Fixed beacon: starboard hand"
		case 15:
			return "Fixed beacon: preferred channel port hand"
		case 16:
			return "Fixed beacon: preferred channel starboard hand"
		case 17:
			return "Fixed beacon: isolated danger"
		case 18:
			return "Fixed beacon: safe water"
		case 19:
			return "Fixed beacon: special mark"
		case 20:
			return "Floating AtoN: cardinal N"
		case 21:
			return "Floating AtoN: cardinal E"
		case 22:
			return "Floating AtoN: cardinal S"
		case 23:
			return "Floating AtoN: cardinal W"
		case 24:
			return "Floating AtoN: port hand mark"
		case 25:
			return "Floating AtoN: starboard hand mark"
		case 26:
			return "Floating AtoN: preferred channel port hand"
		case 27:
			return "Floating AtoN: preferred channel starboard hand"
		case 28:
			return "Floating AtoN: isolated danger"
		case 29:
			return "Floating AtoN: safe water"
		case 30:
			return "Floating AtoN: special mark"
		case 31:
			return "Floating AtoN: light vessel/LANBY/rigs"
	default:
		return fmt.Sprintf("%s(%d)", "AtonTypeConst", int(e))
	}
}

type AisSpecialManeuverConst uint8
const (
	NotAvailable	AisSpecialManeuverConst = 0
	NotEngagedInSpecialManeuver	AisSpecialManeuverConst = 1
	EngagedInSpecialManeuver	AisSpecialManeuverConst = 2
	Reserved_2	AisSpecialManeuverConst = 3
)

func (e AisSpecialManeuverConst) GoString() string {return e.String() }
func (e AisSpecialManeuverConst) String() string {
	switch e {
		case 0:
			return "Not available"
		case 1:
			return "Not engaged in special maneuver"
		case 2:
			return "Engaged in special maneuver"
		case 3:
			return "Reserved"
	default:
		return fmt.Sprintf("%s(%d)", "AisSpecialManeuverConst", int(e))
	}
}

type PositionFixDeviceConst uint8
const (
	DefaultUndefined	PositionFixDeviceConst = 0
	GPS	PositionFixDeviceConst = 1
	GLONASS	PositionFixDeviceConst = 2
	CombinedGPSGLONASS	PositionFixDeviceConst = 3
	LoranC	PositionFixDeviceConst = 4
	Chayka	PositionFixDeviceConst = 5
	IntegratedNavigationSystem	PositionFixDeviceConst = 6
	Surveyed	PositionFixDeviceConst = 7
	Galileo	PositionFixDeviceConst = 8
	InternalGNSS	PositionFixDeviceConst = 15
)

func (e PositionFixDeviceConst) GoString() string {return e.String() }
func (e PositionFixDeviceConst) String() string {
	switch e {
		case 0:
			return "Default: undefined"
		case 1:
			return "GPS"
		case 2:
			return "GLONASS"
		case 3:
			return "Combined GPS/GLONASS"
		case 4:
			return "Loran-C"
		case 5:
			return "Chayka"
		case 6:
			return "Integrated navigation system"
		case 7:
			return "Surveyed"
		case 8:
			return "Galileo"
		case 15:
			return "Internal GNSS"
	default:
		return fmt.Sprintf("%s(%d)", "PositionFixDeviceConst", int(e))
	}
}

type GnsConst uint8
const (
	GPS_2	GnsConst = 0
	GLONASS_2	GnsConst = 1
	GPSGLONASS	GnsConst = 2
	GPSSBASWAAS	GnsConst = 3
	GPSSBASWAASGLONASS	GnsConst = 4
	Chayka_2	GnsConst = 5
	Integrated	GnsConst = 6
	Surveyed_2	GnsConst = 7
	Galileo_2	GnsConst = 8
)

func (e GnsConst) GoString() string {return e.String() }
func (e GnsConst) String() string {
	switch e {
		case 0:
			return "GPS"
		case 1:
			return "GLONASS"
		case 2:
			return "GPS+GLONASS"
		case 3:
			return "GPS+SBAS/WAAS"
		case 4:
			return "GPS+SBAS/WAAS+GLONASS"
		case 5:
			return "Chayka"
		case 6:
			return "integrated"
		case 7:
			return "surveyed"
		case 8:
			return "Galileo"
	default:
		return fmt.Sprintf("%s(%d)", "GnsConst", int(e))
	}
}

type EngineInstanceConst uint8
const (
	SingleEngineOrDualEnginePort	EngineInstanceConst = 0
	DualEngineStarboard	EngineInstanceConst = 1
)

func (e EngineInstanceConst) GoString() string {return e.String() }
func (e EngineInstanceConst) String() string {
	switch e {
		case 0:
			return "Single Engine or Dual Engine Port"
		case 1:
			return "Dual Engine Starboard"
	default:
		return fmt.Sprintf("%s(%d)", "EngineInstanceConst", int(e))
	}
}

type GearStatusConst uint8
const (
	Forward	GearStatusConst = 0
	Neutral	GearStatusConst = 1
	Reverse	GearStatusConst = 2
)

func (e GearStatusConst) GoString() string {return e.String() }
func (e GearStatusConst) String() string {
	switch e {
		case 0:
			return "Forward"
		case 1:
			return "Neutral"
		case 2:
			return "Reverse"
	default:
		return fmt.Sprintf("%s(%d)", "GearStatusConst", int(e))
	}
}

type DirectionConst uint8
const (
	Forward_2	DirectionConst = 0
	Reverse_2	DirectionConst = 1
)

func (e DirectionConst) GoString() string {return e.String() }
func (e DirectionConst) String() string {
	switch e {
		case 0:
			return "Forward"
		case 1:
			return "Reverse"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionConst", int(e))
	}
}

type PositionAccuracyConst uint8
const (
	Low	PositionAccuracyConst = 0
	High	PositionAccuracyConst = 1
)

func (e PositionAccuracyConst) GoString() string {return e.String() }
func (e PositionAccuracyConst) String() string {
	switch e {
		case 0:
			return "Low"
		case 1:
			return "High"
	default:
		return fmt.Sprintf("%s(%d)", "PositionAccuracyConst", int(e))
	}
}

type RaimFlagConst uint8
const (
	NotInUse	RaimFlagConst = 0
	InUse	RaimFlagConst = 1
)

func (e RaimFlagConst) GoString() string {return e.String() }
func (e RaimFlagConst) String() string {
	switch e {
		case 0:
			return "not in use"
		case 1:
			return "in use"
	default:
		return fmt.Sprintf("%s(%d)", "RaimFlagConst", int(e))
	}
}

type TimeStampConst uint8
const (
	NotAvailable_2	TimeStampConst = 60
	ManualInputMode	TimeStampConst = 61
	DeadReckoningMode	TimeStampConst = 62
	PositioningSystemIsInoperative	TimeStampConst = 63
)

func (e TimeStampConst) GoString() string {return e.String() }
func (e TimeStampConst) String() string {
	switch e {
		case 60:
			return "Not available"
		case 61:
			return "Manual input mode"
		case 62:
			return "Dead reckoning mode"
		case 63:
			return "Positioning system is inoperative"
	default:
		return fmt.Sprintf("%s(%d)", "TimeStampConst", int(e))
	}
}

type GnsMethodConst uint8
const (
	NoGNSS	GnsMethodConst = 0
	GNSSFix	GnsMethodConst = 1
	DGNSSFix	GnsMethodConst = 2
	PreciseGNSS	GnsMethodConst = 3
	RTKFixedInteger	GnsMethodConst = 4
	RTKFloat	GnsMethodConst = 5
	EstimatedDRMode	GnsMethodConst = 6
	ManualInput	GnsMethodConst = 7
	SimulateMode	GnsMethodConst = 8
)

func (e GnsMethodConst) GoString() string {return e.String() }
func (e GnsMethodConst) String() string {
	switch e {
		case 0:
			return "no GNSS"
		case 1:
			return "GNSS fix"
		case 2:
			return "DGNSS fix"
		case 3:
			return "Precise GNSS"
		case 4:
			return "RTK Fixed Integer"
		case 5:
			return "RTK float"
		case 6:
			return "Estimated (DR) mode"
		case 7:
			return "Manual Input"
		case 8:
			return "Simulate mode"
	default:
		return fmt.Sprintf("%s(%d)", "GnsMethodConst", int(e))
	}
}

type GnsIntegrityConst uint8
const (
	NoIntegrityChecking	GnsIntegrityConst = 0
	Safe	GnsIntegrityConst = 1
	Caution	GnsIntegrityConst = 2
)

func (e GnsIntegrityConst) GoString() string {return e.String() }
func (e GnsIntegrityConst) String() string {
	switch e {
		case 0:
			return "No integrity checking"
		case 1:
			return "Safe"
		case 2:
			return "Caution"
	default:
		return fmt.Sprintf("%s(%d)", "GnsIntegrityConst", int(e))
	}
}

type SystemTimeConst uint8
const (
	GPS_3	SystemTimeConst = 0
	GLONASS_3	SystemTimeConst = 1
	RadioStation	SystemTimeConst = 2
	LocalCesiumClock	SystemTimeConst = 3
	LocalRubidiumClock	SystemTimeConst = 4
	LocalCrystalClock	SystemTimeConst = 5
)

func (e SystemTimeConst) GoString() string {return e.String() }
func (e SystemTimeConst) String() string {
	switch e {
		case 0:
			return "GPS"
		case 1:
			return "GLONASS"
		case 2:
			return "Radio Station"
		case 3:
			return "Local Cesium clock"
		case 4:
			return "Local Rubidium clock"
		case 5:
			return "Local Crystal clock"
	default:
		return fmt.Sprintf("%s(%d)", "SystemTimeConst", int(e))
	}
}

type MagneticVariationConst uint8
const (
	Manual	MagneticVariationConst = 0
	AutomaticChart	MagneticVariationConst = 1
	AutomaticTable	MagneticVariationConst = 2
	AutomaticCalculation	MagneticVariationConst = 3
	WMM2000	MagneticVariationConst = 4
	WMM2005	MagneticVariationConst = 5
	WMM2010	MagneticVariationConst = 6
	WMM2015	MagneticVariationConst = 7
	WMM2020	MagneticVariationConst = 8
)

func (e MagneticVariationConst) GoString() string {return e.String() }
func (e MagneticVariationConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Automatic Chart"
		case 2:
			return "Automatic Table"
		case 3:
			return "Automatic Calculation"
		case 4:
			return "WMM 2000"
		case 5:
			return "WMM 2005"
		case 6:
			return "WMM 2010"
		case 7:
			return "WMM 2015"
		case 8:
			return "WMM 2020"
	default:
		return fmt.Sprintf("%s(%d)", "MagneticVariationConst", int(e))
	}
}

type ResidualModeConst uint8
const (
	Autonomous	ResidualModeConst = 0
	DifferentialEnhanced	ResidualModeConst = 1
	Estimated	ResidualModeConst = 2
	Simulator	ResidualModeConst = 3
	Manual_2	ResidualModeConst = 4
)

func (e ResidualModeConst) GoString() string {return e.String() }
func (e ResidualModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous"
		case 1:
			return "Differential enhanced"
		case 2:
			return "Estimated"
		case 3:
			return "Simulator"
		case 4:
			return "Manual"
	default:
		return fmt.Sprintf("%s(%d)", "ResidualModeConst", int(e))
	}
}

type WindReferenceConst uint8
const (
	TrueGroundReferencedToNorth	WindReferenceConst = 0
	MagneticGroundReferencedToMagneticNorth	WindReferenceConst = 1
	Apparent	WindReferenceConst = 2
	TrueBoatReferenced	WindReferenceConst = 3
	TrueWaterReferenced	WindReferenceConst = 4
)

func (e WindReferenceConst) GoString() string {return e.String() }
func (e WindReferenceConst) String() string {
	switch e {
		case 0:
			return "True (ground referenced to North)"
		case 1:
			return "Magnetic (ground referenced to Magnetic North)"
		case 2:
			return "Apparent"
		case 3:
			return "True (boat referenced)"
		case 4:
			return "True (water referenced)"
	default:
		return fmt.Sprintf("%s(%d)", "WindReferenceConst", int(e))
	}
}

type WaterReferenceConst uint8
const (
	PaddleWheel	WaterReferenceConst = 0
	PitotTube	WaterReferenceConst = 1
	Doppler	WaterReferenceConst = 2
	CorrelationUltraSound	WaterReferenceConst = 3
	ElectroMagnetic	WaterReferenceConst = 4
)

func (e WaterReferenceConst) GoString() string {return e.String() }
func (e WaterReferenceConst) String() string {
	switch e {
		case 0:
			return "Paddle wheel"
		case 1:
			return "Pitot tube"
		case 2:
			return "Doppler"
		case 3:
			return "Correlation (ultra sound)"
		case 4:
			return "Electro Magnetic"
	default:
		return fmt.Sprintf("%s(%d)", "WaterReferenceConst", int(e))
	}
}

type YesNoConst uint8
const (
	No	YesNoConst = 0
	Yes	YesNoConst = 1
)

func (e YesNoConst) GoString() string {return e.String() }
func (e YesNoConst) String() string {
	switch e {
		case 0:
			return "No"
		case 1:
			return "Yes"
	default:
		return fmt.Sprintf("%s(%d)", "YesNoConst", int(e))
	}
}

type OkWarningConst uint8
const (
	OK	OkWarningConst = 0
	Warning	OkWarningConst = 1
)

func (e OkWarningConst) GoString() string {return e.String() }
func (e OkWarningConst) String() string {
	switch e {
		case 0:
			return "OK"
		case 1:
			return "Warning"
	default:
		return fmt.Sprintf("%s(%d)", "OkWarningConst", int(e))
	}
}

type OffOnConst uint8
const (
	Off	OffOnConst = 0
	On	OffOnConst = 1
)

func (e OffOnConst) GoString() string {return e.String() }
func (e OffOnConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "On"
	default:
		return fmt.Sprintf("%s(%d)", "OffOnConst", int(e))
	}
}

type DirectionReferenceConst uint8
const (
	True	DirectionReferenceConst = 0
	Magnetic	DirectionReferenceConst = 1
	Error	DirectionReferenceConst = 2
)

func (e DirectionReferenceConst) GoString() string {return e.String() }
func (e DirectionReferenceConst) String() string {
	switch e {
		case 0:
			return "True"
		case 1:
			return "Magnetic"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionReferenceConst", int(e))
	}
}

type DirectionRudderConst uint8
const (
	NoOrder	DirectionRudderConst = 0
	MoveToStarboard	DirectionRudderConst = 1
	MoveToPort	DirectionRudderConst = 2
)

func (e DirectionRudderConst) GoString() string {return e.String() }
func (e DirectionRudderConst) String() string {
	switch e {
		case 0:
			return "No Order"
		case 1:
			return "Move to starboard"
		case 2:
			return "Move to port"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionRudderConst", int(e))
	}
}

type NavStatusConst uint8
const (
	UnderWayUsingEngine	NavStatusConst = 0
	AtAnchor	NavStatusConst = 1
	NotUnderCommand	NavStatusConst = 2
	RestrictedManeuverability	NavStatusConst = 3
	ConstrainedByHerDraught	NavStatusConst = 4
	Moored	NavStatusConst = 5
	Aground	NavStatusConst = 6
	EngagedInFishing	NavStatusConst = 7
	UnderWaySailing	NavStatusConst = 8
	HazardousMaterialHighSpeed	NavStatusConst = 9
	HazardousMaterialWingInGround	NavStatusConst = 10
	PowerDrivenVesselTowingAstern	NavStatusConst = 11
	PowerDrivenVesselPushingAheadOrTowingAlongside	NavStatusConst = 12
	AISSART	NavStatusConst = 14
)

func (e NavStatusConst) GoString() string {return e.String() }
func (e NavStatusConst) String() string {
	switch e {
		case 0:
			return "Under way using engine"
		case 1:
			return "At anchor"
		case 2:
			return "Not under command"
		case 3:
			return "Restricted maneuverability"
		case 4:
			return "Constrained by her draught"
		case 5:
			return "Moored"
		case 6:
			return "Aground"
		case 7:
			return "Engaged in Fishing"
		case 8:
			return "Under way sailing"
		case 9:
			return "Hazardous material - High Speed"
		case 10:
			return "Hazardous material - Wing in Ground"
		case 11:
			return "Power-driven vessel towing astern"
		case 12:
			return "Power-driven vessel pushing ahead or towing alongside"
		case 14:
			return "AIS-SART"
	default:
		return fmt.Sprintf("%s(%d)", "NavStatusConst", int(e))
	}
}

type PowerFactorConst uint8
const (
	Leading	PowerFactorConst = 0
	Lagging	PowerFactorConst = 1
	Error_2	PowerFactorConst = 2
)

func (e PowerFactorConst) GoString() string {return e.String() }
func (e PowerFactorConst) String() string {
	switch e {
		case 0:
			return "Leading"
		case 1:
			return "Lagging"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "PowerFactorConst", int(e))
	}
}

type TemperatureSourceConst uint8
const (
	SeaTemperature	TemperatureSourceConst = 0
	OutsideTemperature	TemperatureSourceConst = 1
	InsideTemperature	TemperatureSourceConst = 2
	EngineRoomTemperature	TemperatureSourceConst = 3
	MainCabinTemperature	TemperatureSourceConst = 4
	LiveWellTemperature	TemperatureSourceConst = 5
	BaitWellTemperature	TemperatureSourceConst = 6
	RefrigerationTemperature	TemperatureSourceConst = 7
	HeatingSystemTemperature	TemperatureSourceConst = 8
	DewPointTemperature	TemperatureSourceConst = 9
	ApparentWindChillTemperature	TemperatureSourceConst = 10
	TheoreticalWindChillTemperature	TemperatureSourceConst = 11
	HeatIndexTemperature	TemperatureSourceConst = 12
	FreezerTemperature	TemperatureSourceConst = 13
	ExhaustGasTemperature	TemperatureSourceConst = 14
	ShaftSealTemperature	TemperatureSourceConst = 15
)

func (e TemperatureSourceConst) GoString() string {return e.String() }
func (e TemperatureSourceConst) String() string {
	switch e {
		case 0:
			return "Sea Temperature"
		case 1:
			return "Outside Temperature"
		case 2:
			return "Inside Temperature"
		case 3:
			return "Engine Room Temperature"
		case 4:
			return "Main Cabin Temperature"
		case 5:
			return "Live Well Temperature"
		case 6:
			return "Bait Well Temperature"
		case 7:
			return "Refrigeration Temperature"
		case 8:
			return "Heating System Temperature"
		case 9:
			return "Dew Point Temperature"
		case 10:
			return "Apparent Wind Chill Temperature"
		case 11:
			return "Theoretical Wind Chill Temperature"
		case 12:
			return "Heat Index Temperature"
		case 13:
			return "Freezer Temperature"
		case 14:
			return "Exhaust Gas Temperature"
		case 15:
			return "Shaft Seal Temperature"
	default:
		return fmt.Sprintf("%s(%d)", "TemperatureSourceConst", int(e))
	}
}

type HumiditySourceConst uint8
const (
	Inside	HumiditySourceConst = 0
	Outside	HumiditySourceConst = 1
)

func (e HumiditySourceConst) GoString() string {return e.String() }
func (e HumiditySourceConst) String() string {
	switch e {
		case 0:
			return "Inside"
		case 1:
			return "Outside"
	default:
		return fmt.Sprintf("%s(%d)", "HumiditySourceConst", int(e))
	}
}

type PressureSourceConst uint8
const (
	Atmospheric	PressureSourceConst = 0
	Water	PressureSourceConst = 1
	Steam	PressureSourceConst = 2
	CompressedAir	PressureSourceConst = 3
	Hydraulic	PressureSourceConst = 4
	Filter	PressureSourceConst = 5
	AltimeterSetting	PressureSourceConst = 6
	Oil	PressureSourceConst = 7
	Fuel	PressureSourceConst = 8
)

func (e PressureSourceConst) GoString() string {return e.String() }
func (e PressureSourceConst) String() string {
	switch e {
		case 0:
			return "Atmospheric"
		case 1:
			return "Water"
		case 2:
			return "Steam"
		case 3:
			return "Compressed Air"
		case 4:
			return "Hydraulic"
		case 5:
			return "Filter"
		case 6:
			return "AltimeterSetting"
		case 7:
			return "Oil"
		case 8:
			return "Fuel"
	default:
		return fmt.Sprintf("%s(%d)", "PressureSourceConst", int(e))
	}
}

type DscFormatConst uint8
const (
	GeographicalArea	DscFormatConst = 102
	Distress	DscFormatConst = 112
	CommonInterest	DscFormatConst = 114
	AllShips	DscFormatConst = 116
	IndividualStations	DscFormatConst = 120
	NonCallingPurpose	DscFormatConst = 121
	IndividualStationAutomatic	DscFormatConst = 123
)

func (e DscFormatConst) GoString() string {return e.String() }
func (e DscFormatConst) String() string {
	switch e {
		case 102:
			return "Geographical area"
		case 112:
			return "Distress"
		case 114:
			return "Common interest"
		case 116:
			return "All ships"
		case 120:
			return "Individual stations"
		case 121:
			return "Non-calling purpose"
		case 123:
			return "Individual station automatic"
	default:
		return fmt.Sprintf("%s(%d)", "DscFormatConst", int(e))
	}
}

type DscCategoryConst uint8
const (
	Routine	DscCategoryConst = 100
	Safety	DscCategoryConst = 108
	Urgency	DscCategoryConst = 110
	Distress_2	DscCategoryConst = 112
)

func (e DscCategoryConst) GoString() string {return e.String() }
func (e DscCategoryConst) String() string {
	switch e {
		case 100:
			return "Routine"
		case 108:
			return "Safety"
		case 110:
			return "Urgency"
		case 112:
			return "Distress"
	default:
		return fmt.Sprintf("%s(%d)", "DscCategoryConst", int(e))
	}
}

type DscNatureConst uint8
const (
	Fire	DscNatureConst = 100
	Flooding	DscNatureConst = 101
	Collision	DscNatureConst = 102
	Grounding	DscNatureConst = 103
	Listing	DscNatureConst = 104
	Sinking	DscNatureConst = 105
	DisabledAndAdrift	DscNatureConst = 106
	Undesignated	DscNatureConst = 107
	AbandoningShip	DscNatureConst = 108
	Piracy	DscNatureConst = 109
	ManOverboard	DscNatureConst = 110
	EPIRBEmission	DscNatureConst = 112
)

func (e DscNatureConst) GoString() string {return e.String() }
func (e DscNatureConst) String() string {
	switch e {
		case 100:
			return "Fire"
		case 101:
			return "Flooding"
		case 102:
			return "Collision"
		case 103:
			return "Grounding"
		case 104:
			return "Listing"
		case 105:
			return "Sinking"
		case 106:
			return "Disabled and adrift"
		case 107:
			return "Undesignated"
		case 108:
			return "Abandoning ship"
		case 109:
			return "Piracy"
		case 110:
			return "Man overboard"
		case 112:
			return "EPIRB emission"
	default:
		return fmt.Sprintf("%s(%d)", "DscNatureConst", int(e))
	}
}

type DscFirstTelecommandConst uint8
const (
	F3EG3EAllModesTP	DscFirstTelecommandConst = 100
	F3EG3EDuplexTP	DscFirstTelecommandConst = 101
	Polling	DscFirstTelecommandConst = 103
	UnableToComply	DscFirstTelecommandConst = 104
	EndOfCall	DscFirstTelecommandConst = 105
	Data	DscFirstTelecommandConst = 106
	J3ETP	DscFirstTelecommandConst = 109
	DistressAcknowledgement	DscFirstTelecommandConst = 110
	DistressRelay	DscFirstTelecommandConst = 112
	F1BJ2BTTYFEC	DscFirstTelecommandConst = 113
	F1BJ2BTTYARQ	DscFirstTelecommandConst = 115
	Test	DscFirstTelecommandConst = 118
	ShipPositionOrLocationRegistrationUpdating	DscFirstTelecommandConst = 121
	NoInformation	DscFirstTelecommandConst = 126
)

func (e DscFirstTelecommandConst) GoString() string {return e.String() }
func (e DscFirstTelecommandConst) String() string {
	switch e {
		case 100:
			return "F3E/G3E All modes TP"
		case 101:
			return "F3E/G3E duplex TP"
		case 103:
			return "Polling"
		case 104:
			return "Unable to comply"
		case 105:
			return "End of call"
		case 106:
			return "Data"
		case 109:
			return "J3E TP"
		case 110:
			return "Distress acknowledgement"
		case 112:
			return "Distress relay"
		case 113:
			return "F1B/J2B TTY-FEC"
		case 115:
			return "F1B/J2B TTY-ARQ"
		case 118:
			return "Test"
		case 121:
			return "Ship position or location registration updating"
		case 126:
			return "No information"
	default:
		return fmt.Sprintf("%s(%d)", "DscFirstTelecommandConst", int(e))
	}
}

type DscSecondTelecommandConst uint8
const (
	NoReasonGiven	DscSecondTelecommandConst = 100
	CongestionAtMSC	DscSecondTelecommandConst = 101
	Busy	DscSecondTelecommandConst = 102
	QueueIndication	DscSecondTelecommandConst = 103
	StationBarred	DscSecondTelecommandConst = 104
	NoOperatorAvailable	DscSecondTelecommandConst = 105
	OperatorTemporarilyUnavailable	DscSecondTelecommandConst = 106
	EquipmentDisabled	DscSecondTelecommandConst = 107
	UnableToUseProposedChannel	DscSecondTelecommandConst = 108
	UnableToUseProposedMode	DscSecondTelecommandConst = 109
	ShipsAndAircraftOfStatesNotPartiesToAnArmedConflict_2	DscSecondTelecommandConst = 110
	MedicalTransports	DscSecondTelecommandConst = 111
	PayPhonePublicCallOffice	DscSecondTelecommandConst = 112
	FaxData	DscSecondTelecommandConst = 113
	NoInformation_2	DscSecondTelecommandConst = 126
)

func (e DscSecondTelecommandConst) GoString() string {return e.String() }
func (e DscSecondTelecommandConst) String() string {
	switch e {
		case 100:
			return "No reason given"
		case 101:
			return "Congestion at MSC"
		case 102:
			return "Busy"
		case 103:
			return "Queue indication"
		case 104:
			return "Station barred"
		case 105:
			return "No operator available"
		case 106:
			return "Operator temporarily unavailable"
		case 107:
			return "Equipment disabled"
		case 108:
			return "Unable to use proposed channel"
		case 109:
			return "Unable to use proposed mode"
		case 110:
			return "Ships and aircraft of States not parties to an armed conflict"
		case 111:
			return "Medical transports"
		case 112:
			return "Pay phone/public call office"
		case 113:
			return "Fax/data"
		case 126:
			return "No information"
	default:
		return fmt.Sprintf("%s(%d)", "DscSecondTelecommandConst", int(e))
	}
}

type DscExpansionDataConst uint8
const (
	EnhancedPosition	DscExpansionDataConst = 100
	SourceAndDatumOfPosition	DscExpansionDataConst = 101
	SOG	DscExpansionDataConst = 102
	COG	DscExpansionDataConst = 103
	AdditionalStationIdentification	DscExpansionDataConst = 104
	EnhancedGeographicArea	DscExpansionDataConst = 105
	NumberOfPersonsOnBoard	DscExpansionDataConst = 106
)

func (e DscExpansionDataConst) GoString() string {return e.String() }
func (e DscExpansionDataConst) String() string {
	switch e {
		case 100:
			return "Enhanced position"
		case 101:
			return "Source and datum of position"
		case 102:
			return "SOG"
		case 103:
			return "COG"
		case 104:
			return "Additional station identification"
		case 105:
			return "Enhanced geographic area"
		case 106:
			return "Number of persons on board"
	default:
		return fmt.Sprintf("%s(%d)", "DscExpansionDataConst", int(e))
	}
}

type SeatalkAlarmStatusConst uint8
const (
	AlarmConditionNotMet	SeatalkAlarmStatusConst = 0
	AlarmConditionMetAndNotSilenced	SeatalkAlarmStatusConst = 1
	AlarmConditionMetAndSilenced	SeatalkAlarmStatusConst = 2
)

func (e SeatalkAlarmStatusConst) GoString() string {return e.String() }
func (e SeatalkAlarmStatusConst) String() string {
	switch e {
		case 0:
			return "Alarm condition not met"
		case 1:
			return "Alarm condition met and not silenced"
		case 2:
			return "Alarm condition met and silenced"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmStatusConst", int(e))
	}
}

type SeatalkAlarmIdConst uint8
const (
	NoAlarm	SeatalkAlarmIdConst = 0
	ShallowDepth	SeatalkAlarmIdConst = 1
	DeepDepth	SeatalkAlarmIdConst = 2
	ShallowAnchor	SeatalkAlarmIdConst = 3
	DeepAnchor	SeatalkAlarmIdConst = 4
	OffCourse	SeatalkAlarmIdConst = 5
	AWAHigh	SeatalkAlarmIdConst = 6
	AWALow	SeatalkAlarmIdConst = 7
	AWSHigh	SeatalkAlarmIdConst = 8
	AWSLow	SeatalkAlarmIdConst = 9
	TWAHigh	SeatalkAlarmIdConst = 10
	TWALow	SeatalkAlarmIdConst = 11
	TWSHigh	SeatalkAlarmIdConst = 12
	TWSLow	SeatalkAlarmIdConst = 13
	WPArrival	SeatalkAlarmIdConst = 14
	BoatSpeedHigh	SeatalkAlarmIdConst = 15
	BoatSpeedLow	SeatalkAlarmIdConst = 16
	SeaTemperatureHigh	SeatalkAlarmIdConst = 17
	SeaTemperatureLow	SeatalkAlarmIdConst = 18
	PilotWatch	SeatalkAlarmIdConst = 19
	PilotOffCourse	SeatalkAlarmIdConst = 20
	PilotWindShift	SeatalkAlarmIdConst = 21
	PilotLowBattery	SeatalkAlarmIdConst = 22
	PilotLastMinuteOfWatch	SeatalkAlarmIdConst = 23
	PilotNoNMEAData	SeatalkAlarmIdConst = 24
	PilotLargeXTE	SeatalkAlarmIdConst = 25
	PilotNMEADataError	SeatalkAlarmIdConst = 26
	PilotCUDisconnected	SeatalkAlarmIdConst = 27
	PilotAutoRelease	SeatalkAlarmIdConst = 28
	PilotWayPointAdvance	SeatalkAlarmIdConst = 29
	PilotDriveStopped	SeatalkAlarmIdConst = 30
	PilotTypeUnspecified	SeatalkAlarmIdConst = 31
	PilotCalibrationRequired	SeatalkAlarmIdConst = 32
	PilotLastHeading	SeatalkAlarmIdConst = 33
	PilotNoPilot	SeatalkAlarmIdConst = 34
	PilotRouteComplete	SeatalkAlarmIdConst = 35
	PilotVariableText	SeatalkAlarmIdConst = 36
	GPSFailure	SeatalkAlarmIdConst = 37
	MOB	SeatalkAlarmIdConst = 38
	Seatalk1Anchor	SeatalkAlarmIdConst = 39
	PilotSwappedMotorPower	SeatalkAlarmIdConst = 40
	PilotStandbyTooFastToFish	SeatalkAlarmIdConst = 41
	PilotNoGPSFix	SeatalkAlarmIdConst = 42
	PilotNoGPSCOG	SeatalkAlarmIdConst = 43
	PilotStartUp	SeatalkAlarmIdConst = 44
	PilotTooSlow	SeatalkAlarmIdConst = 45
	PilotNoCompass	SeatalkAlarmIdConst = 46
	PilotRateGyroFault	SeatalkAlarmIdConst = 47
	PilotCurrentLimit	SeatalkAlarmIdConst = 48
	PilotWayPointAdvancePort	SeatalkAlarmIdConst = 49
	PilotWayPointAdvanceStbd	SeatalkAlarmIdConst = 50
	PilotNoWindData	SeatalkAlarmIdConst = 51
	PilotNoSpeedData	SeatalkAlarmIdConst = 52
	PilotSeatalkFail1	SeatalkAlarmIdConst = 53
	PilotSeatalkFail2	SeatalkAlarmIdConst = 54
	PilotWarningTooFastToFish	SeatalkAlarmIdConst = 55
	PilotAutoDocksideFail	SeatalkAlarmIdConst = 56
	PilotTurnTooFast	SeatalkAlarmIdConst = 57
	PilotNoNavData	SeatalkAlarmIdConst = 58
	PilotLostWaypointData	SeatalkAlarmIdConst = 59
	PilotEEPROMCorrupt	SeatalkAlarmIdConst = 60
	PilotRudderFeedbackFail	SeatalkAlarmIdConst = 61
	PilotAutolearnFail1	SeatalkAlarmIdConst = 62
	PilotAutolearnFail2	SeatalkAlarmIdConst = 63
	PilotAutolearnFail3	SeatalkAlarmIdConst = 64
	PilotAutolearnFail4	SeatalkAlarmIdConst = 65
	PilotAutolearnFail5	SeatalkAlarmIdConst = 66
	PilotAutolearnFail6	SeatalkAlarmIdConst = 67
	PilotWarningCalRequired	SeatalkAlarmIdConst = 68
	PilotWarningOffCourse	SeatalkAlarmIdConst = 69
	PilotWarningXTE	SeatalkAlarmIdConst = 70
	PilotWarningWindShift	SeatalkAlarmIdConst = 71
	PilotWarningDriveShort	SeatalkAlarmIdConst = 72
	PilotWarningClutchShort	SeatalkAlarmIdConst = 73
	PilotWarningSolenoidShort	SeatalkAlarmIdConst = 74
	PilotJoystickFault	SeatalkAlarmIdConst = 75
	PilotNoJoystickData	SeatalkAlarmIdConst = 76
	PilotInvalidCommand	SeatalkAlarmIdConst = 80
	AISTXMalfunction	SeatalkAlarmIdConst = 81
	AISAntennaVSWRFault	SeatalkAlarmIdConst = 82
	AISRxChannel1Malfunction	SeatalkAlarmIdConst = 83
	AISRxChannel2Malfunction	SeatalkAlarmIdConst = 84
	AISNoSensorPositionInUse	SeatalkAlarmIdConst = 85
	AISNoValidSOGInformation	SeatalkAlarmIdConst = 86
	AISNoValidCOGInformation	SeatalkAlarmIdConst = 87
	AIS12VAlarm	SeatalkAlarmIdConst = 88
	AIS6VAlarm	SeatalkAlarmIdConst = 89
	AISNoiseThresholdExceededChannelA	SeatalkAlarmIdConst = 90
	AISNoiseThresholdExceededChannelB	SeatalkAlarmIdConst = 91
	AISTransmitterPAFault	SeatalkAlarmIdConst = 92
	AIS3V3Alarm	SeatalkAlarmIdConst = 93
	AISRxChannel70Malfunction	SeatalkAlarmIdConst = 94
	AISHeadingLostInvalid	SeatalkAlarmIdConst = 95
	AISInternalGPSLost	SeatalkAlarmIdConst = 96
	AISNoSensorPosition	SeatalkAlarmIdConst = 97
	AISLockFailure	SeatalkAlarmIdConst = 98
	AISInternalGGATimeout	SeatalkAlarmIdConst = 99
	AISProtocolStackRestart	SeatalkAlarmIdConst = 100
	PilotNoIPSCommunications	SeatalkAlarmIdConst = 101
	PilotPowerOnOrSleepSwitchResetWhileEngaged	SeatalkAlarmIdConst = 102
	PilotUnexpectedResetWhileEngaged	SeatalkAlarmIdConst = 103
	AISDangerousTarget	SeatalkAlarmIdConst = 104
	AISLostTarget	SeatalkAlarmIdConst = 105
	AISSafetyRelatedMessageUsedToSilence	SeatalkAlarmIdConst = 106
	AISConnectionLost	SeatalkAlarmIdConst = 107
	NoFix	SeatalkAlarmIdConst = 108
)

func (e SeatalkAlarmIdConst) GoString() string {return e.String() }
func (e SeatalkAlarmIdConst) String() string {
	switch e {
		case 0:
			return "No Alarm"
		case 1:
			return "Shallow Depth"
		case 2:
			return "Deep Depth"
		case 3:
			return "Shallow Anchor"
		case 4:
			return "Deep Anchor"
		case 5:
			return "Off Course"
		case 6:
			return "AWA High"
		case 7:
			return "AWA Low"
		case 8:
			return "AWS High"
		case 9:
			return "AWS Low"
		case 10:
			return "TWA High"
		case 11:
			return "TWA Low"
		case 12:
			return "TWS High"
		case 13:
			return "TWS Low"
		case 14:
			return "WP Arrival"
		case 15:
			return "Boat Speed High"
		case 16:
			return "Boat Speed Low"
		case 17:
			return "Sea Temperature High"
		case 18:
			return "Sea Temperature Low"
		case 19:
			return "Pilot Watch"
		case 20:
			return "Pilot Off Course"
		case 21:
			return "Pilot Wind Shift"
		case 22:
			return "Pilot Low Battery"
		case 23:
			return "Pilot Last Minute Of Watch"
		case 24:
			return "Pilot No NMEA Data"
		case 25:
			return "Pilot Large XTE"
		case 26:
			return "Pilot NMEA DataError"
		case 27:
			return "Pilot CU Disconnected"
		case 28:
			return "Pilot Auto Release"
		case 29:
			return "Pilot Way Point Advance"
		case 30:
			return "Pilot Drive Stopped"
		case 31:
			return "Pilot Type Unspecified"
		case 32:
			return "Pilot Calibration Required"
		case 33:
			return "Pilot Last Heading"
		case 34:
			return "Pilot No Pilot"
		case 35:
			return "Pilot Route Complete"
		case 36:
			return "Pilot Variable Text"
		case 37:
			return "GPS Failure"
		case 38:
			return "MOB"
		case 39:
			return "Seatalk1 Anchor"
		case 40:
			return "Pilot Swapped Motor Power"
		case 41:
			return "Pilot Standby Too Fast To Fish"
		case 42:
			return "Pilot No GPS Fix"
		case 43:
			return "Pilot No GPS COG"
		case 44:
			return "Pilot Start Up"
		case 45:
			return "Pilot Too Slow"
		case 46:
			return "Pilot No Compass"
		case 47:
			return "Pilot Rate Gyro Fault"
		case 48:
			return "Pilot Current Limit"
		case 49:
			return "Pilot Way Point Advance Port"
		case 50:
			return "Pilot Way Point Advance Stbd"
		case 51:
			return "Pilot No Wind Data"
		case 52:
			return "Pilot No Speed Data"
		case 53:
			return "Pilot Seatalk Fail1"
		case 54:
			return "Pilot Seatalk Fail2"
		case 55:
			return "Pilot Warning Too Fast To Fish"
		case 56:
			return "Pilot Auto Dockside Fail"
		case 57:
			return "Pilot Turn Too Fast"
		case 58:
			return "Pilot No Nav Data"
		case 59:
			return "Pilot Lost Waypoint Data"
		case 60:
			return "Pilot EEPROM Corrupt"
		case 61:
			return "Pilot Rudder Feedback Fail"
		case 62:
			return "Pilot Autolearn Fail1"
		case 63:
			return "Pilot Autolearn Fail2"
		case 64:
			return "Pilot Autolearn Fail3"
		case 65:
			return "Pilot Autolearn Fail4"
		case 66:
			return "Pilot Autolearn Fail5"
		case 67:
			return "Pilot Autolearn Fail6"
		case 68:
			return "Pilot Warning Cal Required"
		case 69:
			return "Pilot Warning OffCourse"
		case 70:
			return "Pilot Warning XTE"
		case 71:
			return "Pilot Warning Wind Shift"
		case 72:
			return "Pilot Warning Drive Short"
		case 73:
			return "Pilot Warning Clutch Short"
		case 74:
			return "Pilot Warning Solenoid Short"
		case 75:
			return "Pilot Joystick Fault"
		case 76:
			return "Pilot No Joystick Data"
		case 80:
			return "Pilot Invalid Command"
		case 81:
			return "AIS TX Malfunction"
		case 82:
			return "AIS Antenna VSWR fault"
		case 83:
			return "AIS Rx channel 1 malfunction"
		case 84:
			return "AIS Rx channel 2 malfunction"
		case 85:
			return "AIS No sensor position in use"
		case 86:
			return "AIS No valid SOG information"
		case 87:
			return "AIS No valid COG information"
		case 88:
			return "AIS 12V alarm"
		case 89:
			return "AIS 6V alarm"
		case 90:
			return "AIS Noise threshold exceeded channel A"
		case 91:
			return "AIS Noise threshold exceeded channel B"
		case 92:
			return "AIS Transmitter PA fault"
		case 93:
			return "AIS 3V3 alarm"
		case 94:
			return "AIS Rx channel 70 malfunction"
		case 95:
			return "AIS Heading lost/invalid"
		case 96:
			return "AIS internal GPS lost"
		case 97:
			return "AIS No sensor position"
		case 98:
			return "AIS Lock failure"
		case 99:
			return "AIS Internal GGA timeout"
		case 100:
			return "AIS Protocol stack restart"
		case 101:
			return "Pilot No IPS communications"
		case 102:
			return "Pilot Power-On or Sleep-Switch Reset While Engaged"
		case 103:
			return "Pilot Unexpected Reset While Engaged"
		case 104:
			return "AIS Dangerous Target"
		case 105:
			return "AIS Lost Target"
		case 106:
			return "AIS Safety Related Message (used to silence)"
		case 107:
			return "AIS Connection Lost"
		case 108:
			return "No Fix"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmIdConst", int(e))
	}
}

type SeatalkAlarmGroupConst uint8
const (
	Instrument	SeatalkAlarmGroupConst = 0
	Autopilot	SeatalkAlarmGroupConst = 1
	Radar	SeatalkAlarmGroupConst = 2
	ChartPlotter	SeatalkAlarmGroupConst = 3
	AIS	SeatalkAlarmGroupConst = 4
)

func (e SeatalkAlarmGroupConst) GoString() string {return e.String() }
func (e SeatalkAlarmGroupConst) String() string {
	switch e {
		case 0:
			return "Instrument"
		case 1:
			return "Autopilot"
		case 2:
			return "Radar"
		case 3:
			return "Chart Plotter"
		case 4:
			return "AIS"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmGroupConst", int(e))
	}
}

type SeatalkPilotModeConst uint8
const (
	Standby	SeatalkPilotModeConst = 64
	Auto	SeatalkPilotModeConst = 66
	Wind	SeatalkPilotModeConst = 70
	Track	SeatalkPilotModeConst = 74
)

func (e SeatalkPilotModeConst) GoString() string {return e.String() }
func (e SeatalkPilotModeConst) String() string {
	switch e {
		case 64:
			return "Standby"
		case 66:
			return "Auto"
		case 70:
			return "Wind"
		case 74:
			return "Track"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkPilotModeConst", int(e))
	}
}

type EntertainmentZoneConst uint8
const (
	AllZones	EntertainmentZoneConst = 0
	Zone1	EntertainmentZoneConst = 1
	Zone2	EntertainmentZoneConst = 2
	Zone3	EntertainmentZoneConst = 3
	Zone4	EntertainmentZoneConst = 4
)

func (e EntertainmentZoneConst) GoString() string {return e.String() }
func (e EntertainmentZoneConst) String() string {
	switch e {
		case 0:
			return "All zones"
		case 1:
			return "Zone 1"
		case 2:
			return "Zone 2"
		case 3:
			return "Zone 3"
		case 4:
			return "Zone 4"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentZoneConst", int(e))
	}
}

type EntertainmentSourceConst uint8
const (
	VesselAlarm	EntertainmentSourceConst = 0
	AM	EntertainmentSourceConst = 1
	FM	EntertainmentSourceConst = 2
	Weather	EntertainmentSourceConst = 3
	DAB	EntertainmentSourceConst = 4
	Aux	EntertainmentSourceConst = 5
	USB	EntertainmentSourceConst = 6
	CD	EntertainmentSourceConst = 7
	MP3	EntertainmentSourceConst = 8
	AppleIOS	EntertainmentSourceConst = 9
	Android	EntertainmentSourceConst = 10
	Bluetooth	EntertainmentSourceConst = 11
	SiriusXM	EntertainmentSourceConst = 12
	Pandora	EntertainmentSourceConst = 13
	Spotify	EntertainmentSourceConst = 14
	Slacker	EntertainmentSourceConst = 15
	Songza	EntertainmentSourceConst = 16
	AppleRadio	EntertainmentSourceConst = 17
	LastFM	EntertainmentSourceConst = 18
	Ethernet	EntertainmentSourceConst = 19
	VideoMP4	EntertainmentSourceConst = 20
	VideoDVD	EntertainmentSourceConst = 21
	VideoBluRay	EntertainmentSourceConst = 22
	HDMI	EntertainmentSourceConst = 23
	Video	EntertainmentSourceConst = 24
)

func (e EntertainmentSourceConst) GoString() string {return e.String() }
func (e EntertainmentSourceConst) String() string {
	switch e {
		case 0:
			return "Vessel alarm"
		case 1:
			return "AM"
		case 2:
			return "FM"
		case 3:
			return "Weather"
		case 4:
			return "DAB"
		case 5:
			return "Aux"
		case 6:
			return "USB"
		case 7:
			return "CD"
		case 8:
			return "MP3"
		case 9:
			return "Apple iOS"
		case 10:
			return "Android"
		case 11:
			return "Bluetooth"
		case 12:
			return "Sirius XM"
		case 13:
			return "Pandora"
		case 14:
			return "Spotify"
		case 15:
			return "Slacker"
		case 16:
			return "Songza"
		case 17:
			return "Apple Radio"
		case 18:
			return "Last FM"
		case 19:
			return "Ethernet"
		case 20:
			return "Video MP4"
		case 21:
			return "Video DVD"
		case 22:
			return "Video BluRay"
		case 23:
			return "HDMI"
		case 24:
			return "Video"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentSourceConst", int(e))
	}
}

type EntertainmentPlayStatusConst uint16
const (
	Play	EntertainmentPlayStatusConst = 0
	Pause	EntertainmentPlayStatusConst = 1
	Stop	EntertainmentPlayStatusConst = 2
	FF1x	EntertainmentPlayStatusConst = 3
	FF2x	EntertainmentPlayStatusConst = 4
	FF3x	EntertainmentPlayStatusConst = 5
	FF4x	EntertainmentPlayStatusConst = 6
	RW1x	EntertainmentPlayStatusConst = 7
	RW2x	EntertainmentPlayStatusConst = 8
	RW3x	EntertainmentPlayStatusConst = 9
	RW4x	EntertainmentPlayStatusConst = 10
	SkipAhead	EntertainmentPlayStatusConst = 11
	SkipBack	EntertainmentPlayStatusConst = 12
	JogAhead	EntertainmentPlayStatusConst = 13
	JogBack	EntertainmentPlayStatusConst = 14
	SeekUp	EntertainmentPlayStatusConst = 15
	SeekDown	EntertainmentPlayStatusConst = 16
	ScanUp	EntertainmentPlayStatusConst = 17
	ScanDown	EntertainmentPlayStatusConst = 18
	TuneUp	EntertainmentPlayStatusConst = 19
	TuneDown	EntertainmentPlayStatusConst = 20
	SlowMotion75x	EntertainmentPlayStatusConst = 21
	SlowMotion5x	EntertainmentPlayStatusConst = 22
	SlowMotion25x	EntertainmentPlayStatusConst = 23
	SlowMotion125x	EntertainmentPlayStatusConst = 24
)

func (e EntertainmentPlayStatusConst) GoString() string {return e.String() }
func (e EntertainmentPlayStatusConst) String() string {
	switch e {
		case 0:
			return "Play"
		case 1:
			return "Pause"
		case 2:
			return "Stop"
		case 3:
			return "FF 1x"
		case 4:
			return "FF 2x"
		case 5:
			return "FF 3x"
		case 6:
			return "FF 4x"
		case 7:
			return "RW 1x"
		case 8:
			return "RW 2x"
		case 9:
			return "RW 3x"
		case 10:
			return "RW 4x"
		case 11:
			return "Skip ahead"
		case 12:
			return "Skip back"
		case 13:
			return "Jog ahead"
		case 14:
			return "Jog back"
		case 15:
			return "Seek up"
		case 16:
			return "Seek down"
		case 17:
			return "Scan up"
		case 18:
			return "Scan down"
		case 19:
			return "Tune up"
		case 20:
			return "Tune down"
		case 21:
			return "Slow motion .75x"
		case 22:
			return "Slow motion .5x"
		case 23:
			return "Slow motion .25x"
		case 24:
			return "Slow motion .125x"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentPlayStatusConst", int(e))
	}
}

type EntertainmentRepeatStatusConst uint8
const (
	Off_2	EntertainmentRepeatStatusConst = 0
	One	EntertainmentRepeatStatusConst = 1
	All	EntertainmentRepeatStatusConst = 2
)

func (e EntertainmentRepeatStatusConst) GoString() string {return e.String() }
func (e EntertainmentRepeatStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "One"
		case 2:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRepeatStatusConst", int(e))
	}
}

type EntertainmentShuffleStatusConst uint8
const (
	Off_3	EntertainmentShuffleStatusConst = 0
	PlayQueue	EntertainmentShuffleStatusConst = 1
	All_2	EntertainmentShuffleStatusConst = 2
)

func (e EntertainmentShuffleStatusConst) GoString() string {return e.String() }
func (e EntertainmentShuffleStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Play queue"
		case 2:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentShuffleStatusConst", int(e))
	}
}

type EntertainmentLikeStatusConst uint8
const (
	None	EntertainmentLikeStatusConst = 0
	ThumbsUp	EntertainmentLikeStatusConst = 1
	ThumbsDown	EntertainmentLikeStatusConst = 2
)

func (e EntertainmentLikeStatusConst) GoString() string {return e.String() }
func (e EntertainmentLikeStatusConst) String() string {
	switch e {
		case 0:
			return "None"
		case 1:
			return "Thumbs up"
		case 2:
			return "Thumbs down"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentLikeStatusConst", int(e))
	}
}

type EntertainmentTypeConst uint8
const (
	File	EntertainmentTypeConst = 0
	PlaylistName	EntertainmentTypeConst = 1
	GenreName	EntertainmentTypeConst = 2
	AlbumName	EntertainmentTypeConst = 3
	ArtistName	EntertainmentTypeConst = 4
	TrackName	EntertainmentTypeConst = 5
	StationName	EntertainmentTypeConst = 6
	StationNumber	EntertainmentTypeConst = 7
	FavouriteNumber	EntertainmentTypeConst = 8
	PlayQueue_2	EntertainmentTypeConst = 9
	ContentInfo	EntertainmentTypeConst = 10
)

func (e EntertainmentTypeConst) GoString() string {return e.String() }
func (e EntertainmentTypeConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentTypeConst", int(e))
	}
}

type EntertainmentGroupConst uint8
const (
	File_2	EntertainmentGroupConst = 0
	PlaylistName_2	EntertainmentGroupConst = 1
	GenreName_2	EntertainmentGroupConst = 2
	AlbumName_2	EntertainmentGroupConst = 3
	ArtistName_2	EntertainmentGroupConst = 4
	TrackName_2	EntertainmentGroupConst = 5
	StationName_2	EntertainmentGroupConst = 6
	StationNumber_2	EntertainmentGroupConst = 7
	FavouriteNumber_2	EntertainmentGroupConst = 8
	PlayQueue_3	EntertainmentGroupConst = 9
	ContentInfo_2	EntertainmentGroupConst = 10
)

func (e EntertainmentGroupConst) GoString() string {return e.String() }
func (e EntertainmentGroupConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentGroupConst", int(e))
	}
}

type EntertainmentChannelConst uint8
const (
	AllChannels	EntertainmentChannelConst = 0
	StereoFullRange	EntertainmentChannelConst = 1
	StereoFront	EntertainmentChannelConst = 2
	StereoBack	EntertainmentChannelConst = 3
	StereoSurround	EntertainmentChannelConst = 4
	Center	EntertainmentChannelConst = 5
	Subwoofer	EntertainmentChannelConst = 6
	FrontLeft	EntertainmentChannelConst = 7
	FrontRight	EntertainmentChannelConst = 8
	BackLeft	EntertainmentChannelConst = 9
	BackRight	EntertainmentChannelConst = 10
	SurroundLeft	EntertainmentChannelConst = 11
	SurroundRight	EntertainmentChannelConst = 12
)

func (e EntertainmentChannelConst) GoString() string {return e.String() }
func (e EntertainmentChannelConst) String() string {
	switch e {
		case 0:
			return "All channels"
		case 1:
			return "Stereo full range"
		case 2:
			return "Stereo front"
		case 3:
			return "Stereo back"
		case 4:
			return "Stereo surround"
		case 5:
			return "Center"
		case 6:
			return "Subwoofer"
		case 7:
			return "Front left"
		case 8:
			return "Front right"
		case 9:
			return "Back left"
		case 10:
			return "Back right"
		case 11:
			return "Surround left"
		case 12:
			return "Surround right"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentChannelConst", int(e))
	}
}

type EntertainmentEqConst uint8
const (
	Flat	EntertainmentEqConst = 0
	Rock	EntertainmentEqConst = 1
	Hall	EntertainmentEqConst = 2
	Jazz	EntertainmentEqConst = 3
	Pop	EntertainmentEqConst = 4
	Live	EntertainmentEqConst = 5
	Classic	EntertainmentEqConst = 6
	Vocal	EntertainmentEqConst = 7
	Arena	EntertainmentEqConst = 8
	Cinema	EntertainmentEqConst = 9
	Custom	EntertainmentEqConst = 10
)

func (e EntertainmentEqConst) GoString() string {return e.String() }
func (e EntertainmentEqConst) String() string {
	switch e {
		case 0:
			return "Flat"
		case 1:
			return "Rock"
		case 2:
			return "Hall"
		case 3:
			return "Jazz"
		case 4:
			return "Pop"
		case 5:
			return "Live"
		case 6:
			return "Classic"
		case 7:
			return "Vocal"
		case 8:
			return "Arena"
		case 9:
			return "Cinema"
		case 10:
			return "Custom"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentEqConst", int(e))
	}
}

type EntertainmentFilterConst uint8
const (
	FullRange	EntertainmentFilterConst = 0
	HighPass	EntertainmentFilterConst = 1
	LowPass	EntertainmentFilterConst = 2
	BandPass	EntertainmentFilterConst = 3
	NotchFilter	EntertainmentFilterConst = 4
)

func (e EntertainmentFilterConst) GoString() string {return e.String() }
func (e EntertainmentFilterConst) String() string {
	switch e {
		case 0:
			return "Full range"
		case 1:
			return "High pass"
		case 2:
			return "Low pass"
		case 3:
			return "Band pass"
		case 4:
			return "Notch filter"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentFilterConst", int(e))
	}
}

type AlertTypeConst uint8
const (
	EmergencyAlarm	AlertTypeConst = 1
	Alarm	AlertTypeConst = 2
	Warning_2	AlertTypeConst = 5
	Caution_2	AlertTypeConst = 8
)

func (e AlertTypeConst) GoString() string {return e.String() }
func (e AlertTypeConst) String() string {
	switch e {
		case 1:
			return "Emergency Alarm"
		case 2:
			return "Alarm"
		case 5:
			return "Warning"
		case 8:
			return "Caution"
	default:
		return fmt.Sprintf("%s(%d)", "AlertTypeConst", int(e))
	}
}

type AlertCategoryConst uint8
const (
	Navigational	AlertCategoryConst = 0
	Technical	AlertCategoryConst = 1
)

func (e AlertCategoryConst) GoString() string {return e.String() }
func (e AlertCategoryConst) String() string {
	switch e {
		case 0:
			return "Navigational"
		case 1:
			return "Technical"
	default:
		return fmt.Sprintf("%s(%d)", "AlertCategoryConst", int(e))
	}
}

type AlertTriggerConditionConst uint8
const (
	Manual_3	AlertTriggerConditionConst = 0
	Auto_2	AlertTriggerConditionConst = 1
	Test_2	AlertTriggerConditionConst = 2
	Disabled	AlertTriggerConditionConst = 3
)

func (e AlertTriggerConditionConst) GoString() string {return e.String() }
func (e AlertTriggerConditionConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Auto"
		case 2:
			return "Test"
		case 3:
			return "Disabled"
	default:
		return fmt.Sprintf("%s(%d)", "AlertTriggerConditionConst", int(e))
	}
}

type AlertThresholdStatusConst uint8
const (
	Normal	AlertThresholdStatusConst = 0
	ThresholdExceeded	AlertThresholdStatusConst = 1
	ExtremeThresholdExceeded	AlertThresholdStatusConst = 2
	LowThresholdExceeded	AlertThresholdStatusConst = 3
	Acknowledged	AlertThresholdStatusConst = 4
	AwaitingAcknowledge	AlertThresholdStatusConst = 5
)

func (e AlertThresholdStatusConst) GoString() string {return e.String() }
func (e AlertThresholdStatusConst) String() string {
	switch e {
		case 0:
			return "Normal"
		case 1:
			return "Threshold Exceeded"
		case 2:
			return "Extreme Threshold Exceeded"
		case 3:
			return "Low Threshold Exceeded"
		case 4:
			return "Acknowledged"
		case 5:
			return "Awaiting Acknowledge"
	default:
		return fmt.Sprintf("%s(%d)", "AlertThresholdStatusConst", int(e))
	}
}

type AlertStateConst uint8
const (
	Disabled_2	AlertStateConst = 0
	Normal_2	AlertStateConst = 1
	Active	AlertStateConst = 2
	Silenced	AlertStateConst = 3
	Acknowledged_2	AlertStateConst = 4
	AwaitingAcknowledge_2	AlertStateConst = 5
)

func (e AlertStateConst) GoString() string {return e.String() }
func (e AlertStateConst) String() string {
	switch e {
		case 0:
			return "Disabled"
		case 1:
			return "Normal"
		case 2:
			return "Active"
		case 3:
			return "Silenced"
		case 4:
			return "Acknowledged"
		case 5:
			return "Awaiting Acknowledge"
	default:
		return fmt.Sprintf("%s(%d)", "AlertStateConst", int(e))
	}
}

type AlertLanguageIdConst uint8
const (
	EnglishUS	AlertLanguageIdConst = 0
	EnglishUK	AlertLanguageIdConst = 1
	Arabic	AlertLanguageIdConst = 2
	ChineseSimplified	AlertLanguageIdConst = 3
	Croatian	AlertLanguageIdConst = 4
	Danish	AlertLanguageIdConst = 5
	Dutch	AlertLanguageIdConst = 6
	Finnish	AlertLanguageIdConst = 7
	French	AlertLanguageIdConst = 8
	German	AlertLanguageIdConst = 9
	Greek	AlertLanguageIdConst = 10
	Italian	AlertLanguageIdConst = 11
	Japanese	AlertLanguageIdConst = 12
	Korean	AlertLanguageIdConst = 13
	Norwegian	AlertLanguageIdConst = 14
	Polish	AlertLanguageIdConst = 15
	Portuguese	AlertLanguageIdConst = 16
	Russian	AlertLanguageIdConst = 17
	Spanish	AlertLanguageIdConst = 18
	Swedish	AlertLanguageIdConst = 19
)

func (e AlertLanguageIdConst) GoString() string {return e.String() }
func (e AlertLanguageIdConst) String() string {
	switch e {
		case 0:
			return "English (US)"
		case 1:
			return "English (UK)"
		case 2:
			return "Arabic"
		case 3:
			return "Chinese (simplified)"
		case 4:
			return "Croatian"
		case 5:
			return "Danish"
		case 6:
			return "Dutch"
		case 7:
			return "Finnish"
		case 8:
			return "French"
		case 9:
			return "German"
		case 10:
			return "Greek"
		case 11:
			return "Italian"
		case 12:
			return "Japanese"
		case 13:
			return "Korean"
		case 14:
			return "Norwegian"
		case 15:
			return "Polish"
		case 16:
			return "Portuguese"
		case 17:
			return "Russian"
		case 18:
			return "Spanish"
		case 19:
			return "Swedish"
	default:
		return fmt.Sprintf("%s(%d)", "AlertLanguageIdConst", int(e))
	}
}

type AlertResponseCommandConst uint8
const (
	Acknowledge	AlertResponseCommandConst = 0
	TemporarySilence	AlertResponseCommandConst = 1
	TestCommandOff	AlertResponseCommandConst = 2
	TestCommandOn	AlertResponseCommandConst = 3
)

func (e AlertResponseCommandConst) GoString() string {return e.String() }
func (e AlertResponseCommandConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Temporary Silence"
		case 2:
			return "Test Command off"
		case 3:
			return "Test Command on"
	default:
		return fmt.Sprintf("%s(%d)", "AlertResponseCommandConst", int(e))
	}
}

type ConverterStateConst uint8
const (
	Off_4	ConverterStateConst = 0
	LowPowerMode	ConverterStateConst = 1
	Fault	ConverterStateConst = 2
	Bulk	ConverterStateConst = 3
	Absorption	ConverterStateConst = 4
	Float	ConverterStateConst = 5
	Storage	ConverterStateConst = 6
	Equalize	ConverterStateConst = 7
	PassThru	ConverterStateConst = 8
	Inverting	ConverterStateConst = 9
	Assisting	ConverterStateConst = 10
)

func (e ConverterStateConst) GoString() string {return e.String() }
func (e ConverterStateConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Low Power Mode"
		case 2:
			return "Fault"
		case 3:
			return "Bulk"
		case 4:
			return "Absorption"
		case 5:
			return "Float"
		case 6:
			return "Storage"
		case 7:
			return "Equalize"
		case 8:
			return "Pass thru"
		case 9:
			return "Inverting"
		case 10:
			return "Assisting"
	default:
		return fmt.Sprintf("%s(%d)", "ConverterStateConst", int(e))
	}
}

type ThrusterDirectionControlConst uint8
const (
	Off_5	ThrusterDirectionControlConst = 0
	Ready	ThrusterDirectionControlConst = 1
	ToPort	ThrusterDirectionControlConst = 2
	ToStarboard	ThrusterDirectionControlConst = 3
)

func (e ThrusterDirectionControlConst) GoString() string {return e.String() }
func (e ThrusterDirectionControlConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Ready"
		case 2:
			return "To Port"
		case 3:
			return "To Starboard"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterDirectionControlConst", int(e))
	}
}

type ThrusterRetractControlConst uint8
const (
	Off_6	ThrusterRetractControlConst = 0
	Extend	ThrusterRetractControlConst = 1
	Retract	ThrusterRetractControlConst = 2
)

func (e ThrusterRetractControlConst) GoString() string {return e.String() }
func (e ThrusterRetractControlConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Extend"
		case 2:
			return "Retract"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterRetractControlConst", int(e))
	}
}

type ThrusterMotorTypeConst uint8
const (
	A12VDC	ThrusterMotorTypeConst = 0
	A24VDC	ThrusterMotorTypeConst = 1
	A48VDC	ThrusterMotorTypeConst = 2
	A24VAC	ThrusterMotorTypeConst = 3
	Hydraulic_2	ThrusterMotorTypeConst = 4
)

func (e ThrusterMotorTypeConst) GoString() string {return e.String() }
func (e ThrusterMotorTypeConst) String() string {
	switch e {
		case 0:
			return "A12VDC"
		case 1:
			return "A24VDC"
		case 2:
			return "A48VDC"
		case 3:
			return "A24VAC"
		case 4:
			return "Hydraulic"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterMotorTypeConst", int(e))
	}
}

type BootStateConst uint8
const (
	InStartupMonitor	BootStateConst = 0
	RunningBootloader	BootStateConst = 1
	RunningApplication	BootStateConst = 2
)

func (e BootStateConst) GoString() string {return e.String() }
func (e BootStateConst) String() string {
	switch e {
		case 0:
			return "in Startup Monitor"
		case 1:
			return "running Bootloader"
		case 2:
			return "running Application"
	default:
		return fmt.Sprintf("%s(%d)", "BootStateConst", int(e))
	}
}

type AccessLevelConst uint8
const (
	Locked	AccessLevelConst = 0
	UnlockedLevel1	AccessLevelConst = 1
	UnlockedLevel2	AccessLevelConst = 2
)

func (e AccessLevelConst) GoString() string {return e.String() }
func (e AccessLevelConst) String() string {
	switch e {
		case 0:
			return "Locked"
		case 1:
			return "unlocked level 1"
		case 2:
			return "unlocked level 2"
	default:
		return fmt.Sprintf("%s(%d)", "AccessLevelConst", int(e))
	}
}

type TransmissionIntervalConst uint8
const (
	Acknowledge_2	TransmissionIntervalConst = 0
	TransmitIntervalPriorityNotSupported	TransmissionIntervalConst = 1
	TransmitIntervalTooLow	TransmissionIntervalConst = 2
	AccessDenied	TransmissionIntervalConst = 3
	NotSupported	TransmissionIntervalConst = 4
)

func (e TransmissionIntervalConst) GoString() string {return e.String() }
func (e TransmissionIntervalConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Transmit Interval/Priority not supported"
		case 2:
			return "Transmit Interval too low"
		case 3:
			return "Access denied"
		case 4:
			return "Not supported"
	default:
		return fmt.Sprintf("%s(%d)", "TransmissionIntervalConst", int(e))
	}
}

type ParameterFieldConst uint8
const (
	Acknowledge_3	ParameterFieldConst = 0
	InvalidParameterField	ParameterFieldConst = 1
	TemporaryError	ParameterFieldConst = 2
	ParameterOutOfRange	ParameterFieldConst = 3
	AccessDenied_2	ParameterFieldConst = 4
	NotSupported_2	ParameterFieldConst = 5
	ReadOrWriteNotSupported	ParameterFieldConst = 6
)

func (e ParameterFieldConst) GoString() string {return e.String() }
func (e ParameterFieldConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Invalid parameter field"
		case 2:
			return "Temporary error"
		case 3:
			return "Parameter out of range"
		case 4:
			return "Access denied"
		case 5:
			return "Not supported"
		case 6:
			return "Read or Write not supported"
	default:
		return fmt.Sprintf("%s(%d)", "ParameterFieldConst", int(e))
	}
}

type PgnListFunctionConst uint8
const (
	TransmitPGNList	PgnListFunctionConst = 0
	ReceivePGNList	PgnListFunctionConst = 1
)

func (e PgnListFunctionConst) GoString() string {return e.String() }
func (e PgnListFunctionConst) String() string {
	switch e {
		case 0:
			return "Transmit PGN list"
		case 1:
			return "Receive PGN list"
	default:
		return fmt.Sprintf("%s(%d)", "PgnListFunctionConst", int(e))
	}
}

type FusionCommandConst uint8
const (
	Play_2	FusionCommandConst = 1
	Pause_2	FusionCommandConst = 2
	Next	FusionCommandConst = 4
	Prev	FusionCommandConst = 6
)

func (e FusionCommandConst) GoString() string {return e.String() }
func (e FusionCommandConst) String() string {
	switch e {
		case 1:
			return "Play"
		case 2:
			return "Pause"
		case 4:
			return "Next"
		case 6:
			return "Prev"
	default:
		return fmt.Sprintf("%s(%d)", "FusionCommandConst", int(e))
	}
}

type FusionSiriusCommandConst uint8
const (
	Next_2	FusionSiriusCommandConst = 1
	Prev_2	FusionSiriusCommandConst = 2
)

func (e FusionSiriusCommandConst) GoString() string {return e.String() }
func (e FusionSiriusCommandConst) String() string {
	switch e {
		case 1:
			return "Next"
		case 2:
			return "Prev"
	default:
		return fmt.Sprintf("%s(%d)", "FusionSiriusCommandConst", int(e))
	}
}

type FusionMuteCommandConst uint8
const (
	MuteOn	FusionMuteCommandConst = 1
	MuteOff	FusionMuteCommandConst = 2
)

func (e FusionMuteCommandConst) GoString() string {return e.String() }
func (e FusionMuteCommandConst) String() string {
	switch e {
		case 1:
			return "Mute On"
		case 2:
			return "Mute Off"
	default:
		return fmt.Sprintf("%s(%d)", "FusionMuteCommandConst", int(e))
	}
}

type SeatalkKeystrokeConst uint8
const (
	Auto_3	SeatalkKeystrokeConst = 1
	Standby_2	SeatalkKeystrokeConst = 2
	Wind_2	SeatalkKeystrokeConst = 3
	AMinus1	SeatalkKeystrokeConst = 5
	AMinus10	SeatalkKeystrokeConst = 6
	APlus1	SeatalkKeystrokeConst = 7
	APlus10	SeatalkKeystrokeConst = 8
	AMinus1AndMinus10	SeatalkKeystrokeConst = 33
	APlus1AndPlus10	SeatalkKeystrokeConst = 34
	Track_2	SeatalkKeystrokeConst = 35
)

func (e SeatalkKeystrokeConst) GoString() string {return e.String() }
func (e SeatalkKeystrokeConst) String() string {
	switch e {
		case 1:
			return "Auto"
		case 2:
			return "Standby"
		case 3:
			return "Wind"
		case 5:
			return "A-1"
		case 6:
			return "A-10"
		case 7:
			return "A+1"
		case 8:
			return "A+10"
		case 33:
			return "A-1 and -10"
		case 34:
			return "A+1 and +10"
		case 35:
			return "Track"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkKeystrokeConst", int(e))
	}
}

type SeatalkDeviceIdConst uint8
const (
	S100	SeatalkDeviceIdConst = 3
	CourseComputer	SeatalkDeviceIdConst = 5
)

func (e SeatalkDeviceIdConst) GoString() string {return e.String() }
func (e SeatalkDeviceIdConst) String() string {
	switch e {
		case 3:
			return "S100"
		case 5:
			return "Course Computer"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkDeviceIdConst", int(e))
	}
}

type SeatalkNetworkGroupConst uint8
const (
	None_2	SeatalkNetworkGroupConst = 0
	Helm1	SeatalkNetworkGroupConst = 1
	Helm2	SeatalkNetworkGroupConst = 2
	Cockpit	SeatalkNetworkGroupConst = 3
	Flybridge	SeatalkNetworkGroupConst = 4
	Mast	SeatalkNetworkGroupConst = 5
	Group1	SeatalkNetworkGroupConst = 6
	Group2	SeatalkNetworkGroupConst = 7
	Group3	SeatalkNetworkGroupConst = 8
	Group4	SeatalkNetworkGroupConst = 9
	Group5	SeatalkNetworkGroupConst = 10
)

func (e SeatalkNetworkGroupConst) GoString() string {return e.String() }
func (e SeatalkNetworkGroupConst) String() string {
	switch e {
		case 0:
			return "None"
		case 1:
			return "Helm 1"
		case 2:
			return "Helm 2"
		case 3:
			return "Cockpit"
		case 4:
			return "Flybridge"
		case 5:
			return "Mast"
		case 6:
			return "Group 1"
		case 7:
			return "Group 2"
		case 8:
			return "Group 3"
		case 9:
			return "Group 4"
		case 10:
			return "Group 5"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkNetworkGroupConst", int(e))
	}
}

type SeatalkDisplayColorConst uint8
const (
	Day1	SeatalkDisplayColorConst = 0
	Day2	SeatalkDisplayColorConst = 2
	RedBlack	SeatalkDisplayColorConst = 3
	Inverse	SeatalkDisplayColorConst = 4
)

func (e SeatalkDisplayColorConst) GoString() string {return e.String() }
func (e SeatalkDisplayColorConst) String() string {
	switch e {
		case 0:
			return "Day 1"
		case 2:
			return "Day 2"
		case 3:
			return "Red/Black"
		case 4:
			return "Inverse"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkDisplayColorConst", int(e))
	}
}

type AirmarCalibrateFunctionConst uint8
const (
	NormalCancelCalibration	AirmarCalibrateFunctionConst = 0
	EnterCalibrationMode	AirmarCalibrateFunctionConst = 1
	ResetCalibrationTo0	AirmarCalibrateFunctionConst = 2
	Verify	AirmarCalibrateFunctionConst = 3
	ResetCompassToDefaults	AirmarCalibrateFunctionConst = 4
	ResetDampingToDefaults	AirmarCalibrateFunctionConst = 5
)

func (e AirmarCalibrateFunctionConst) GoString() string {return e.String() }
func (e AirmarCalibrateFunctionConst) String() string {
	switch e {
		case 0:
			return "Normal/cancel calibration"
		case 1:
			return "Enter calibration mode"
		case 2:
			return "Reset calibration to 0"
		case 3:
			return "Verify"
		case 4:
			return "Reset compass to defaults"
		case 5:
			return "Reset damping to defaults"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCalibrateFunctionConst", int(e))
	}
}

type AirmarCalibrateStatusConst uint8
const (
	Queried	AirmarCalibrateStatusConst = 0
	Passed	AirmarCalibrateStatusConst = 1
	FailedTimeout	AirmarCalibrateStatusConst = 2
	FailedTiltError	AirmarCalibrateStatusConst = 3
	FailedOther	AirmarCalibrateStatusConst = 4
	InProgress	AirmarCalibrateStatusConst = 5
)

func (e AirmarCalibrateStatusConst) GoString() string {return e.String() }
func (e AirmarCalibrateStatusConst) String() string {
	switch e {
		case 0:
			return "Queried"
		case 1:
			return "Passed"
		case 2:
			return "Failed - timeout"
		case 3:
			return "Failed - tilt error"
		case 4:
			return "Failed - other"
		case 5:
			return "In progress"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCalibrateStatusConst", int(e))
	}
}

type AirmarTemperatureInstanceConst uint8
const (
	DeviceSensor	AirmarTemperatureInstanceConst = 0
	OnboardWaterSensor	AirmarTemperatureInstanceConst = 1
	OptionalWaterSensor	AirmarTemperatureInstanceConst = 2
)

func (e AirmarTemperatureInstanceConst) GoString() string {return e.String() }
func (e AirmarTemperatureInstanceConst) String() string {
	switch e {
		case 0:
			return "Device Sensor"
		case 1:
			return "Onboard Water Sensor"
		case 2:
			return "Optional Water Sensor"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarTemperatureInstanceConst", int(e))
	}
}

type AirmarFilterConst uint8
const (
	NoFilter	AirmarFilterConst = 0
	BasicIIRFilter	AirmarFilterConst = 1
)

func (e AirmarFilterConst) GoString() string {return e.String() }
func (e AirmarFilterConst) String() string {
	switch e {
		case 0:
			return "No filter"
		case 1:
			return "Basic IIR filter"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarFilterConst", int(e))
	}
}

type ControllerStateConst uint8
const (
	ErrorActive	ControllerStateConst = 0
	ErrorPassive	ControllerStateConst = 1
	BusOff	ControllerStateConst = 2
)

func (e ControllerStateConst) GoString() string {return e.String() }
func (e ControllerStateConst) String() string {
	switch e {
		case 0:
			return "Error Active"
		case 1:
			return "Error Passive"
		case 2:
			return "Bus Off"
	default:
		return fmt.Sprintf("%s(%d)", "ControllerStateConst", int(e))
	}
}

type EquipmentStatusConst uint8
const (
	Operational	EquipmentStatusConst = 0
	Fault_2	EquipmentStatusConst = 1
)

func (e EquipmentStatusConst) GoString() string {return e.String() }
func (e EquipmentStatusConst) String() string {
	switch e {
		case 0:
			return "Operational"
		case 1:
			return "Fault"
	default:
		return fmt.Sprintf("%s(%d)", "EquipmentStatusConst", int(e))
	}
}

type MobStatusConst uint8
const (
	MOBEmitterActivated	MobStatusConst = 0
	ManualOnBoardMOBButtonActivation	MobStatusConst = 1
	TestMode	MobStatusConst = 2
)

func (e MobStatusConst) GoString() string {return e.String() }
func (e MobStatusConst) String() string {
	switch e {
		case 0:
			return "MOB Emitter Activated"
		case 1:
			return "Manual on-board MOB Button Activation"
		case 2:
			return "Test mode"
	default:
		return fmt.Sprintf("%s(%d)", "MobStatusConst", int(e))
	}
}

type LowBatteryConst uint8
const (
	Good	LowBatteryConst = 0
	Low_2	LowBatteryConst = 1
)

func (e LowBatteryConst) GoString() string {return e.String() }
func (e LowBatteryConst) String() string {
	switch e {
		case 0:
			return "Good"
		case 1:
			return "Low"
	default:
		return fmt.Sprintf("%s(%d)", "LowBatteryConst", int(e))
	}
}

type TurnModeConst uint8
const (
	RudderLimitControlled	TurnModeConst = 0
	TurnRateControlled	TurnModeConst = 1
	RadiusControlled	TurnModeConst = 2
)

func (e TurnModeConst) GoString() string {return e.String() }
func (e TurnModeConst) String() string {
	switch e {
		case 0:
			return "Rudder limit controlled"
		case 1:
			return "Turn rate controlled"
		case 2:
			return "Radius controlled"
	default:
		return fmt.Sprintf("%s(%d)", "TurnModeConst", int(e))
	}
}

type AcceptabilityConst uint8
const (
	BadLevel	AcceptabilityConst = 0
	BadFrequency	AcceptabilityConst = 1
	BeingQualified	AcceptabilityConst = 2
	Good_2	AcceptabilityConst = 3
)

func (e AcceptabilityConst) GoString() string {return e.String() }
func (e AcceptabilityConst) String() string {
	switch e {
		case 0:
			return "Bad level"
		case 1:
			return "Bad frequency"
		case 2:
			return "Being qualified"
		case 3:
			return "Good"
	default:
		return fmt.Sprintf("%s(%d)", "AcceptabilityConst", int(e))
	}
}

type LineConst uint8
const (
	Line1	LineConst = 0
	Line2	LineConst = 1
	Line3	LineConst = 2
)

func (e LineConst) GoString() string {return e.String() }
func (e LineConst) String() string {
	switch e {
		case 0:
			return "Line 1"
		case 1:
			return "Line 2"
		case 2:
			return "Line 3"
	default:
		return fmt.Sprintf("%s(%d)", "LineConst", int(e))
	}
}

type WaveformConst uint8
const (
	SineWave	WaveformConst = 0
	ModifiedSineWave	WaveformConst = 1
)

func (e WaveformConst) GoString() string {return e.String() }
func (e WaveformConst) String() string {
	switch e {
		case 0:
			return "Sine wave"
		case 1:
			return "Modified sine wave"
	default:
		return fmt.Sprintf("%s(%d)", "WaveformConst", int(e))
	}
}

type TankTypeConst uint8
const (
	Fuel_2	TankTypeConst = 0
	Water_2	TankTypeConst = 1
	GrayWater	TankTypeConst = 2
	LiveWell	TankTypeConst = 3
	Oil_2	TankTypeConst = 4
	BlackWater	TankTypeConst = 5
)

func (e TankTypeConst) GoString() string {return e.String() }
func (e TankTypeConst) String() string {
	switch e {
		case 0:
			return "Fuel"
		case 1:
			return "Water"
		case 2:
			return "Gray water"
		case 3:
			return "Live well"
		case 4:
			return "Oil"
		case 5:
			return "Black water"
	default:
		return fmt.Sprintf("%s(%d)", "TankTypeConst", int(e))
	}
}

type DcSourceConst uint8
const (
	Battery	DcSourceConst = 0
	Alternator	DcSourceConst = 1
	Convertor	DcSourceConst = 2
	SolarCell	DcSourceConst = 3
	WindGenerator	DcSourceConst = 4
)

func (e DcSourceConst) GoString() string {return e.String() }
func (e DcSourceConst) String() string {
	switch e {
		case 0:
			return "Battery"
		case 1:
			return "Alternator"
		case 2:
			return "Convertor"
		case 3:
			return "Solar cell"
		case 4:
			return "Wind generator"
	default:
		return fmt.Sprintf("%s(%d)", "DcSourceConst", int(e))
	}
}

type ChargerStateConst uint8
const (
	NotCharging	ChargerStateConst = 0
	Bulk_2	ChargerStateConst = 1
	Absorption_2	ChargerStateConst = 2
	Overcharge	ChargerStateConst = 3
	Equalise	ChargerStateConst = 4
	Float_2	ChargerStateConst = 5
	NoFloat	ChargerStateConst = 6
	ConstantVI	ChargerStateConst = 7
	Disabled_3	ChargerStateConst = 8
	Fault_3	ChargerStateConst = 9
)

func (e ChargerStateConst) GoString() string {return e.String() }
func (e ChargerStateConst) String() string {
	switch e {
		case 0:
			return "Not charging"
		case 1:
			return "Bulk"
		case 2:
			return "Absorption"
		case 3:
			return "Overcharge"
		case 4:
			return "Equalise"
		case 5:
			return "Float"
		case 6:
			return "No float"
		case 7:
			return "Constant VI"
		case 8:
			return "Disabled"
		case 9:
			return "Fault"
	default:
		return fmt.Sprintf("%s(%d)", "ChargerStateConst", int(e))
	}
}

type ChargingAlgorithmConst uint8
const (
	Trickle	ChargingAlgorithmConst = 0
	ConstantVoltageConstantCurrent	ChargingAlgorithmConst = 1
	A2StageNoFloat	ChargingAlgorithmConst = 2
	A3Stage	ChargingAlgorithmConst = 3
)

func (e ChargingAlgorithmConst) GoString() string {return e.String() }
func (e ChargingAlgorithmConst) String() string {
	switch e {
		case 0:
			return "Trickle"
		case 1:
			return "Constant voltage / Constant current"
		case 2:
			return "A2 stage (no float)"
		case 3:
			return "A3 stage"
	default:
		return fmt.Sprintf("%s(%d)", "ChargingAlgorithmConst", int(e))
	}
}

type ChargerModeConst uint8
const (
	Standalone	ChargerModeConst = 0
	Primary	ChargerModeConst = 1
	Secondary	ChargerModeConst = 2
	Echo	ChargerModeConst = 3
)

func (e ChargerModeConst) GoString() string {return e.String() }
func (e ChargerModeConst) String() string {
	switch e {
		case 0:
			return "Standalone"
		case 1:
			return "Primary"
		case 2:
			return "Secondary"
		case 3:
			return "Echo"
	default:
		return fmt.Sprintf("%s(%d)", "ChargerModeConst", int(e))
	}
}

type InverterStateConst uint8
const (
	Invert	InverterStateConst = 0
	ACPassthru	InverterStateConst = 1
	LoadSense	InverterStateConst = 2
	Fault_4	InverterStateConst = 3
	Disabled_4	InverterStateConst = 4
)

func (e InverterStateConst) GoString() string {return e.String() }
func (e InverterStateConst) String() string {
	switch e {
		case 0:
			return "Invert"
		case 1:
			return "AC passthru"
		case 2:
			return "Load sense"
		case 3:
			return "Fault"
		case 4:
			return "Disabled"
	default:
		return fmt.Sprintf("%s(%d)", "InverterStateConst", int(e))
	}
}

type BatteryTypeConst uint8
const (
	Flooded	BatteryTypeConst = 0
	Gel	BatteryTypeConst = 1
	AGM	BatteryTypeConst = 2
)

func (e BatteryTypeConst) GoString() string {return e.String() }
func (e BatteryTypeConst) String() string {
	switch e {
		case 0:
			return "Flooded"
		case 1:
			return "Gel"
		case 2:
			return "AGM"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryTypeConst", int(e))
	}
}

type BatteryVoltageConst uint8
const (
	A6V	BatteryVoltageConst = 0
	A12V	BatteryVoltageConst = 1
	A24V	BatteryVoltageConst = 2
	A32V	BatteryVoltageConst = 3
	A36V	BatteryVoltageConst = 4
	A42V	BatteryVoltageConst = 5
	A48V	BatteryVoltageConst = 6
)

func (e BatteryVoltageConst) GoString() string {return e.String() }
func (e BatteryVoltageConst) String() string {
	switch e {
		case 0:
			return "A6V"
		case 1:
			return "A12V"
		case 2:
			return "A24V"
		case 3:
			return "A32V"
		case 4:
			return "A36V"
		case 5:
			return "A42V"
		case 6:
			return "A48V"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryVoltageConst", int(e))
	}
}

type BatteryChemistryConst uint8
const (
	PbLead	BatteryChemistryConst = 0
	Li	BatteryChemistryConst = 1
	NiCd	BatteryChemistryConst = 2
	ZnO	BatteryChemistryConst = 3
	NiMH	BatteryChemistryConst = 4
)

func (e BatteryChemistryConst) GoString() string {return e.String() }
func (e BatteryChemistryConst) String() string {
	switch e {
		case 0:
			return "Pb (Lead)"
		case 1:
			return "Li"
		case 2:
			return "NiCd"
		case 3:
			return "ZnO"
		case 4:
			return "NiMH"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryChemistryConst", int(e))
	}
}

type GoodWarningErrorConst uint8
const (
	Good_3	GoodWarningErrorConst = 0
	Warning_3	GoodWarningErrorConst = 1
	Error_3	GoodWarningErrorConst = 2
)

func (e GoodWarningErrorConst) GoString() string {return e.String() }
func (e GoodWarningErrorConst) String() string {
	switch e {
		case 0:
			return "Good"
		case 1:
			return "Warning"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "GoodWarningErrorConst", int(e))
	}
}

type TrackingConst uint8
const (
	Cancelled	TrackingConst = 0
	Acquiring	TrackingConst = 1
	Tracking	TrackingConst = 2
	Lost	TrackingConst = 3
)

func (e TrackingConst) GoString() string {return e.String() }
func (e TrackingConst) String() string {
	switch e {
		case 0:
			return "Cancelled"
		case 1:
			return "Acquiring"
		case 2:
			return "Tracking"
		case 3:
			return "Lost"
	default:
		return fmt.Sprintf("%s(%d)", "TrackingConst", int(e))
	}
}

type TargetAcquisitionConst uint8
const (
	Manual_4	TargetAcquisitionConst = 0
	Automatic	TargetAcquisitionConst = 1
)

func (e TargetAcquisitionConst) GoString() string {return e.String() }
func (e TargetAcquisitionConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Automatic"
	default:
		return fmt.Sprintf("%s(%d)", "TargetAcquisitionConst", int(e))
	}
}

type WindlassDirectionConst uint8
const (
	Off_7	WindlassDirectionConst = 0
	Down	WindlassDirectionConst = 1
	Up	WindlassDirectionConst = 2
)

func (e WindlassDirectionConst) GoString() string {return e.String() }
func (e WindlassDirectionConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Down"
		case 2:
			return "Up"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassDirectionConst", int(e))
	}
}

type SpeedTypeConst uint8
const (
	SingleSpeed	SpeedTypeConst = 0
	DualSpeed	SpeedTypeConst = 1
	ProportionalSpeed	SpeedTypeConst = 2
)

func (e SpeedTypeConst) GoString() string {return e.String() }
func (e SpeedTypeConst) String() string {
	switch e {
		case 0:
			return "Single speed"
		case 1:
			return "Dual speed"
		case 2:
			return "Proportional speed"
	default:
		return fmt.Sprintf("%s(%d)", "SpeedTypeConst", int(e))
	}
}

type WindlassMotionConst uint8
const (
	WindlassStopped	WindlassMotionConst = 0
	DeploymentOccurring	WindlassMotionConst = 1
	RetrievalOccurring	WindlassMotionConst = 2
)

func (e WindlassMotionConst) GoString() string {return e.String() }
func (e WindlassMotionConst) String() string {
	switch e {
		case 0:
			return "Windlass stopped"
		case 1:
			return "Deployment occurring"
		case 2:
			return "Retrieval occurring"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassMotionConst", int(e))
	}
}

type RodeTypeConst uint8
const (
	ChainPresentlyDetected	RodeTypeConst = 0
	RopePresentlyDetected	RodeTypeConst = 1
)

func (e RodeTypeConst) GoString() string {return e.String() }
func (e RodeTypeConst) String() string {
	switch e {
		case 0:
			return "Chain presently detected"
		case 1:
			return "Rope presently detected"
	default:
		return fmt.Sprintf("%s(%d)", "RodeTypeConst", int(e))
	}
}

type DockingStatusConst uint8
const (
	NotDocked	DockingStatusConst = 0
	FullyDocked	DockingStatusConst = 1
)

func (e DockingStatusConst) GoString() string {return e.String() }
func (e DockingStatusConst) String() string {
	switch e {
		case 0:
			return "Not docked"
		case 1:
			return "Fully docked"
	default:
		return fmt.Sprintf("%s(%d)", "DockingStatusConst", int(e))
	}
}

type AisTypeConst uint8
const (
	SOTDMA	AisTypeConst = 0
	CS	AisTypeConst = 1
)

func (e AisTypeConst) GoString() string {return e.String() }
func (e AisTypeConst) String() string {
	switch e {
		case 0:
			return "SOTDMA"
		case 1:
			return "CS"
	default:
		return fmt.Sprintf("%s(%d)", "AisTypeConst", int(e))
	}
}

type AisBandConst uint8
const (
	Top525KHzOfMarineBand	AisBandConst = 0
	EntireMarineBand	AisBandConst = 1
)

func (e AisBandConst) GoString() string {return e.String() }
func (e AisBandConst) String() string {
	switch e {
		case 0:
			return "Top 525 kHz of marine band"
		case 1:
			return "Entire marine band"
	default:
		return fmt.Sprintf("%s(%d)", "AisBandConst", int(e))
	}
}

type AisModeConst uint8
const (
	Autonomous_2	AisModeConst = 0
	Assigned	AisModeConst = 1
)

func (e AisModeConst) GoString() string {return e.String() }
func (e AisModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous"
		case 1:
			return "Assigned"
	default:
		return fmt.Sprintf("%s(%d)", "AisModeConst", int(e))
	}
}

type AisCommunicationStateConst uint8
const (
	SOTDMA_2	AisCommunicationStateConst = 0
	ITDMA	AisCommunicationStateConst = 1
)

func (e AisCommunicationStateConst) GoString() string {return e.String() }
func (e AisCommunicationStateConst) String() string {
	switch e {
		case 0:
			return "SOTDMA"
		case 1:
			return "ITDMA"
	default:
		return fmt.Sprintf("%s(%d)", "AisCommunicationStateConst", int(e))
	}
}

type AvailableConst uint8
const (
	Available	AvailableConst = 0
	NotAvailable_3	AvailableConst = 1
)

func (e AvailableConst) GoString() string {return e.String() }
func (e AvailableConst) String() string {
	switch e {
		case 0:
			return "Available"
		case 1:
			return "Not available"
	default:
		return fmt.Sprintf("%s(%d)", "AvailableConst", int(e))
	}
}

type BearingModeConst uint8
const (
	GreatCircle	BearingModeConst = 0
	Rhumbline	BearingModeConst = 1
)

func (e BearingModeConst) GoString() string {return e.String() }
func (e BearingModeConst) String() string {
	switch e {
		case 0:
			return "Great Circle"
		case 1:
			return "Rhumbline"
	default:
		return fmt.Sprintf("%s(%d)", "BearingModeConst", int(e))
	}
}

type MarkTypeConst uint8
const (
	Collision_2	MarkTypeConst = 0
	TurningPoint	MarkTypeConst = 1
	Reference	MarkTypeConst = 2
	Wheelover	MarkTypeConst = 3
	Waypoint	MarkTypeConst = 4
)

func (e MarkTypeConst) GoString() string {return e.String() }
func (e MarkTypeConst) String() string {
	switch e {
		case 0:
			return "Collision"
		case 1:
			return "Turning point"
		case 2:
			return "Reference"
		case 3:
			return "Wheelover"
		case 4:
			return "Waypoint"
	default:
		return fmt.Sprintf("%s(%d)", "MarkTypeConst", int(e))
	}
}

type GnssModeConst uint8
const (
	A1D	GnssModeConst = 0
	A2D	GnssModeConst = 1
	A3D	GnssModeConst = 2
	Auto_4	GnssModeConst = 3
)

func (e GnssModeConst) GoString() string {return e.String() }
func (e GnssModeConst) String() string {
	switch e {
		case 0:
			return "A1D"
		case 1:
			return "A2D"
		case 2:
			return "A3D"
		case 3:
			return "Auto"
	default:
		return fmt.Sprintf("%s(%d)", "GnssModeConst", int(e))
	}
}

type RangeResidualModeConst uint8
const (
	RangeResidualsWereUsedToCalculateData	RangeResidualModeConst = 0
	RangeResidualsWereCalculatedAfterThePosition	RangeResidualModeConst = 1
)

func (e RangeResidualModeConst) GoString() string {return e.String() }
func (e RangeResidualModeConst) String() string {
	switch e {
		case 0:
			return "Range residuals were used to calculate data"
		case 1:
			return "Range residuals were calculated after the position"
	default:
		return fmt.Sprintf("%s(%d)", "RangeResidualModeConst", int(e))
	}
}

type DgnssModeConst uint8
const (
	None_3	DgnssModeConst = 0
	SBASIfAvailable	DgnssModeConst = 1
	SBAS	DgnssModeConst = 3
)

func (e DgnssModeConst) GoString() string {return e.String() }
func (e DgnssModeConst) String() string {
	switch e {
		case 0:
			return "None"
		case 1:
			return "SBAS if available"
		case 3:
			return "SBAS"
	default:
		return fmt.Sprintf("%s(%d)", "DgnssModeConst", int(e))
	}
}

type SatelliteStatusConst uint8
const (
	NotTracked	SatelliteStatusConst = 0
	Tracked	SatelliteStatusConst = 1
	Used	SatelliteStatusConst = 2
	NotTrackedDiff	SatelliteStatusConst = 3
	TrackedDiff	SatelliteStatusConst = 4
	UsedDiff	SatelliteStatusConst = 5
)

func (e SatelliteStatusConst) GoString() string {return e.String() }
func (e SatelliteStatusConst) String() string {
	switch e {
		case 0:
			return "Not tracked"
		case 1:
			return "Tracked"
		case 2:
			return "Used"
		case 3:
			return "Not tracked+Diff"
		case 4:
			return "Tracked+Diff"
		case 5:
			return "Used+Diff"
	default:
		return fmt.Sprintf("%s(%d)", "SatelliteStatusConst", int(e))
	}
}

type AisVersionConst uint8
const (
	ITURM1371Minus1	AisVersionConst = 0
	ITURM13713	AisVersionConst = 1
	ITURM13715	AisVersionConst = 2
	ITURM1371FutureEdition	AisVersionConst = 3
)

func (e AisVersionConst) GoString() string {return e.String() }
func (e AisVersionConst) String() string {
	switch e {
		case 0:
			return "ITU-R M.1371-1"
		case 1:
			return "ITU-R M.1371-3"
		case 2:
			return "ITU-R M.1371-5"
		case 3:
			return "ITU-R M.1371 future edition"
	default:
		return fmt.Sprintf("%s(%d)", "AisVersionConst", int(e))
	}
}

type TideConst uint8
const (
	Falling	TideConst = 0
	Rising	TideConst = 1
)

func (e TideConst) GoString() string {return e.String() }
func (e TideConst) String() string {
	switch e {
		case 0:
			return "Falling"
		case 1:
			return "Rising"
	default:
		return fmt.Sprintf("%s(%d)", "TideConst", int(e))
	}
}

type WatermakerStateConst uint8
const (
	Stopped	WatermakerStateConst = 0
	Starting	WatermakerStateConst = 1
	Running	WatermakerStateConst = 2
	Stopping	WatermakerStateConst = 3
	Flushing	WatermakerStateConst = 4
	Rinsing	WatermakerStateConst = 5
	Initiating	WatermakerStateConst = 6
	Manual_5	WatermakerStateConst = 7
)

func (e WatermakerStateConst) GoString() string {return e.String() }
func (e WatermakerStateConst) String() string {
	switch e {
		case 0:
			return "Stopped"
		case 1:
			return "Starting"
		case 2:
			return "Running"
		case 3:
			return "Stopping"
		case 4:
			return "Flushing"
		case 5:
			return "Rinsing"
		case 6:
			return "Initiating"
		case 7:
			return "Manual"
	default:
		return fmt.Sprintf("%s(%d)", "WatermakerStateConst", int(e))
	}
}

type EntertainmentIdTypeConst uint8
const (
	Group	EntertainmentIdTypeConst = 0
	File_3	EntertainmentIdTypeConst = 1
	EncryptedGroup	EntertainmentIdTypeConst = 2
	EncryptedFile	EntertainmentIdTypeConst = 3
)

func (e EntertainmentIdTypeConst) GoString() string {return e.String() }
func (e EntertainmentIdTypeConst) String() string {
	switch e {
		case 0:
			return "Group"
		case 1:
			return "File"
		case 2:
			return "Encrypted group"
		case 3:
			return "Encrypted file"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentIdTypeConst", int(e))
	}
}

type EntertainmentDefaultSettingsConst uint8
const (
	SaveCurrentSettingsAsUserDefault	EntertainmentDefaultSettingsConst = 0
	LoadUserDefault	EntertainmentDefaultSettingsConst = 1
	LoadManufacturerDefault	EntertainmentDefaultSettingsConst = 2
)

func (e EntertainmentDefaultSettingsConst) GoString() string {return e.String() }
func (e EntertainmentDefaultSettingsConst) String() string {
	switch e {
		case 0:
			return "Save current settings as user default"
		case 1:
			return "Load user default"
		case 2:
			return "Load manufacturer default"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentDefaultSettingsConst", int(e))
	}
}

type EntertainmentRegionsConst uint8
const (
	USA	EntertainmentRegionsConst = 0
	Europe	EntertainmentRegionsConst = 1
	Asia	EntertainmentRegionsConst = 2
	MiddleEast	EntertainmentRegionsConst = 3
	LatinAmerica	EntertainmentRegionsConst = 4
	Australia	EntertainmentRegionsConst = 5
	Russia	EntertainmentRegionsConst = 6
	Japan	EntertainmentRegionsConst = 7
)

func (e EntertainmentRegionsConst) GoString() string {return e.String() }
func (e EntertainmentRegionsConst) String() string {
	switch e {
		case 0:
			return "USA"
		case 1:
			return "Europe"
		case 2:
			return "Asia"
		case 3:
			return "Middle East"
		case 4:
			return "Latin America"
		case 5:
			return "Australia"
		case 6:
			return "Russia"
		case 7:
			return "Japan"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRegionsConst", int(e))
	}
}

type VideoProtocolsConst uint8
const (
	PAL	VideoProtocolsConst = 0
	NTSC	VideoProtocolsConst = 1
)

func (e VideoProtocolsConst) GoString() string {return e.String() }
func (e VideoProtocolsConst) String() string {
	switch e {
		case 0:
			return "PAL"
		case 1:
			return "NTSC"
	default:
		return fmt.Sprintf("%s(%d)", "VideoProtocolsConst", int(e))
	}
}

type EntertainmentVolumeControlConst uint8
const (
	Up_2	EntertainmentVolumeControlConst = 0
	Down_2	EntertainmentVolumeControlConst = 1
)

func (e EntertainmentVolumeControlConst) GoString() string {return e.String() }
func (e EntertainmentVolumeControlConst) String() string {
	switch e {
		case 0:
			return "Up"
		case 1:
			return "Down"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentVolumeControlConst", int(e))
	}
}

type BluetoothStatusConst uint8
const (
	Connected	BluetoothStatusConst = 0
	NotConnected	BluetoothStatusConst = 1
	NotPaired	BluetoothStatusConst = 2
)

func (e BluetoothStatusConst) GoString() string {return e.String() }
func (e BluetoothStatusConst) String() string {
	switch e {
		case 0:
			return "Connected"
		case 1:
			return "Not connected"
		case 2:
			return "Not paired"
	default:
		return fmt.Sprintf("%s(%d)", "BluetoothStatusConst", int(e))
	}
}

type BluetoothSourceStatusConst uint8
const (
	Reserved_3	BluetoothSourceStatusConst = 0
	Connected_2	BluetoothSourceStatusConst = 1
	Connecting	BluetoothSourceStatusConst = 2
	NotConnected_2	BluetoothSourceStatusConst = 3
)

func (e BluetoothSourceStatusConst) GoString() string {return e.String() }
func (e BluetoothSourceStatusConst) String() string {
	switch e {
		case 0:
			return "Reserved"
		case 1:
			return "Connected"
		case 2:
			return "Connecting"
		case 3:
			return "Not connected"
	default:
		return fmt.Sprintf("%s(%d)", "BluetoothSourceStatusConst", int(e))
	}
}

type SonichubCommandConst uint8
const (
	Init2	SonichubCommandConst = 1
	AMRadio	SonichubCommandConst = 4
	ZoneInfo	SonichubCommandConst = 5
	Source	SonichubCommandConst = 6
	SourceList	SonichubCommandConst = 8
	Control	SonichubCommandConst = 9
	FMRadio	SonichubCommandConst = 12
	Playlist	SonichubCommandConst = 13
	Track_3	SonichubCommandConst = 14
	Artist	SonichubCommandConst = 15
	Album	SonichubCommandConst = 16
	MenuItem	SonichubCommandConst = 19
	Zones	SonichubCommandConst = 20
	MaxVolume	SonichubCommandConst = 23
	Volume	SonichubCommandConst = 24
	Init1	SonichubCommandConst = 25
	Position	SonichubCommandConst = 48
	Init3	SonichubCommandConst = 50
)

func (e SonichubCommandConst) GoString() string {return e.String() }
func (e SonichubCommandConst) String() string {
	switch e {
		case 1:
			return "Init #2"
		case 4:
			return "AM Radio"
		case 5:
			return "Zone Info"
		case 6:
			return "Source"
		case 8:
			return "Source List"
		case 9:
			return "Control"
		case 12:
			return "FM Radio"
		case 13:
			return "Playlist"
		case 14:
			return "Track"
		case 15:
			return "Artist"
		case 16:
			return "Album"
		case 19:
			return "Menu Item"
		case 20:
			return "Zones"
		case 23:
			return "Max Volume"
		case 24:
			return "Volume"
		case 25:
			return "Init #1"
		case 48:
			return "Position"
		case 50:
			return "Init #3"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubCommandConst", int(e))
	}
}

type SimnetApModeConst uint8
const (
	Heading	SimnetApModeConst = 2
	Wind_3	SimnetApModeConst = 3
	Nav	SimnetApModeConst = 10
	NoDrift	SimnetApModeConst = 11
)

func (e SimnetApModeConst) GoString() string {return e.String() }
func (e SimnetApModeConst) String() string {
	switch e {
		case 2:
			return "Heading"
		case 3:
			return "Wind"
		case 10:
			return "Nav"
		case 11:
			return "No Drift"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApModeConst", int(e))
	}
}

type SimnetDeviceModelConst uint8
const (
	AC	SimnetDeviceModelConst = 0
	OtherDevice	SimnetDeviceModelConst = 1
	NAC	SimnetDeviceModelConst = 100
)

func (e SimnetDeviceModelConst) GoString() string {return e.String() }
func (e SimnetDeviceModelConst) String() string {
	switch e {
		case 0:
			return "AC"
		case 1:
			return "Other device"
		case 100:
			return "NAC"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDeviceModelConst", int(e))
	}
}

type SimnetDeviceReportConst uint8
const (
	Status	SimnetDeviceReportConst = 2
	SendStatus	SimnetDeviceReportConst = 3
	Mode	SimnetDeviceReportConst = 10
	SendMode	SimnetDeviceReportConst = 11
	SailingProcessorStatus	SimnetDeviceReportConst = 23
)

func (e SimnetDeviceReportConst) GoString() string {return e.String() }
func (e SimnetDeviceReportConst) String() string {
	switch e {
		case 2:
			return "Status"
		case 3:
			return "Send Status"
		case 10:
			return "Mode"
		case 11:
			return "Send Mode"
		case 23:
			return "Sailing Processor Status"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDeviceReportConst", int(e))
	}
}

type SimnetApStatusConst uint8
const (
	Manual_6	SimnetApStatusConst = 2
	Automatic_2	SimnetApStatusConst = 16
)

func (e SimnetApStatusConst) GoString() string {return e.String() }
func (e SimnetApStatusConst) String() string {
	switch e {
		case 2:
			return "Manual"
		case 16:
			return "Automatic"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApStatusConst", int(e))
	}
}

type SimnetCommandConst uint8
const (
	Text	SimnetCommandConst = 50
)

func (e SimnetCommandConst) GoString() string {return e.String() }
func (e SimnetCommandConst) String() string {
	switch e {
		case 50:
			return "Text"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetCommandConst", int(e))
	}
}

type SimnetEventCommandConst uint8
const (
	Alarm_2	SimnetEventCommandConst = 1
	APCommand	SimnetEventCommandConst = 2
	Autopilot_2	SimnetEventCommandConst = 255
)

func (e SimnetEventCommandConst) GoString() string {return e.String() }
func (e SimnetEventCommandConst) String() string {
	switch e {
		case 1:
			return "Alarm"
		case 2:
			return "AP command"
		case 255:
			return "Autopilot"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetEventCommandConst", int(e))
	}
}

type SimnetNightModeConst uint8
const (
	Day	SimnetNightModeConst = 2
	Night	SimnetNightModeConst = 4
)

func (e SimnetNightModeConst) GoString() string {return e.String() }
func (e SimnetNightModeConst) String() string {
	switch e {
		case 2:
			return "Day"
		case 4:
			return "Night"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetNightModeConst", int(e))
	}
}

type SimnetNightModeColorConst uint8
const (
	Red	SimnetNightModeColorConst = 0
	Green	SimnetNightModeColorConst = 1
	Blue	SimnetNightModeColorConst = 2
	White	SimnetNightModeColorConst = 3
)

func (e SimnetNightModeColorConst) GoString() string {return e.String() }
func (e SimnetNightModeColorConst) String() string {
	switch e {
		case 0:
			return "Red"
		case 1:
			return "Green"
		case 2:
			return "Blue"
		case 3:
			return "White"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetNightModeColorConst", int(e))
	}
}

type SimnetDisplayGroupConst uint8
const (
	Default	SimnetDisplayGroupConst = 1
	Group1_2	SimnetDisplayGroupConst = 2
	Group2_2	SimnetDisplayGroupConst = 3
	Group3_2	SimnetDisplayGroupConst = 4
	Group4_2	SimnetDisplayGroupConst = 5
	Group5_2	SimnetDisplayGroupConst = 6
	Group6	SimnetDisplayGroupConst = 7
)

func (e SimnetDisplayGroupConst) GoString() string {return e.String() }
func (e SimnetDisplayGroupConst) String() string {
	switch e {
		case 1:
			return "Default"
		case 2:
			return "Group 1"
		case 3:
			return "Group 2"
		case 4:
			return "Group 3"
		case 5:
			return "Group 4"
		case 6:
			return "Group 5"
		case 7:
			return "Group 6"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDisplayGroupConst", int(e))
	}
}

type SimnetHourDisplayConst uint8
const (
	A24Hour	SimnetHourDisplayConst = 0
	A12Hour	SimnetHourDisplayConst = 1
)

func (e SimnetHourDisplayConst) GoString() string {return e.String() }
func (e SimnetHourDisplayConst) String() string {
	switch e {
		case 0:
			return "A24 hour"
		case 1:
			return "A12 hour"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetHourDisplayConst", int(e))
	}
}

type SimnetTimeFormatConst uint8
const (
	MMDdYyyy	SimnetTimeFormatConst = 1
	DdMMYyyy	SimnetTimeFormatConst = 2
)

func (e SimnetTimeFormatConst) GoString() string {return e.String() }
func (e SimnetTimeFormatConst) String() string {
	switch e {
		case 1:
			return "MM/dd/yyyy"
		case 2:
			return "dd/MM/yyyy"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetTimeFormatConst", int(e))
	}
}

type SimnetBacklightLevelConst uint8
const (
	A10PercentMin	SimnetBacklightLevelConst = 0
	DayMode	SimnetBacklightLevelConst = 1
	NightMode	SimnetBacklightLevelConst = 4
	A20Percent	SimnetBacklightLevelConst = 11
	A30Percent	SimnetBacklightLevelConst = 22
	A40Percent	SimnetBacklightLevelConst = 33
	A50Percent	SimnetBacklightLevelConst = 44
	A60Percent	SimnetBacklightLevelConst = 55
	A70Percent	SimnetBacklightLevelConst = 66
	A80Percent	SimnetBacklightLevelConst = 77
	A90Percent	SimnetBacklightLevelConst = 88
	A100PercentMax	SimnetBacklightLevelConst = 99
)

func (e SimnetBacklightLevelConst) GoString() string {return e.String() }
func (e SimnetBacklightLevelConst) String() string {
	switch e {
		case 0:
			return "A10% (Min)"
		case 1:
			return "Day mode"
		case 4:
			return "Night mode"
		case 11:
			return "A20%"
		case 22:
			return "A30%"
		case 33:
			return "A40%"
		case 44:
			return "A50%"
		case 55:
			return "A60%"
		case 66:
			return "A70%"
		case 77:
			return "A80%"
		case 88:
			return "A90%"
		case 99:
			return "A100% (Max)"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetBacklightLevelConst", int(e))
	}
}

type SimnetApEventsConst uint8
const (
	Standby_3	SimnetApEventsConst = 6
	AutoMode	SimnetApEventsConst = 9
	NavMode	SimnetApEventsConst = 10
	NonFollowUpMode	SimnetApEventsConst = 13
	FollowUpMode	SimnetApEventsConst = 14
	WindMode	SimnetApEventsConst = 15
	SquareTurn	SimnetApEventsConst = 18
	CTurn	SimnetApEventsConst = 19
	UTurn	SimnetApEventsConst = 20
	SpiralTurn	SimnetApEventsConst = 21
	ZigZagTurn	SimnetApEventsConst = 22
	LazySTurn	SimnetApEventsConst = 23
	DepthTurn	SimnetApEventsConst = 24
	ChangeCourse	SimnetApEventsConst = 26
	TimerSync	SimnetApEventsConst = 61
	PingPortEnd	SimnetApEventsConst = 112
	PingStarboardEnd	SimnetApEventsConst = 113
)

func (e SimnetApEventsConst) GoString() string {return e.String() }
func (e SimnetApEventsConst) String() string {
	switch e {
		case 6:
			return "Standby"
		case 9:
			return "Auto mode"
		case 10:
			return "Nav mode"
		case 13:
			return "Non Follow Up mode"
		case 14:
			return "Follow Up mode"
		case 15:
			return "Wind mode"
		case 18:
			return "Square (Turn)"
		case 19:
			return "C-Turn"
		case 20:
			return "U-Turn"
		case 21:
			return "Spiral (Turn)"
		case 22:
			return "Zig Zag (Turn)"
		case 23:
			return "Lazy-S (Turn)"
		case 24:
			return "Depth (Turn)"
		case 26:
			return "Change course"
		case 61:
			return "Timer sync"
		case 112:
			return "Ping port end"
		case 113:
			return "Ping starboard end"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApEventsConst", int(e))
	}
}

type SimnetDirectionConst uint8
const (
	Port	SimnetDirectionConst = 2
	Starboard	SimnetDirectionConst = 3
	LeftRudderPort	SimnetDirectionConst = 4
	RightRudderStarboard	SimnetDirectionConst = 5
)

func (e SimnetDirectionConst) GoString() string {return e.String() }
func (e SimnetDirectionConst) String() string {
	switch e {
		case 2:
			return "Port"
		case 3:
			return "Starboard"
		case 4:
			return "Left rudder (port)"
		case 5:
			return "Right rudder (starboard)"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDirectionConst", int(e))
	}
}

type SimnetAlarmConst uint8
const (
	LowBoatSpeed	SimnetAlarmConst = 57
	WindDataMissing	SimnetAlarmConst = 58
)

func (e SimnetAlarmConst) GoString() string {return e.String() }
func (e SimnetAlarmConst) String() string {
	switch e {
		case 57:
			return "Low boat speed"
		case 58:
			return "Wind data missing"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetAlarmConst", int(e))
	}
}

type FusionMessageIdConst uint8
const (
	RequestStatus	FusionMessageIdConst = 1
	Source_2	FusionMessageIdConst = 2
	TrackInfo	FusionMessageIdConst = 4
	TrackTitle	FusionMessageIdConst = 5
	TrackArtist	FusionMessageIdConst = 6
	TrackAlbum	FusionMessageIdConst = 7
	TrackProgress	FusionMessageIdConst = 9
	AMFMStation	FusionMessageIdConst = 11
	VHF	FusionMessageIdConst = 12
	Squelch	FusionMessageIdConst = 13
	Scan	FusionMessageIdConst = 14
	MenuItem_2	FusionMessageIdConst = 17
	Replay	FusionMessageIdConst = 20
	Mute	FusionMessageIdConst = 23
	SetZoneVolume	FusionMessageIdConst = 24
	SetAllVolumes	FusionMessageIdConst = 25
	SubVolume	FusionMessageIdConst = 26
	Tone	FusionMessageIdConst = 27
	Volume_2	FusionMessageIdConst = 29
	Power	FusionMessageIdConst = 32
	UnitName	FusionMessageIdConst = 33
	SiriusXMChannel	FusionMessageIdConst = 36
	SiriusXMTitle	FusionMessageIdConst = 37
	SiriusXMArtist	FusionMessageIdConst = 38
	SiriusXMGenre	FusionMessageIdConst = 40
	ZoneName	FusionMessageIdConst = 45
)

func (e FusionMessageIdConst) GoString() string {return e.String() }
func (e FusionMessageIdConst) String() string {
	switch e {
		case 1:
			return "Request Status"
		case 2:
			return "Source"
		case 4:
			return "Track Info"
		case 5:
			return "Track Title"
		case 6:
			return "Track Artist"
		case 7:
			return "Track Album"
		case 9:
			return "Track Progress"
		case 11:
			return "AM/FM Station"
		case 12:
			return "VHF"
		case 13:
			return "Squelch"
		case 14:
			return "Scan"
		case 17:
			return "Menu Item"
		case 20:
			return "Replay"
		case 23:
			return "Mute"
		case 24:
			return "Set Zone Volume"
		case 25:
			return "Set All Volumes"
		case 26:
			return "Sub Volume"
		case 27:
			return "Tone"
		case 29:
			return "Volume"
		case 32:
			return "Power"
		case 33:
			return "Unit Name"
		case 36:
			return "SiriusXM Channel"
		case 37:
			return "SiriusXM Title"
		case 38:
			return "SiriusXM Artist"
		case 40:
			return "SiriusXM Genre"
		case 45:
			return "Zone Name"
	default:
		return fmt.Sprintf("%s(%d)", "FusionMessageIdConst", int(e))
	}
}

type SonichubControlConst uint8
const (
	Set	SonichubControlConst = 0
	Ack	SonichubControlConst = 128
)

func (e SonichubControlConst) GoString() string {return e.String() }
func (e SonichubControlConst) String() string {
	switch e {
		case 0:
			return "Set"
		case 128:
			return "Ack"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubControlConst", int(e))
	}
}

type SonichubSourceConst uint8
const (
	AM_2	SonichubSourceConst = 0
	FM_2	SonichubSourceConst = 1
	IPod	SonichubSourceConst = 2
	USB_2	SonichubSourceConst = 3
	AUX	SonichubSourceConst = 4
	AUX2	SonichubSourceConst = 5
	Mic	SonichubSourceConst = 6
)

func (e SonichubSourceConst) GoString() string {return e.String() }
func (e SonichubSourceConst) String() string {
	switch e {
		case 0:
			return "AM"
		case 1:
			return "FM"
		case 2:
			return "iPod"
		case 3:
			return "USB"
		case 4:
			return "AUX"
		case 5:
			return "AUX 2"
		case 6:
			return "Mic"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubSourceConst", int(e))
	}
}

type IsoControlConst uint8
const (
	ACK	IsoControlConst = 0
	NAK	IsoControlConst = 1
	AccessDenied_3	IsoControlConst = 2
	AddressBusy	IsoControlConst = 3
)

func (e IsoControlConst) GoString() string {return e.String() }
func (e IsoControlConst) String() string {
	switch e {
		case 0:
			return "ACK"
		case 1:
			return "NAK"
		case 2:
			return "Access Denied"
		case 3:
			return "Address Busy"
	default:
		return fmt.Sprintf("%s(%d)", "IsoControlConst", int(e))
	}
}

type IsoCommandConst uint8
const (
	ACK_2	IsoCommandConst = 0
	RTS	IsoCommandConst = 16
	CTS	IsoCommandConst = 17
	EOM	IsoCommandConst = 19
	BAM	IsoCommandConst = 32
	Abort	IsoCommandConst = 255
)

func (e IsoCommandConst) GoString() string {return e.String() }
func (e IsoCommandConst) String() string {
	switch e {
		case 0:
			return "ACK"
		case 16:
			return "RTS"
		case 17:
			return "CTS"
		case 19:
			return "EOM"
		case 32:
			return "BAM"
		case 255:
			return "Abort"
	default:
		return fmt.Sprintf("%s(%d)", "IsoCommandConst", int(e))
	}
}

type GroupFunctionConst uint8
const (
	Request	GroupFunctionConst = 0
	Command	GroupFunctionConst = 1
	Acknowledge_4	GroupFunctionConst = 2
	ReadFields	GroupFunctionConst = 3
	ReadFieldsReply	GroupFunctionConst = 4
	WriteFields	GroupFunctionConst = 5
	WriteFieldsReply	GroupFunctionConst = 6
)

func (e GroupFunctionConst) GoString() string {return e.String() }
func (e GroupFunctionConst) String() string {
	switch e {
		case 0:
			return "Request"
		case 1:
			return "Command"
		case 2:
			return "Acknowledge"
		case 3:
			return "Read Fields"
		case 4:
			return "Read Fields Reply"
		case 5:
			return "Write Fields"
		case 6:
			return "Write Fields Reply"
	default:
		return fmt.Sprintf("%s(%d)", "GroupFunctionConst", int(e))
	}
}

type AirmarCommandConst uint8
const (
	AttitudeOffsets	AirmarCommandConst = 32
	CalibrateCompass	AirmarCommandConst = 33
	TrueWindOptions	AirmarCommandConst = 34
	SimulateMode_2	AirmarCommandConst = 35
	CalibrateDepth	AirmarCommandConst = 40
	CalibrateSpeed	AirmarCommandConst = 41
	CalibrateTemperature	AirmarCommandConst = 42
	SpeedFilter	AirmarCommandConst = 43
	TemperatureFilter	AirmarCommandConst = 44
	NMEA2000Options	AirmarCommandConst = 46
)

func (e AirmarCommandConst) GoString() string {return e.String() }
func (e AirmarCommandConst) String() string {
	switch e {
		case 32:
			return "Attitude Offsets"
		case 33:
			return "Calibrate Compass"
		case 34:
			return "True Wind Options"
		case 35:
			return "Simulate Mode"
		case 40:
			return "Calibrate Depth"
		case 41:
			return "Calibrate Speed"
		case 42:
			return "Calibrate Temperature"
		case 43:
			return "Speed Filter"
		case 44:
			return "Temperature Filter"
		case 46:
			return "NMEA 2000 options"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCommandConst", int(e))
	}
}

type AirmarDepthQualityFactorConst uint8
const (
	DepthUnlocked	AirmarDepthQualityFactorConst = 0
	Quality10Percent	AirmarDepthQualityFactorConst = 1
	Quality20Percent	AirmarDepthQualityFactorConst = 2
	Quality30Percent	AirmarDepthQualityFactorConst = 3
	Quality40Percent	AirmarDepthQualityFactorConst = 4
	Quality50Percent	AirmarDepthQualityFactorConst = 5
	Quality60Percent	AirmarDepthQualityFactorConst = 6
	Quality70Percent	AirmarDepthQualityFactorConst = 7
	Quality80Percent	AirmarDepthQualityFactorConst = 8
	Quality90Percent	AirmarDepthQualityFactorConst = 9
	Quality100Percent	AirmarDepthQualityFactorConst = 10
)

func (e AirmarDepthQualityFactorConst) GoString() string {return e.String() }
func (e AirmarDepthQualityFactorConst) String() string {
	switch e {
		case 0:
			return "Depth unlocked"
		case 1:
			return "Quality 10%"
		case 2:
			return "Quality 20%"
		case 3:
			return "Quality 30%"
		case 4:
			return "Quality 40%"
		case 5:
			return "Quality 50%"
		case 6:
			return "Quality 60%"
		case 7:
			return "Quality 70%"
		case 8:
			return "Quality 80%"
		case 9:
			return "Quality 90%"
		case 10:
			return "Quality 100%"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarDepthQualityFactorConst", int(e))
	}
}

type PgnErrorCodeConst uint8
const (
	Acknowledge_5	PgnErrorCodeConst = 0
	PGNNotSupported	PgnErrorCodeConst = 1
	PGNNotAvailable	PgnErrorCodeConst = 2
	AccessDenied_4	PgnErrorCodeConst = 3
	NotSupported_3	PgnErrorCodeConst = 4
	TagNotSupported	PgnErrorCodeConst = 5
	ReadOrWriteNotSupported_2	PgnErrorCodeConst = 6
)

func (e PgnErrorCodeConst) GoString() string {return e.String() }
func (e PgnErrorCodeConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "PGN not supported"
		case 2:
			return "PGN not available"
		case 3:
			return "Access denied"
		case 4:
			return "Not supported"
		case 5:
			return "Tag not supported"
		case 6:
			return "Read or Write not supported"
	default:
		return fmt.Sprintf("%s(%d)", "PgnErrorCodeConst", int(e))
	}
}

type AirmarTransmissionIntervalConst uint8
const (
	MeasureInterval	AirmarTransmissionIntervalConst = 0
	RequestedByUser	AirmarTransmissionIntervalConst = 1
)

func (e AirmarTransmissionIntervalConst) GoString() string {return e.String() }
func (e AirmarTransmissionIntervalConst) String() string {
	switch e {
		case 0:
			return "Measure interval"
		case 1:
			return "Requested by user"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarTransmissionIntervalConst", int(e))
	}
}

type MobPositionSourceConst uint8
const (
	PositionEstimatedByTheVessel	MobPositionSourceConst = 0
	PositionReportedByMOBEmitter	MobPositionSourceConst = 1
)

func (e MobPositionSourceConst) GoString() string {return e.String() }
func (e MobPositionSourceConst) String() string {
	switch e {
		case 0:
			return "Position estimated by the vessel"
		case 1:
			return "Position reported by MOB emitter"
	default:
		return fmt.Sprintf("%s(%d)", "MobPositionSourceConst", int(e))
	}
}

type SteeringModeConst uint8
const (
	MainSteering	SteeringModeConst = 0
	NonFollowUpDevice	SteeringModeConst = 1
	FollowUpDevice	SteeringModeConst = 2
	HeadingControlStandalone	SteeringModeConst = 3
	HeadingControl	SteeringModeConst = 4
	TrackControl	SteeringModeConst = 5
)

func (e SteeringModeConst) GoString() string {return e.String() }
func (e SteeringModeConst) String() string {
	switch e {
		case 0:
			return "Main Steering"
		case 1:
			return "Non-Follow-Up Device"
		case 2:
			return "Follow-Up Device"
		case 3:
			return "Heading Control Standalone"
		case 4:
			return "Heading Control"
		case 5:
			return "Track Control"
	default:
		return fmt.Sprintf("%s(%d)", "SteeringModeConst", int(e))
	}
}

type FusionRadioSourceConst uint8
const (
	AM_3	FusionRadioSourceConst = 0
	FM_3	FusionRadioSourceConst = 1
)

func (e FusionRadioSourceConst) GoString() string {return e.String() }
func (e FusionRadioSourceConst) String() string {
	switch e {
		case 0:
			return "AM"
		case 1:
			return "FM"
	default:
		return fmt.Sprintf("%s(%d)", "FusionRadioSourceConst", int(e))
	}
}

type FusionReplayModeConst uint8
const (
	USBRepeat	FusionReplayModeConst = 9
	USBShuffle	FusionReplayModeConst = 10
	IPodRepeat	FusionReplayModeConst = 12
	IPodShuffle	FusionReplayModeConst = 13
)

func (e FusionReplayModeConst) GoString() string {return e.String() }
func (e FusionReplayModeConst) String() string {
	switch e {
		case 9:
			return "USB repeat"
		case 10:
			return "USB shuffle"
		case 12:
			return "iPod repeat"
		case 13:
			return "iPod shuffle"
	default:
		return fmt.Sprintf("%s(%d)", "FusionReplayModeConst", int(e))
	}
}

type FusionReplayStatusConst uint8
const (
	Off_8	FusionReplayStatusConst = 0
	OneTrack	FusionReplayStatusConst = 1
	AllAlbum	FusionReplayStatusConst = 2
)

func (e FusionReplayStatusConst) GoString() string {return e.String() }
func (e FusionReplayStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "One/track"
		case 2:
			return "All/album"
	default:
		return fmt.Sprintf("%s(%d)", "FusionReplayStatusConst", int(e))
	}
}

type AirmarPostControlConst uint8
const (
	ReportPreviousValues	AirmarPostControlConst = 0
	GenerateNewValues	AirmarPostControlConst = 1
)

func (e AirmarPostControlConst) GoString() string {return e.String() }
func (e AirmarPostControlConst) String() string {
	switch e {
		case 0:
			return "Report previous values"
		case 1:
			return "Generate new values"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarPostControlConst", int(e))
	}
}

type AirmarPostIdConst uint8
const (
	FormatCode	AirmarPostIdConst = 1
	FactoryEEPROM	AirmarPostIdConst = 2
	UserEEPROM	AirmarPostIdConst = 3
	WaterTemperatureSensor	AirmarPostIdConst = 4
	SonarTransceiver	AirmarPostIdConst = 5
	SpeedSensor	AirmarPostIdConst = 6
	InternalTemperatureSensor	AirmarPostIdConst = 7
	BatteryVoltageSensor	AirmarPostIdConst = 8
)

func (e AirmarPostIdConst) GoString() string {return e.String() }
func (e AirmarPostIdConst) String() string {
	switch e {
		case 1:
			return "Format Code"
		case 2:
			return "Factory EEPROM"
		case 3:
			return "User EEPROM"
		case 4:
			return "Water Temperature Sensor"
		case 5:
			return "Sonar Transceiver"
		case 6:
			return "Speed sensor"
		case 7:
			return "Internal temperature sensor"
		case 8:
			return "Battery voltage sensor"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarPostIdConst", int(e))
	}
}

type SonichubTuningConst uint8
const (
	SeekingUp	SonichubTuningConst = 1
	Tuned	SonichubTuningConst = 2
	SeekingDown	SonichubTuningConst = 3
)

func (e SonichubTuningConst) GoString() string {return e.String() }
func (e SonichubTuningConst) String() string {
	switch e {
		case 1:
			return "Seeking up"
		case 2:
			return "Tuned"
		case 3:
			return "Seeking down"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubTuningConst", int(e))
	}
}

type SonichubPlaylistConst uint8
const (
	Report	SonichubPlaylistConst = 1
	NextSong	SonichubPlaylistConst = 4
	PreviousSong	SonichubPlaylistConst = 6
)

func (e SonichubPlaylistConst) GoString() string {return e.String() }
func (e SonichubPlaylistConst) String() string {
	switch e {
		case 1:
			return "Report"
		case 4:
			return "Next song"
		case 6:
			return "Previous song"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubPlaylistConst", int(e))
	}
}

type FusionPowerStateConst uint8
const (
	On_2	FusionPowerStateConst = 1
	Off_9	FusionPowerStateConst = 2
)

func (e FusionPowerStateConst) GoString() string {return e.String() }
func (e FusionPowerStateConst) String() string {
	switch e {
		case 1:
			return "On"
		case 2:
			return "Off"
	default:
		return fmt.Sprintf("%s(%d)", "FusionPowerStateConst", int(e))
	}
}

type PriorityConst uint8
const (
	A0	PriorityConst = 0
	A1	PriorityConst = 1
	A2	PriorityConst = 2
	A3	PriorityConst = 3
	A4	PriorityConst = 4
	A5	PriorityConst = 5
	A6	PriorityConst = 6
	A7	PriorityConst = 7
	LeaveUnchanged	PriorityConst = 8
	ResetToDefault	PriorityConst = 9
)

func (e PriorityConst) GoString() string {return e.String() }
func (e PriorityConst) String() string {
	switch e {
		case 0:
			return "A0"
		case 1:
			return "A1"
		case 2:
			return "A2"
		case 3:
			return "A3"
		case 4:
			return "A4"
		case 5:
			return "A5"
		case 6:
			return "A6"
		case 7:
			return "A7"
		case 8:
			return "Leave unchanged"
		case 9:
			return "Reset to default"
	default:
		return fmt.Sprintf("%s(%d)", "PriorityConst", int(e))
	}
}

type DeviceTempStateConst uint8
const (
	Cold	DeviceTempStateConst = 0
	Warm	DeviceTempStateConst = 1
	Hot	DeviceTempStateConst = 2
)

func (e DeviceTempStateConst) GoString() string {return e.String() }
func (e DeviceTempStateConst) String() string {
	switch e {
		case 0:
			return "Cold"
		case 1:
			return "Warm"
		case 2:
			return "Hot"
	default:
		return fmt.Sprintf("%s(%d)", "DeviceTempStateConst", int(e))
	}
}

type BandgDecimalsConst uint8
const (
	A0_2	BandgDecimalsConst = 0
	A1_2	BandgDecimalsConst = 1
	A2_2	BandgDecimalsConst = 2
	A3_2	BandgDecimalsConst = 3
	A4_2	BandgDecimalsConst = 4
	Auto_5	BandgDecimalsConst = 254
)

func (e BandgDecimalsConst) GoString() string {return e.String() }
func (e BandgDecimalsConst) String() string {
	switch e {
		case 0:
			return "A0"
		case 1:
			return "A1"
		case 2:
			return "A2"
		case 3:
			return "A3"
		case 4:
			return "A4"
		case 254:
			return "Auto"
	default:
		return fmt.Sprintf("%s(%d)", "BandgDecimalsConst", int(e))
	}
}

type GarminColorModeConst uint8
const (
	Day_2	GarminColorModeConst = 0
	Night_2	GarminColorModeConst = 1
	Color	GarminColorModeConst = 13
)

func (e GarminColorModeConst) GoString() string {return e.String() }
func (e GarminColorModeConst) String() string {
	switch e {
		case 0:
			return "Day"
		case 1:
			return "Night"
		case 13:
			return "Color"
	default:
		return fmt.Sprintf("%s(%d)", "GarminColorModeConst", int(e))
	}
}

type GarminColorConst uint8
const (
	DayFullColor	GarminColorConst = 0
	DayHighContrast	GarminColorConst = 1
	NightFullColor	GarminColorConst = 2
	NightRedBlack	GarminColorConst = 3
	NightGreenBlack	GarminColorConst = 4
)

func (e GarminColorConst) GoString() string {return e.String() }
func (e GarminColorConst) String() string {
	switch e {
		case 0:
			return "Day full color"
		case 1:
			return "Day high contrast"
		case 2:
			return "Night full color"
		case 3:
			return "Night red/black"
		case 4:
			return "Night green/black"
	default:
		return fmt.Sprintf("%s(%d)", "GarminColorConst", int(e))
	}
}

type GarminBacklightLevelConst uint8
const (
	A0Percent	GarminBacklightLevelConst = 0
	A5Percent	GarminBacklightLevelConst = 1
	A10Percent	GarminBacklightLevelConst = 2
	A15Percent	GarminBacklightLevelConst = 3
	A20Percent_2	GarminBacklightLevelConst = 4
	A25Percent	GarminBacklightLevelConst = 5
	A30Percent_2	GarminBacklightLevelConst = 6
	A35Percent	GarminBacklightLevelConst = 7
	A40Percent_2	GarminBacklightLevelConst = 8
	A45Percent	GarminBacklightLevelConst = 9
	A50Percent_2	GarminBacklightLevelConst = 10
	A55Percent	GarminBacklightLevelConst = 11
	A60Percent_2	GarminBacklightLevelConst = 12
	A65Percent	GarminBacklightLevelConst = 13
	A70Percent_2	GarminBacklightLevelConst = 14
	A75Percent	GarminBacklightLevelConst = 15
	A80Percent_2	GarminBacklightLevelConst = 16
	A85Percent	GarminBacklightLevelConst = 17
	A90Percent_2	GarminBacklightLevelConst = 18
	A95Percent	GarminBacklightLevelConst = 19
	A100Percent	GarminBacklightLevelConst = 20
)

func (e GarminBacklightLevelConst) GoString() string {return e.String() }
func (e GarminBacklightLevelConst) String() string {
	switch e {
		case 0:
			return "A0%"
		case 1:
			return "A5%"
		case 2:
			return "A10%"
		case 3:
			return "A15%"
		case 4:
			return "A20%"
		case 5:
			return "A25%"
		case 6:
			return "A30%"
		case 7:
			return "A35%"
		case 8:
			return "A40%"
		case 9:
			return "A45%"
		case 10:
			return "A50%"
		case 11:
			return "A55%"
		case 12:
			return "A60%"
		case 13:
			return "A65%"
		case 14:
			return "A70%"
		case 15:
			return "A75%"
		case 16:
			return "A80%"
		case 17:
			return "A85%"
		case 18:
			return "A90%"
		case 19:
			return "A95%"
		case 20:
			return "A100%"
	default:
		return fmt.Sprintf("%s(%d)", "GarminBacklightLevelConst", int(e))
	}
}

type SeatalkPilotMode16Const uint16
const (
	Standby_4	SeatalkPilotMode16Const = 0
	AutoCompassCommanded	SeatalkPilotMode16Const = 64
	VaneWindMode	SeatalkPilotMode16Const = 256
	TrackMode	SeatalkPilotMode16Const = 384
	NoDriftCOGReferencedInTrackCourseChanges	SeatalkPilotMode16Const = 385
)

func (e SeatalkPilotMode16Const) GoString() string {return e.String() }
func (e SeatalkPilotMode16Const) String() string {
	switch e {
		case 0:
			return "Standby"
		case 64:
			return "Auto, compass commanded"
		case 256:
			return "Vane, Wind Mode"
		case 384:
			return "Track Mode"
		case 385:
			return "No Drift, COG referenced (In track, course changes)"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkPilotMode16Const", int(e))
	}
}

type StationHealthConst uint8
const (
	NotWorking	StationHealthConst = 0
	Unmonitored	StationHealthConst = 1
	HealthyOperational	StationHealthConst = 2
	HealthyTestMode	StationHealthConst = 3
	TestMode_2	StationHealthConst = 4
)

func (e StationHealthConst) GoString() string {return e.String() }
func (e StationHealthConst) String() string {
	switch e {
		case 0:
			return "Not Working"
		case 1:
			return "Unmonitored"
		case 2:
			return "Healthy Operational"
		case 3:
			return "Healthy Test Mode"
		case 4:
			return "Test Mode"
	default:
		return fmt.Sprintf("%s(%d)", "StationHealthConst", int(e))
	}
}

type SerialBitRateConst uint8
const (
	A25	SerialBitRateConst = 0
	A50	SerialBitRateConst = 1
	A100	SerialBitRateConst = 2
	A200	SerialBitRateConst = 3
	A300	SerialBitRateConst = 4
	A600	SerialBitRateConst = 5
	A1200	SerialBitRateConst = 6
	A2400	SerialBitRateConst = 7
	A4800	SerialBitRateConst = 8
	A9600	SerialBitRateConst = 9
	A19200	SerialBitRateConst = 10
	A19200_2	SerialBitRateConst = 11
	A38400	SerialBitRateConst = 12
	A57600	SerialBitRateConst = 13
)

func (e SerialBitRateConst) GoString() string {return e.String() }
func (e SerialBitRateConst) String() string {
	switch e {
		case 0:
			return "A25"
		case 1:
			return "A50"
		case 2:
			return "A100"
		case 3:
			return "A200"
		case 4:
			return "A300"
		case 5:
			return "A600"
		case 6:
			return "A1200"
		case 7:
			return "A2400"
		case 8:
			return "A4800"
		case 9:
			return "A9600"
		case 10:
			return "A19200"
		case 11:
			return "A19200"
		case 12:
			return "A38400"
		case 13:
			return "A57600"
	default:
		return fmt.Sprintf("%s(%d)", "SerialBitRateConst", int(e))
	}
}

type SerialDetectionModeConst uint8
const (
	AutoBitRate	SerialDetectionModeConst = 0
	ManualBitRate	SerialDetectionModeConst = 1
)

func (e SerialDetectionModeConst) GoString() string {return e.String() }
func (e SerialDetectionModeConst) String() string {
	switch e {
		case 0:
			return "Auto bit rate"
		case 1:
			return "Manual bit rate"
	default:
		return fmt.Sprintf("%s(%d)", "SerialDetectionModeConst", int(e))
	}
}

type DifferentialSourceConst uint8
const (
	Auto_6	DifferentialSourceConst = 0
	Loran	DifferentialSourceConst = 1
	MSKBeacon	DifferentialSourceConst = 2
	FMSubcarrier	DifferentialSourceConst = 3
	AIS_2	DifferentialSourceConst = 4
	GroundBasedRadio	DifferentialSourceConst = 5
	SBAS_2	DifferentialSourceConst = 6
	Satellite	DifferentialSourceConst = 7
)

func (e DifferentialSourceConst) GoString() string {return e.String() }
func (e DifferentialSourceConst) String() string {
	switch e {
		case 0:
			return "Auto"
		case 1:
			return "Loran"
		case 2:
			return "MSK Beacon"
		case 3:
			return "FM Subcarrier"
		case 4:
			return "AIS"
		case 5:
			return "Ground based radio"
		case 6:
			return "SBAS"
		case 7:
			return "Satellite"
	default:
		return fmt.Sprintf("%s(%d)", "DifferentialSourceConst", int(e))
	}
}

type DifferentialModeConst uint8
const (
	Manual_7	DifferentialModeConst = 0
	AutoPower	DifferentialModeConst = 1
	AutoRange	DifferentialModeConst = 2
)

func (e DifferentialModeConst) GoString() string {return e.String() }
func (e DifferentialModeConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Auto Power"
		case 2:
			return "Auto Range"
	default:
		return fmt.Sprintf("%s(%d)", "DifferentialModeConst", int(e))
	}
}


type DeviceFunctionConst uint16
var DeviceFunctionConstMap = map[int]map[int]string{10: {130: "Diagnostic",
	140: "Bus Traffic Logger",
	 },
20: {110: "Alarm Enunciator",
	130: "Emergency Position Indicating Radio Beacon (EPIRB)",
	135: "Man Overboard",
	140: "Voyage Data Recorder",
	150: "Camera",
	 },
25: {130: "PC Gateway",
	131: "NMEA 2000 to Analog Gateway",
	132: "Analog to NMEA 2000 Gateway",
	133: "NMEA 2000 to Serial Gateway",
	135: "NMEA 0183 Gateway",
	136: "NMEA Network Gateway",
	137: "NMEA 2000 Wireless Gateway",
	140: "Router",
	150: "Bridge",
	160: "Repeater",
	 },
30: {130: "Binary Event Monitor",
	140: "Load Controller",
	141: "AC/DC Input",
	150: "Function Controller",
	 },
35: {140: "Engine",
	141: "DC Generator/Alternator",
	142: "Solar Panel (Solar Array)",
	143: "Wind Generator (DC)",
	144: "Fuel Cell",
	145: "Network Power Supply",
	151: "AC Generator",
	152: "AC Bus",
	153: "AC Mains (Utility/Shore)",
	154: "AC Output",
	160: "Power Converter - Battery Charger",
	161: "Power Converter - Battery Charger+Inverter",
	162: "Power Converter - Inverter",
	163: "Power Converter - DC",
	170: "Battery",
	180: "Engine Gateway",
	 },
40: {130: "Follow-up Controller",
	140: "Mode Controller",
	150: "Autopilot",
	155: "Rudder",
	160: "Heading Sensors",
	170: "Trim (Tabs)/Interceptors",
	180: "Attitude (Pitch, Roll, Yaw) Control",
	 },
50: {130: "Engineroom Monitoring",
	140: "Engine",
	141: "DC Generator/Alternator",
	150: "Engine Controller",
	151: "AC Generator",
	155: "Motor",
	160: "Engine Gateway",
	165: "Transmission",
	170: "Throttle/Shift Control",
	180: "Actuator",
	190: "Gauge Interface",
	200: "Gauge Large",
	210: "Gauge Small",
	 },
60: {130: "Bottom Depth",
	135: "Bottom Depth/Speed",
	136: "Bottom Depth/Speed/Temperature",
	140: "Ownship Attitude",
	145: "Ownship Position (GNSS)",
	150: "Ownship Position (Loran C)",
	155: "Speed",
	160: "Turn Rate Indicator",
	170: "Integrated Navigation",
	175: "Integrated Navigation System",
	190: "Navigation Management",
	195: "Automatic Identification System (AIS)",
	200: "Radar",
	201: "Infrared Imaging",
	205: "ECDIS",
	210: "ECS",
	220: "Direction Finder",
	230: "Voyage Status",
	 },
70: {130: "EPIRB",
	140: "AIS",
	150: "DSC",
	160: "Data Receiver/Transceiver",
	170: "Satellite",
	180: "Radio-telephone (MF/HF)",
	190: "Radiotelephone",
	 },
75: {130: "Temperature",
	140: "Pressure",
	150: "Fluid Level",
	160: "Flow",
	170: "Humidity",
	 },
80: {130: "Time/Date Systems",
	140: "VDR",
	150: "Integrated Instrumentation",
	160: "General Purpose Displays",
	170: "General Sensor Box",
	180: "Weather Instruments",
	190: "Transducer/General",
	200: "NMEA 0183 Converter",
	 },
85: {130: "Atmospheric",
	160: "Aquatic",
	 },
90: {130: "HVAC",
	 },
100: {130: "Scale (Catch)",
	 },
110: {130: "Button Interface",
	135: "Switch Interface",
	140: "Analog Interface",
	 },
120: {130: "Display",
	140: "Alarm Enunciator",
	 },
125: {130: "Multimedia Player",
	140: "Multimedia Controller",
	 },

}








type SimnetKeyValueConst uint16
var SimnetKeyValueConstMap = map[int]FieldDescriptor{0: {
		Name: "Heading Offset",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	41: {
		Name: "Timezone offset",
		CanboatType: "TIME",
		Resolution: 60,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	260: {
		Name: "True wind high",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	264: {
		Name: "Deep water",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	516: {
		Name: "True wind low",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	517: {
		Name: "Low boat speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	520: {
		Name: "Shallow water",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	768: {
		Name: "Local field",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	1024: {
		Name: "Field angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	1800: {
		Name: "Anchor depth",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	4863: {
		Name: "Backlight level",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	5160: {
		Name: "Time format",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	5161: {
		Name: "Time hour display",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	9983: {
		Name: "Night mode",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	11524: {
		Name: "True wind shift",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	22296: {
		Name: "AP low boat speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	32789: {
		Name: "Alert bits",
		CanboatType: "BITLOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "SIMNET_ALERT_BITFIELD",
		},
	44079: {
		Name: "Night mode color",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	55087: {
		Name: "Day mode invert",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	 
}



type BandgKeyValueConst uint16
var BandgKeyValueConstMap = map[int]FieldDescriptor{0: {
		Name: "Altitude",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	11: {
		Name: "Rudder Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	16: {
		Name: "User 5",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	17: {
		Name: "User 6",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	18: {
		Name: "User 7",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	19: {
		Name: "User 8",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	20: {
		Name: "User 9",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	21: {
		Name: "User 10",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	22: {
		Name: "User 11",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	23: {
		Name: "User 12",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	24: {
		Name: "User 13",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	25: {
		Name: "User 14",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	26: {
		Name: "User 15",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	27: {
		Name: "User 16",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	28: {
		Name: "Outside Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	29: {
		Name: "Outside Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	30: {
		Name: "Water Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	31: {
		Name: "Water Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	50: {
		Name: "Tacking Performance",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "%",
		BitLength: 0,
		BitLookupName: "",
		},
	52: {
		Name: "Attitude Roll",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	53: {
		Name: "Optimum Wind Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	56: {
		Name: "User 1",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	57: {
		Name: "User 2",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	58: {
		Name: "User 3",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	59: {
		Name: "User 4",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	60: {
		Name: "Roll Rate",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	64: {
		Name: "Forestay",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	65: {
		Name: "Water Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	77: {
		Name: "Wind Speed Apparent",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	79: {
		Name: "Wind Speed Apparent",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	80: {
		Name: "Average True Wind Direction",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	81: {
		Name: "Wind Angle Apparent",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	83: {
		Name: "Target TWA",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	85: {
		Name: "Wind Speed True",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	86: {
		Name: "Wind Speed True",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	89: {
		Name: "Wind Angle True",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	100: {
		Name: "Unknown",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	102: {
		Name: "Keel Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	103: {
		Name: "Canard Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	104: {
		Name: "Keel Trim Tab Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	105: {
		Name: "Course",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	109: {
		Name: "Wind Direction",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	111: {
		Name: "Next Leg AWA",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	113: {
		Name: "Next Leg AWS",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	117: {
		Name: "Race Timer",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	124: {
		Name: "Polar Performance",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "%",
		BitLength: 0,
		BitLookupName: "",
		},
	125: {
		Name: "Target Boat Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	126: {
		Name: "Polar Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	127: {
		Name: "VMG to Wind",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	129: {
		Name: "DR Distance",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	130: {
		Name: "Leeway Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	131: {
		Name: "Current Drift",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	132: {
		Name: "Current Set",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	135: {
		Name: "Barometric Pressure",
		CanboatType: "NUMBER",
		Resolution: 100,
		Unit: "Pa",
		BitLength: 0,
		BitLookupName: "",
		},
	152: {
		Name: "Distance to Start Line",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	154: {
		Name: "Heading on Opposite Tack",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	155: {
		Name: "Attitude Pitch",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	156: {
		Name: "Mast Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	157: {
		Name: "Wind Angle to Mast",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	158: {
		Name: "Pitch Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	163: {
		Name: "Daggerboard Position",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	164: {
		Name: "Boom Position",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	185: {
		Name: "MOB DR Bearing",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	186: {
		Name: "MOB DR Range",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	194: {
		Name: "Depth",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	195: {
		Name: "Depth",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	199: {
		Name: "Aft Depth",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	205: {
		Name: "Odometer",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	207: {
		Name: "Trip Distance",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	211: {
		Name: "DR Bearing",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	233: {
		Name: "Course Over Ground",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	235: {
		Name: "Speed Over Ground",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	239: {
		Name: "Remote 0",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	240: {
		Name: "Remote 1",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	241: {
		Name: "Remote 2",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	242: {
		Name: "Remote 3",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	243: {
		Name: "Remote 4",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	244: {
		Name: "Remote 5",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	245: {
		Name: "Remote 6",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	246: {
		Name: "Remote 7",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	247: {
		Name: "Remote 8",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	248: {
		Name: "Remote 9",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	256: {
		Name: "Layline Time",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	258: {
		Name: "Layline Distance",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	259: {
		Name: "Layline Distance",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	260: {
		Name: "Sailing Time to Waypoint",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	261: {
		Name: "Sailing Distance to Waypoint",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	262: {
		Name: "Sailing ETA",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	265: {
		Name: "Trip Time",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	270: {
		Name: "Bow Latitude",
		CanboatType: "NUMBER",
		Resolution: 1e-07,
		Unit: "deg",
		BitLength: 0,
		BitLookupName: "",
		},
	271: {
		Name: "Bow Longitude",
		CanboatType: "NUMBER",
		Resolution: 1e-07,
		Unit: "deg",
		BitLength: 0,
		BitLookupName: "",
		},
	272: {
		Name: "Start Line Bearing",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	273: {
		Name: "Start Line Bias",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	274: {
		Name: "Distance to Start Line Port",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	275: {
		Name: "Distance to Start Line Starboard",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	280: {
		Name: "Bias Advantage in Boat Lengths",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	281: {
		Name: "Distance to Start Line in Boat Lengths",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	282: {
		Name: "Backstay",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	283: {
		Name: "Boom Vang",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	284: {
		Name: "Chain Length",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	285: {
		Name: "VMG Performance",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "%",
		BitLength: 0,
		BitLookupName: "",
		},
	286: {
		Name: "Inner Forestay Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	287: {
		Name: "Inner Forestay Halyard Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	288: {
		Name: "Jib Furl",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	289: {
		Name: "Jib Halyard Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	290: {
		Name: "Outhaul Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	291: {
		Name: "Plow Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	292: {
		Name: "Cunningham",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	293: {
		Name: "Jacuzzi Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	294: {
		Name: "Pool Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	296: {
		Name: "Keel Draught",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	297: {
		Name: "Boom Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	298: {
		Name: "Code Zero Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	301: {
		Name: "Distance Behind Start Line",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	302: {
		Name: "Distance Behind Start Line in Boat Lengths",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	305: {
		Name: "Bias Advantage",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	306: {
		Name: "Opposite Tack COG",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	307: {
		Name: "Opposite Tack Target Heading",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	308: {
		Name: "Mast Rake",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	309: {
		Name: "Next Leg Bearing",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	310: {
		Name: "Next Leg Target Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	311: {
		Name: "Ground Wind Direction",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	312: {
		Name: "Ground Wind Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	313: {
		Name: "Mast Cant Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	314: {
		Name: "Rudder Toe In",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	315: {
		Name: "Daggerboard Port",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	316: {
		Name: "Daggerboard Starboard",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	317: {
		Name: "User 17",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	318: {
		Name: "User 18",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	319: {
		Name: "User 19",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	320: {
		Name: "User 20",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	321: {
		Name: "User 21",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	322: {
		Name: "User 22",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	323: {
		Name: "User 23",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	324: {
		Name: "User 24",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	325: {
		Name: "User 25",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	326: {
		Name: "User 26",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	327: {
		Name: "User 27",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	328: {
		Name: "User 28",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	329: {
		Name: "User 29",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	330: {
		Name: "User 30",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	331: {
		Name: "User 31",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	332: {
		Name: "User 32",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	336: {
		Name: "Average True Wind Direction",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	337: {
		Name: "Wind Phase",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	338: {
		Name: "Wind Lift",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	380: {
		Name: "Active Perf Mode",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	381: {
		Name: "Gust Bear Away",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	382: {
		Name: "TWS Bear Away",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	383: {
		Name: "Heel Compensation",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	384: {
		Name: "Pilot Net Course",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	385: {
		Name: "Pilot Target Wind Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	386: {
		Name: "Pilot Weather Helm",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	387: {
		Name: "Pilot Mean Heel",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	 
}


type StationStatusConst uint16
const (
	StationInUse	StationStatusConst = 0
	LowSNR	StationStatusConst = 1
	CycleError	StationStatusConst = 2
	Blink	StationStatusConst = 3
)

func (e StationStatusConst) GoString() string {return e.String() }
func (e StationStatusConst) String() string {
	switch e {
		case 0:
			return "Station in use"
		case 1:
			return "Low SNR"
		case 2:
			return "Cycle Error"
		case 3:
			return "Blink"
	default:
		return fmt.Sprintf("%s(%d)", "StationStatusConst", int(e))
	}
}

type EngineStatus1Const uint16
const (
	CheckEngine	EngineStatus1Const = 0
	OverTemperature	EngineStatus1Const = 1
	LowOilPressure	EngineStatus1Const = 2
	LowOilLevel	EngineStatus1Const = 3
	LowFuelPressure	EngineStatus1Const = 4
	LowSystemVoltage	EngineStatus1Const = 5
	LowCoolantLevel	EngineStatus1Const = 6
	WaterFlow	EngineStatus1Const = 7
	WaterInFuel	EngineStatus1Const = 8
	ChargeIndicator	EngineStatus1Const = 9
	PreheatIndicator	EngineStatus1Const = 10
	HighBoostPressure	EngineStatus1Const = 11
	RevLimitExceeded	EngineStatus1Const = 12
	EGRSystem	EngineStatus1Const = 13
	ThrottlePositionSensor	EngineStatus1Const = 14
	EmergencyStop	EngineStatus1Const = 15
)

func (e EngineStatus1Const) GoString() string {return e.String() }
func (e EngineStatus1Const) String() string {
	switch e {
		case 0:
			return "Check Engine"
		case 1:
			return "Over Temperature"
		case 2:
			return "Low Oil Pressure"
		case 3:
			return "Low Oil Level"
		case 4:
			return "Low Fuel Pressure"
		case 5:
			return "Low System Voltage"
		case 6:
			return "Low Coolant Level"
		case 7:
			return "Water Flow"
		case 8:
			return "Water In Fuel"
		case 9:
			return "Charge Indicator"
		case 10:
			return "Preheat Indicator"
		case 11:
			return "High Boost Pressure"
		case 12:
			return "Rev Limit Exceeded"
		case 13:
			return "EGR System"
		case 14:
			return "Throttle Position Sensor"
		case 15:
			return "Emergency Stop"
	default:
		return fmt.Sprintf("%s(%d)", "EngineStatus1Const", int(e))
	}
}

type EngineStatus2Const uint16
const (
	WarningLevel1	EngineStatus2Const = 0
	WarningLevel2	EngineStatus2Const = 1
	PowerReduction	EngineStatus2Const = 2
	MaintenanceNeeded	EngineStatus2Const = 3
	EngineCommError	EngineStatus2Const = 4
	SubOrSecondaryThrottle	EngineStatus2Const = 5
	NeutralStartProtect	EngineStatus2Const = 6
	EngineShuttingDown	EngineStatus2Const = 7
)

func (e EngineStatus2Const) GoString() string {return e.String() }
func (e EngineStatus2Const) String() string {
	switch e {
		case 0:
			return "Warning Level 1"
		case 1:
			return "Warning Level 2"
		case 2:
			return "Power Reduction"
		case 3:
			return "Maintenance Needed"
		case 4:
			return "Engine Comm Error"
		case 5:
			return "Sub or Secondary Throttle"
		case 6:
			return "Neutral Start Protect"
		case 7:
			return "Engine Shutting Down"
	default:
		return fmt.Sprintf("%s(%d)", "EngineStatus2Const", int(e))
	}
}

type EntertainmentPlayStatusBitfieldConst uint16
const (
	Play_3	EntertainmentPlayStatusBitfieldConst = 0
	Pause_3	EntertainmentPlayStatusBitfieldConst = 1
	Stop_2	EntertainmentPlayStatusBitfieldConst = 2
	FF1x_2	EntertainmentPlayStatusBitfieldConst = 3
	FF2x_2	EntertainmentPlayStatusBitfieldConst = 4
	FF3x_2	EntertainmentPlayStatusBitfieldConst = 5
	FF4x_2	EntertainmentPlayStatusBitfieldConst = 6
	RW1x_2	EntertainmentPlayStatusBitfieldConst = 7
	RW2x_2	EntertainmentPlayStatusBitfieldConst = 8
	RW3x_2	EntertainmentPlayStatusBitfieldConst = 9
	RW4x_2	EntertainmentPlayStatusBitfieldConst = 10
	SkipAhead_2	EntertainmentPlayStatusBitfieldConst = 11
	SkipBack_2	EntertainmentPlayStatusBitfieldConst = 12
	JogAhead_2	EntertainmentPlayStatusBitfieldConst = 13
	JogBack_2	EntertainmentPlayStatusBitfieldConst = 14
	SeekUp_2	EntertainmentPlayStatusBitfieldConst = 15
	SeekDown_2	EntertainmentPlayStatusBitfieldConst = 16
	ScanUp_2	EntertainmentPlayStatusBitfieldConst = 17
	ScanDown_2	EntertainmentPlayStatusBitfieldConst = 18
	TuneUp_2	EntertainmentPlayStatusBitfieldConst = 19
	TuneDown_2	EntertainmentPlayStatusBitfieldConst = 20
	SlowMotion75x_2	EntertainmentPlayStatusBitfieldConst = 21
	SlowMotion5x_2	EntertainmentPlayStatusBitfieldConst = 22
	SlowMotion25x_2	EntertainmentPlayStatusBitfieldConst = 23
	SlowMotion125x_2	EntertainmentPlayStatusBitfieldConst = 24
	SourceRenaming	EntertainmentPlayStatusBitfieldConst = 25
)

func (e EntertainmentPlayStatusBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentPlayStatusBitfieldConst) String() string {
	switch e {
		case 0:
			return "Play"
		case 1:
			return "Pause"
		case 2:
			return "Stop"
		case 3:
			return "FF 1x"
		case 4:
			return "FF 2x"
		case 5:
			return "FF 3x"
		case 6:
			return "FF 4x"
		case 7:
			return "RW 1x"
		case 8:
			return "RW 2x"
		case 9:
			return "RW 3x"
		case 10:
			return "RW 4x"
		case 11:
			return "Skip ahead"
		case 12:
			return "Skip back"
		case 13:
			return "Jog ahead"
		case 14:
			return "Jog back"
		case 15:
			return "Seek up"
		case 16:
			return "Seek down"
		case 17:
			return "Scan up"
		case 18:
			return "Scan down"
		case 19:
			return "Tune up"
		case 20:
			return "Tune down"
		case 21:
			return "Slow motion .75x"
		case 22:
			return "Slow motion .5x"
		case 23:
			return "Slow motion .25x"
		case 24:
			return "Slow motion .125x"
		case 25:
			return "Source renaming"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentPlayStatusBitfieldConst", int(e))
	}
}

type EntertainmentGroupBitfieldConst uint16
const (
	File_4	EntertainmentGroupBitfieldConst = 0
	PlaylistName_3	EntertainmentGroupBitfieldConst = 1
	GenreName_3	EntertainmentGroupBitfieldConst = 2
	AlbumName_3	EntertainmentGroupBitfieldConst = 3
	ArtistName_3	EntertainmentGroupBitfieldConst = 4
	TrackName_3	EntertainmentGroupBitfieldConst = 5
	StationName_3	EntertainmentGroupBitfieldConst = 6
	StationNumber_3	EntertainmentGroupBitfieldConst = 7
	FavouriteNumber_3	EntertainmentGroupBitfieldConst = 8
	PlayQueue_4	EntertainmentGroupBitfieldConst = 9
	ContentInfo_3	EntertainmentGroupBitfieldConst = 10
)

func (e EntertainmentGroupBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentGroupBitfieldConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentGroupBitfieldConst", int(e))
	}
}

type ThrusterControlEventsConst uint16
const (
	AnotherDeviceControllingThruster	ThrusterControlEventsConst = 0
	BoatSpeedTooFastToSafelyUseThruster	ThrusterControlEventsConst = 1
)

func (e ThrusterControlEventsConst) GoString() string {return e.String() }
func (e ThrusterControlEventsConst) String() string {
	switch e {
		case 0:
			return "Another device controlling thruster"
		case 1:
			return "Boat speed too fast to safely use thruster"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterControlEventsConst", int(e))
	}
}

type ThrusterMotorEventsConst uint16
const (
	MotorOverTemperatureCutout	ThrusterMotorEventsConst = 0
	MotorOverCurrentCutout	ThrusterMotorEventsConst = 1
	LowOilLevelWarning	ThrusterMotorEventsConst = 2
	OilOverTemperatureWarning	ThrusterMotorEventsConst = 3
	ControllerUnderVoltageCutout	ThrusterMotorEventsConst = 4
	ManufacturerDefined	ThrusterMotorEventsConst = 5
)

func (e ThrusterMotorEventsConst) GoString() string {return e.String() }
func (e ThrusterMotorEventsConst) String() string {
	switch e {
		case 0:
			return "Motor over temperature cutout"
		case 1:
			return "Motor over current cutout"
		case 2:
			return "Low oil level warning"
		case 3:
			return "Oil over temperature warning"
		case 4:
			return "Controller under voltage cutout"
		case 5:
			return "Manufacturer defined"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterMotorEventsConst", int(e))
	}
}

type WindlassControlConst uint16
const (
	AnotherDeviceControllingWindlass	WindlassControlConst = 0
)

func (e WindlassControlConst) GoString() string {return e.String() }
func (e WindlassControlConst) String() string {
	switch e {
		case 0:
			return "Another device controlling windlass"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassControlConst", int(e))
	}
}

type WindlassOperationConst uint16
const (
	SystemError	WindlassOperationConst = 0
	SensorError	WindlassOperationConst = 1
	NoWindlassMotionDetected	WindlassOperationConst = 2
	RetrievalDockingDistanceReached	WindlassOperationConst = 3
	EndOfRodeReached	WindlassOperationConst = 4
)

func (e WindlassOperationConst) GoString() string {return e.String() }
func (e WindlassOperationConst) String() string {
	switch e {
		case 0:
			return "System error"
		case 1:
			return "Sensor error"
		case 2:
			return "No windlass motion detected"
		case 3:
			return "Retrieval docking distance reached"
		case 4:
			return "End of rode reached"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassOperationConst", int(e))
	}
}

type WindlassMonitoringConst uint16
const (
	ControllerUnderVoltageCutOut	WindlassMonitoringConst = 0
	ControllerOverCurrentCutOut	WindlassMonitoringConst = 1
	ControllerOverTemperatureCutOut	WindlassMonitoringConst = 2
	ManufacturerDefined_2	WindlassMonitoringConst = 3
)

func (e WindlassMonitoringConst) GoString() string {return e.String() }
func (e WindlassMonitoringConst) String() string {
	switch e {
		case 0:
			return "Controller under voltage cut-out"
		case 1:
			return "Controller over current cut-out"
		case 2:
			return "Controller over temperature cut-out"
		case 3:
			return "Manufacturer defined"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassMonitoringConst", int(e))
	}
}

type SimnetApModeBitfieldConst uint16
const (
	Standby_5	SimnetApModeBitfieldConst = 3
	Heading_2	SimnetApModeBitfieldConst = 4
	Nav_2	SimnetApModeBitfieldConst = 6
	NoDrift_2	SimnetApModeBitfieldConst = 8
	Wind_4	SimnetApModeBitfieldConst = 10
)

func (e SimnetApModeBitfieldConst) GoString() string {return e.String() }
func (e SimnetApModeBitfieldConst) String() string {
	switch e {
		case 3:
			return "Standby"
		case 4:
			return "Heading"
		case 6:
			return "Nav"
		case 8:
			return "No Drift"
		case 10:
			return "Wind"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApModeBitfieldConst", int(e))
	}
}

type SimnetAlertBitfieldConst uint16
const (
	NoGPSFix	SimnetAlertBitfieldConst = 0
	NoActiveAutopilotControlUnit	SimnetAlertBitfieldConst = 2
	NoAutopilotComputer	SimnetAlertBitfieldConst = 4
	APClutchOverload	SimnetAlertBitfieldConst = 6
	APClutchDisengaged	SimnetAlertBitfieldConst = 8
	RudderControllerFault	SimnetAlertBitfieldConst = 10
	NoRudderResponse	SimnetAlertBitfieldConst = 12
	RudderDriveOverload	SimnetAlertBitfieldConst = 14
	HighDriveSupply	SimnetAlertBitfieldConst = 16
	LowDriveSupply	SimnetAlertBitfieldConst = 18
	MemoryFail	SimnetAlertBitfieldConst = 20
	APPositionDataMissing	SimnetAlertBitfieldConst = 22
	APSpeedDataMissing	SimnetAlertBitfieldConst = 24
	APDepthDataMissing	SimnetAlertBitfieldConst = 26
	APHeadingDataMissing	SimnetAlertBitfieldConst = 28
	APNavDataMissing	SimnetAlertBitfieldConst = 30
	APRudderDataMissing	SimnetAlertBitfieldConst = 32
	APWindDataMissing	SimnetAlertBitfieldConst = 34
	APOffCourse	SimnetAlertBitfieldConst = 36
	HighDriveTemperature	SimnetAlertBitfieldConst = 38
	DriveInhibit	SimnetAlertBitfieldConst = 40
	RudderLimit	SimnetAlertBitfieldConst = 42
	DriveComputerMissing	SimnetAlertBitfieldConst = 44
	DriveReadyMissing	SimnetAlertBitfieldConst = 46
	EVCComError	SimnetAlertBitfieldConst = 48
	EVCOverride	SimnetAlertBitfieldConst = 50
	LowCANBusVoltage	SimnetAlertBitfieldConst = 52
	CANBusSupplyOverload	SimnetAlertBitfieldConst = 54
	WindSensorBatteryLow	SimnetAlertBitfieldConst = 56
)

func (e SimnetAlertBitfieldConst) GoString() string {return e.String() }
func (e SimnetAlertBitfieldConst) String() string {
	switch e {
		case 0:
			return "No GPS fix"
		case 2:
			return "No active autopilot control unit"
		case 4:
			return "No autopilot computer"
		case 6:
			return "AP clutch overload"
		case 8:
			return "AP clutch disengaged"
		case 10:
			return "Rudder controller fault"
		case 12:
			return "No rudder response"
		case 14:
			return "Rudder drive overload"
		case 16:
			return "High drive supply"
		case 18:
			return "Low drive supply"
		case 20:
			return "Memory fail"
		case 22:
			return "AP position data missing"
		case 24:
			return "AP speed data missing"
		case 26:
			return "AP depth data missing"
		case 28:
			return "AP heading data missing"
		case 30:
			return "AP nav data missing"
		case 32:
			return "AP rudder data missing"
		case 34:
			return "AP wind data missing"
		case 36:
			return "AP off course"
		case 38:
			return "High drive temperature"
		case 40:
			return "Drive inhibit"
		case 42:
			return "Rudder limit"
		case 44:
			return "Drive computer missing"
		case 46:
			return "Drive ready missing"
		case 48:
			return "EVC com error"
		case 50:
			return "EVC override"
		case 52:
			return "Low CAN bus voltage"
		case 54:
			return "CAN bus supply overload"
		case 56:
			return "Wind sensor battery low"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetAlertBitfieldConst", int(e))
	}
}

type EntertainmentRepeatBitfieldConst uint16
const (
	Song	EntertainmentRepeatBitfieldConst = 0
	PlayQueue_5	EntertainmentRepeatBitfieldConst = 1
)

func (e EntertainmentRepeatBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentRepeatBitfieldConst) String() string {
	switch e {
		case 0:
			return "Song"
		case 1:
			return "Play queue"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRepeatBitfieldConst", int(e))
	}
}

type EntertainmentShuffleBitfieldConst uint16
const (
	PlayQueue_6	EntertainmentShuffleBitfieldConst = 0
	All_3	EntertainmentShuffleBitfieldConst = 1
)

func (e EntertainmentShuffleBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentShuffleBitfieldConst) String() string {
	switch e {
		case 0:
			return "Play queue"
		case 1:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentShuffleBitfieldConst", int(e))
	}
}

var unseenList = []PgnInfo{
	{
		PGN: 127490,
		Description: "Electric Drive Status, Dynamic",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 127491,
		Description: "Electric Energy Storage Status, Dynamic",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 127494,
		Description: "Electric Drive Information",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 127495,
		Description: "Electric Energy Storage Information",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 127510,
		Description: "Charger Configuration Status",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 128001,
		Description: "Vessel Acceleration",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128002,
		Description: "Electric Drive Status, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128003,
		Description: "Electric Energy Storage Status, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128520,
		Description: "Tracked Target Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 128538,
		Description: "Elevator Car Status",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 128768,
		Description: "Elevator Motor Control",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128769,
		Description: "Elevator Deck Push Button",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128780,
		Description: "Linear Actuator Control/Status",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129027,
		Description: "Position Delta, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129028,
		Description: "Altitude Delta, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129040,
		Description: "AIS Class B Extended Position Report",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129291,
		Description: "Set & Drift, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129301,
		Description: "Navigation - Route / Time to+from Mark",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129302,
		Description: "Bearing and Distance between two Marks",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129538,
		Description: "GNSS Control Status",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129542,
		Description: "GNSS Pseudorange Noise Statistics",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129545,
		Description: "GNSS RAIM Output",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129792,
		Description: "AIS DGNSS Broadcast Binary Message",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129798,
		Description: "AIS SAR Aircraft Position Report",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129804,
		Description: "AIS Assignment Mode Command",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129807,
		Description: "AIS Class B Group Assignment",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129808,
		Description: "DSC Distress Call Information",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129808,
		Description: "DSC Call Information",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130052,
		Description: "Loran-C TD Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130053,
		Description: "Loran-C Range Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130054,
		Description: "Loran-C Signal Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130060,
		Description: "Label",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130061,
		Description: "Channel Source Configuration",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130064,
		Description: "Route and WP Service - Database List",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130065,
		Description: "Route and WP Service - Route List",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130066,
		Description: "Route and WP Service - Route/WP-List Attributes",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130067,
		Description: "Route and WP Service - Route - WP Name & Position",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130068,
		Description: "Route and WP Service - Route - WP Name",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130069,
		Description: "Route and WP Service - XTE Limit & Navigation Method",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130070,
		Description: "Route and WP Service - WP Comment",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130071,
		Description: "Route and WP Service - Route Comment",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130072,
		Description: "Route and WP Service - Database Comment",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130073,
		Description: "Route and WP Service - Radius of Turn",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130074,
		Description: "Route and WP Service - WP List - WP Name & Position",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130321,
		Description: "Salinity Station Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130322,
		Description: "Current Station Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130323,
		Description: "Meteorological Station Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130324,
		Description: "Moored Buoy Station Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130330,
		Description: "Lighting System Settings",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130560,
		Description: "Payload Mass",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130561,
		Description: "Lighting Zone",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130562,
		Description: "Lighting Scene",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130563,
		Description: "Lighting Device",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130564,
		Description: "Lighting Device Enumeration",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130565,
		Description: "Lighting Color Sequence",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130566,
		Description: "Lighting Program",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130569,
		Description: "Current Status and File",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130570,
		Description: "Library Data File",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130571,
		Description: "Library Data Group",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130572,
		Description: "Library Data Search",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130573,
		Description: "Supported Source Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130574,
		Description: "Supported Zone Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130576,
		Description: "Small Craft Status",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130577,
		Description: "Direction Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130579,
		Description: "System Configuration",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130580,
		Description: "System Configuration (deprecated)",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130581,
		Description: "Zone Configuration (deprecated)",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130582,
		Description: "Zone Volume",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130583,
		Description: "Available Audio EQ presets",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130584,
		Description: "Available Bluetooth addresses",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130585,
		Description: "Bluetooth source status",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130586,
		Description: "Zone Configuration",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130816,
		Description: "SonicHub: Init #2",
		Fast: true,
		ManId: 275,
	},
	{
		PGN: 130816,
		Description: "SonicHub: AM Radio",
		Fast: true,
		ManId: 275,
	},
	{
		PGN: 130816,
		Description: "SonicHub: Init #3",
		Fast: true,
		ManId: 275,
	},
	{
		PGN: 130819,
		Description: "Simnet: Request Reprogram",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130820,
		Description: "Simnet: Reprogram Status",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130820,
		Description: "Fusion: Tone",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: Volume",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: Power State",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Channel",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Title",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Artist",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Genre",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130827,
		Description: "Lowrance: unknown",
		Fast: true,
		ManId: 140,
	},
	{
		PGN: 130828,
		Description: "Simnet: Set Serial Number",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130831,
		Description: "Suzuki: Engine and Storage Device Config",
		Fast: true,
		ManId: 586,
	},
	{
		PGN: 130832,
		Description: "Simnet: Fuel Used - High Resolution",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130834,
		Description: "Simnet: Engine and Tank Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130835,
		Description: "Simnet: Set Engine and Tank Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130837,
		Description: "Simnet: Fuel Flow Turbine Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130838,
		Description: "Simnet: Fluid Level Warning",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130839,
		Description: "Simnet: Pressure Sensor Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130840,
		Description: "Simnet: Data User Group Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130842,
		Description: "Simnet: AIS Class B static data (msg 24 Part A)",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130843,
		Description: "Simnet: Sonar Status, Frequency and DSP Voltage",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130847,
		Description: "SeaTalk: Node Statistics",
		Fast: true,
		ManId: 1851,
	},
	{
		PGN: 130880,
		Description: "Airmar: Additional Weather Data",
		Fast: true,
		ManId: 135,
	},
	{
		PGN: 130881,
		Description: "Airmar: Heater Control",
		Fast: true,
		ManId: 135,
	},
	{
		PGN: 130944,
		Description: "Airmar: POST",
		Fast: true,
		ManId: 135,
	},
}

    // Define the partial type and its methods
    type NmeaRequestGroupFunctionPartial struct {
        Info MessageInfo
        FunctionCode GroupFunctionConst
        Pgn *uint32
        TransmissionInterval *float32
        TransmissionIntervalOffset *float32
        NumberOfParameters *uint8
        // Raw data for variable length fields in proprietary group function messages
        RawData []uint8
    }

    // Decode function that returns error for Partial types
    func DecodeNmeaRequestGroupFunctionPartial(Info MessageInfo, stream *DataStream) (any, error) {
        return nil, fmt.Errorf("cannot decode NmeaRequestGroupFunctionPartial directly - use NmeaRequestGroupFunction for decoding")
    }

    // Encode returns an error for partial variants
    func (p NmeaRequestGroupFunctionPartial) Encode(stream *DataStream) (*MessageInfo, error) {
        return nil, fmt.Errorf("cannot encode partial variant of NmeaRequestGroupFunction - use NmeaRequestGroupFunction for encoding")
    }

    // Define the partial type and its methods
    type NmeaCommandGroupFunctionPartial struct {
        Info MessageInfo
        FunctionCode GroupFunctionConst
        Pgn *uint32
        Priority PriorityConst
        NumberOfParameters *uint8
        // Raw data for variable length fields in proprietary group function messages
        RawData []uint8
    }

    // Decode function that returns error for Partial types
    func DecodeNmeaCommandGroupFunctionPartial(Info MessageInfo, stream *DataStream) (any, error) {
        return nil, fmt.Errorf("cannot decode NmeaCommandGroupFunctionPartial directly - use NmeaCommandGroupFunction for decoding")
    }

    // Encode returns an error for partial variants
    func (p NmeaCommandGroupFunctionPartial) Encode(stream *DataStream) (*MessageInfo, error) {
        return nil, fmt.Errorf("cannot encode partial variant of NmeaCommandGroupFunction - use NmeaCommandGroupFunction for encoding")
    }

    // Define the partial type and its methods
    type NmeaAcknowledgeGroupFunctionPartial struct {
        Info MessageInfo
        FunctionCode GroupFunctionConst
        Pgn *uint32
        PgnErrorCode PgnErrorCodeConst
        TransmissionIntervalPriorityErrorCode TransmissionIntervalConst
        NumberOfParameters *uint8
        // Raw data for variable length fields in proprietary group function messages
        RawData []uint8
    }

    // Decode function that returns error for Partial types
    func DecodeNmeaAcknowledgeGroupFunctionPartial(Info MessageInfo, stream *DataStream) (any, error) {
        return nil, fmt.Errorf("cannot decode NmeaAcknowledgeGroupFunctionPartial directly - use NmeaAcknowledgeGroupFunction for decoding")
    }

    // Encode returns an error for partial variants
    func (p NmeaAcknowledgeGroupFunctionPartial) Encode(stream *DataStream) (*MessageInfo, error) {
        return nil, fmt.Errorf("cannot encode partial variant of NmeaAcknowledgeGroupFunction - use NmeaAcknowledgeGroupFunction for encoding")
    }

    // Define the partial type and its methods
    type NmeaReadFieldsReplyGroupFunctionPartial struct {
        Info MessageInfo
        FunctionCode GroupFunctionConst
        Pgn *uint32
        ManufacturerCode ManufacturerCodeConst
        IndustryCode IndustryCodeConst
        UniqueId *uint8
        NumberOfSelectionPairs *uint8
        NumberOfParameters *uint8
        // Raw data for variable length fields in proprietary group function messages
        RawData []uint8
    }

    // Decode function that returns error for Partial types
    func DecodeNmeaReadFieldsReplyGroupFunctionPartial(Info MessageInfo, stream *DataStream) (any, error) {
        return nil, fmt.Errorf("cannot decode NmeaReadFieldsReplyGroupFunctionPartial directly - use NmeaReadFieldsReplyGroupFunction for decoding")
    }

    // Encode returns an error for partial variants
    func (p NmeaReadFieldsReplyGroupFunctionPartial) Encode(stream *DataStream) (*MessageInfo, error) {
        return nil, fmt.Errorf("cannot encode partial variant of NmeaReadFieldsReplyGroupFunction - use NmeaReadFieldsReplyGroupFunction for encoding")
    }

    // Define the partial type and its methods
    type NmeaWriteFieldsGroupFunctionPartial struct {
        Info MessageInfo
        FunctionCode GroupFunctionConst
        Pgn *uint32
        ManufacturerCode ManufacturerCodeConst
        IndustryCode IndustryCodeConst
        UniqueId *uint8
        NumberOfSelectionPairs *uint8
        NumberOfParameters *uint8
        // Raw data for variable length fields in proprietary group function messages
        RawData []uint8
    }

    // Decode function that returns error for Partial types
    func DecodeNmeaWriteFieldsGroupFunctionPartial(Info MessageInfo, stream *DataStream) (any, error) {
        return nil, fmt.Errorf("cannot decode NmeaWriteFieldsGroupFunctionPartial directly - use NmeaWriteFieldsGroupFunction for decoding")
    }

    // Encode returns an error for partial variants
    func (p NmeaWriteFieldsGroupFunctionPartial) Encode(stream *DataStream) (*MessageInfo, error) {
        return nil, fmt.Errorf("cannot encode partial variant of NmeaWriteFieldsGroupFunction - use NmeaWriteFieldsGroupFunction for encoding")
    }

    // Define the partial type and its methods
    type NmeaWriteFieldsReplyGroupFunctionPartial struct {
        Info MessageInfo
        FunctionCode GroupFunctionConst
        Pgn *uint32
        ManufacturerCode ManufacturerCodeConst
        IndustryCode IndustryCodeConst
        UniqueId *uint8
        NumberOfSelectionPairs *uint8
        NumberOfParameters *uint8
        // Raw data for variable length fields in proprietary group function messages
        RawData []uint8
    }

    // Decode function that returns error for Partial types
    func DecodeNmeaWriteFieldsReplyGroupFunctionPartial(Info MessageInfo, stream *DataStream) (any, error) {
        return nil, fmt.Errorf("cannot decode NmeaWriteFieldsReplyGroupFunctionPartial directly - use NmeaWriteFieldsReplyGroupFunction for decoding")
    }

    // Encode returns an error for partial variants
    func (p NmeaWriteFieldsReplyGroupFunctionPartial) Encode(stream *DataStream) (*MessageInfo, error) {
        return nil, fmt.Errorf("cannot encode partial variant of NmeaWriteFieldsReplyGroupFunction - use NmeaWriteFieldsReplyGroupFunction for encoding")
    }

var PgnList = pgnList
var pgnList = []PgnInfo{
    {
        Id: "IsoAcknowledgement",
        PGN: 59392,
        Description: "ISO Acknowledgement",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoAcknowledgement,
        Instance: &IsoAcknowledgement {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Control",
            GolangType:"IsoControlConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "GroupFunction",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 24,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "IsoRequest",
        PGN: 59904,
        Description: "ISO Request",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoRequest,
        Instance: &IsoRequest {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 24,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        },
    },
    {
        Id: "IsoTransportProtocolDataTransfer",
        PGN: 60160,
        Description: "ISO Transport Protocol, Data Transfer",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoTransportProtocolDataTransfer,
        Instance: &IsoTransportProtocolDataTransfer {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 56,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "Data",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        },
    },
    {
        Id: "IsoTransportProtocolConnectionManagementRequestToSend",
        PGN: 60416,
        Description: "ISO Transport Protocol, Connection Management - Request To Send",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoTransportProtocolConnectionManagementRequestToSend,
        Instance: &IsoTransportProtocolConnectionManagementRequestToSend {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 16,
            Id: "GroupFunctionCode",
            GolangType:"IsoCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 255,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "MessageSize",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Packets",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "PacketsReply",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "IsoTransportProtocolConnectionManagementClearToSend",
        PGN: 60416,
        Description: "ISO Transport Protocol, Connection Management - Clear To Send",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoTransportProtocolConnectionManagementClearToSend,
        Instance: &IsoTransportProtocolConnectionManagementClearToSend {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 17,
            Id: "GroupFunctionCode",
            GolangType:"IsoCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 255,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "MaxPackets",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NextSid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "IsoTransportProtocolConnectionManagementEndOfMessage",
        PGN: 60416,
        Description: "ISO Transport Protocol, Connection Management - End Of Message",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoTransportProtocolConnectionManagementEndOfMessage,
        Instance: &IsoTransportProtocolConnectionManagementEndOfMessage {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 19,
            Id: "GroupFunctionCode",
            GolangType:"IsoCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 255,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "TotalMessageSize",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "TotalNumberOfFramesReceived",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "IsoTransportProtocolConnectionManagementBroadcastAnnounce",
        PGN: 60416,
        Description: "ISO Transport Protocol, Connection Management - Broadcast Announce",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoTransportProtocolConnectionManagementBroadcastAnnounce,
        Instance: &IsoTransportProtocolConnectionManagementBroadcastAnnounce {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 32,
            Id: "GroupFunctionCode",
            GolangType:"IsoCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 255,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "MessageSize",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Packets",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "IsoTransportProtocolConnectionManagementAbort",
        PGN: 60416,
        Description: "ISO Transport Protocol, Connection Management - Abort",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoTransportProtocolConnectionManagementAbort,
        Instance: &IsoTransportProtocolConnectionManagementAbort {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 255,
            Id: "GroupFunctionCode",
            GolangType:"IsoCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 255,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "Reason",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 24,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "IsoAddressClaim",
        PGN: 60928,
        Description: "ISO Address Claim",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoAddressClaim,
        Instance: &IsoAddressClaim {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 21,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "UniqueNumber",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2.097149e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 11,
            BitOffset: 21,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DeviceInstanceLower",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 5,
            BitOffset: 35,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DeviceInstanceUpper",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "INDIRECT_LOOKUP",
            Resolution:1,
            Id: "DeviceFunction",
            GolangType:"DeviceFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 1,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "Spare",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 7,
            BitOffset: 49,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DeviceClass",
            GolangType:"DeviceClassConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 4,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SystemInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 3,
            BitOffset: 60,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "IndustryGroup",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 1,
            BitOffset: 63,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ArbitraryAddressCapable",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        },
    },
    {
        Id: "Bus1PhaseCBasicAcQuantities",
        PGN: 65001,
        Description: "Bus #1 Phase C Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeBus1PhaseCBasicAcQuantities,
        Instance: &Bus1PhaseCBasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "Bus1PhaseBBasicAcQuantities",
        PGN: 65002,
        Description: "Bus #1 Phase B Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeBus1PhaseBBasicAcQuantities,
        Instance: &Bus1PhaseBBasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "Bus1PhaseABasicAcQuantities",
        PGN: 65003,
        Description: "Bus #1 Phase A Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeBus1PhaseABasicAcQuantities,
        Instance: &Bus1PhaseABasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "UtilityPhaseCAcReactivePower",
        PGN: 65006,
        Description: "Utility Phase C AC Reactive Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseCAcReactivePower,
        Instance: &UtilityPhaseCAcReactivePower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReactivePower",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:6.10352e-05,
            Id: "PowerFactor",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.99981689453125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerFactorLagging",
            GolangType:"PowerFactorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 30,
            BitOffset: 34,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "UtilityPhaseCAcPower",
        PGN: 65007,
        Description: "Utility Phase C AC Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseCAcPower,
        Instance: &UtilityPhaseCAcPower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RealPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ApparentPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 2,
            },
        },
    },
    {
        Id: "UtilityPhaseCBasicAcQuantities",
        PGN: 65008,
        Description: "Utility Phase C Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseCBasicAcQuantities,
        Instance: &UtilityPhaseCBasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcRmsCurrent",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "UtilityPhaseBAcReactivePower",
        PGN: 65009,
        Description: "Utility Phase B AC Reactive Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseBAcReactivePower,
        Instance: &UtilityPhaseBAcReactivePower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReactivePower",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:6.10352e-05,
            Id: "PowerFactor",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.99981689453125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerFactorLagging",
            GolangType:"PowerFactorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 30,
            BitOffset: 34,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "UtilityPhaseBAcPower",
        PGN: 65010,
        Description: "Utility Phase B AC Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseBAcPower,
        Instance: &UtilityPhaseBAcPower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RealPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ApparentPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 2,
            },
        },
    },
    {
        Id: "UtilityPhaseBBasicAcQuantities",
        PGN: 65011,
        Description: "Utility Phase B Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseBBasicAcQuantities,
        Instance: &UtilityPhaseBBasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcRmsCurrent",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "UtilityPhaseAAcReactivePower",
        PGN: 65012,
        Description: "Utility Phase A AC Reactive Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseAAcReactivePower,
        Instance: &UtilityPhaseAAcReactivePower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReactivePower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:6.10352e-05,
            Id: "PowerFactor",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.99981689453125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerFactorLagging",
            GolangType:"PowerFactorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 14,
            BitOffset: 50,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "UtilityPhaseAAcPower",
        PGN: 65013,
        Description: "Utility Phase A AC Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseAAcPower,
        Instance: &UtilityPhaseAAcPower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RealPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ApparentPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 2,
            },
        },
    },
    {
        Id: "UtilityPhaseABasicAcQuantities",
        PGN: 65014,
        Description: "Utility Phase A Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityPhaseABasicAcQuantities,
        Instance: &UtilityPhaseABasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcRmsCurrent",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "UtilityTotalAcReactivePower",
        PGN: 65015,
        Description: "Utility Total AC Reactive Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityTotalAcReactivePower,
        Instance: &UtilityTotalAcReactivePower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReactivePower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:6.10352e-05,
            Id: "PowerFactor",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.99981689453125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerFactorLagging",
            GolangType:"PowerFactorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 14,
            BitOffset: 50,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "UtilityTotalAcPower",
        PGN: 65016,
        Description: "Utility Total AC Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityTotalAcPower,
        Instance: &UtilityTotalAcPower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RealPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ApparentPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 2,
            },
        },
    },
    {
        Id: "UtilityAverageBasicAcQuantities",
        PGN: 65017,
        Description: "Utility Average Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeUtilityAverageBasicAcQuantities,
        Instance: &UtilityAverageBasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcRmsCurrent",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GeneratorPhaseCAcReactivePower",
        PGN: 65019,
        Description: "Generator Phase C AC Reactive Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseCAcReactivePower,
        Instance: &GeneratorPhaseCAcReactivePower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReactivePower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:6.10352e-05,
            Id: "PowerFactor",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.99981689453125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerFactorLagging",
            GolangType:"PowerFactorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 14,
            BitOffset: 50,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GeneratorPhaseCAcPower",
        PGN: 65020,
        Description: "Generator Phase C AC Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseCAcPower,
        Instance: &GeneratorPhaseCAcPower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RealPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ApparentPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 2,
            },
        },
    },
    {
        Id: "GeneratorPhaseCBasicAcQuantities",
        PGN: 65021,
        Description: "Generator Phase C Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseCBasicAcQuantities,
        Instance: &GeneratorPhaseCBasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcRmsCurrent",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GeneratorPhaseBAcReactivePower",
        PGN: 65022,
        Description: "Generator Phase B AC Reactive Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseBAcReactivePower,
        Instance: &GeneratorPhaseBAcReactivePower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReactivePower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:6.10352e-05,
            Id: "PowerFactor",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.99981689453125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerFactorLagging",
            GolangType:"PowerFactorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 14,
            BitOffset: 50,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GeneratorPhaseBAcPower",
        PGN: 65023,
        Description: "Generator Phase B AC Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseBAcPower,
        Instance: &GeneratorPhaseBAcPower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RealPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ApparentPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 2,
            },
        },
    },
    {
        Id: "GeneratorPhaseBBasicAcQuantities",
        PGN: 65024,
        Description: "Generator Phase B Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseBBasicAcQuantities,
        Instance: &GeneratorPhaseBBasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcRmsCurrent",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GeneratorPhaseAAcReactivePower",
        PGN: 65025,
        Description: "Generator Phase A AC Reactive Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseAAcReactivePower,
        Instance: &GeneratorPhaseAAcReactivePower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReactivePower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:6.10352e-05,
            Id: "PowerFactor",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.99981689453125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerFactorLagging",
            GolangType:"PowerFactorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 14,
            BitOffset: 50,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GeneratorPhaseAAcPower",
        PGN: 65026,
        Description: "Generator Phase A AC Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseAAcPower,
        Instance: &GeneratorPhaseAAcPower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RealPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ApparentPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 2,
            },
        },
    },
    {
        Id: "GeneratorPhaseABasicAcQuantities",
        PGN: 65027,
        Description: "Generator Phase A Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorPhaseABasicAcQuantities,
        Instance: &GeneratorPhaseABasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcRmsCurrent",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GeneratorTotalAcReactivePower",
        PGN: 65028,
        Description: "Generator Total AC Reactive Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorTotalAcReactivePower,
        Instance: &GeneratorTotalAcReactivePower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReactivePower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:6.10352e-05,
            Id: "PowerFactor",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.99981689453125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerFactorLagging",
            GolangType:"PowerFactorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 14,
            BitOffset: 50,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GeneratorTotalAcPower",
        PGN: 65029,
        Description: "Generator Total AC Power",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorTotalAcPower,
        Instance: &GeneratorTotalAcPower {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RealPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ApparentPower",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2e+09,
            RangeMax: 2.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1, 
            Offset: -2000000000,
            Order: 2,
            },
        },
    },
    {
        Id: "GeneratorAverageBasicAcQuantities",
        PGN: 65030,
        Description: "Generator Average Basic AC Quantities",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGeneratorAverageBasicAcQuantities,
        Instance: &GeneratorAverageBasicAcQuantities {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineLineAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LineNeutralAcRmsVoltage",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0078125,
            Id: "AcFrequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 511.9765625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcRmsCurrent",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "IsoCommandedAddress",
        PGN: 65240,
        Description: "ISO Commanded Address",
        Fast: false,
        ManId: 0,
        Decoder: DecodeIsoCommandedAddress,
        Instance: &IsoCommandedAddress {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 21,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "UniqueNumber",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 11,
            BitOffset: 21,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DeviceInstanceLower",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 5,
            BitOffset: 35,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DeviceInstanceUpper",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "INDIRECT_LOOKUP",
            Resolution:1,
            Id: "DeviceFunction",
            GolangType:"DeviceFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 1,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 7,
            BitOffset: 49,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DeviceClass",
            GolangType:"DeviceClassConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 4,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SystemInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 3,
            BitOffset: 60,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 1,
            BitOffset: 63,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved10",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 8,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NewSourceAddress",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        },
    },
    {
        Id: "MaretronProprietaryDcBreakerCurrent",
        PGN: 65284,
        Description: "Maretron: Proprietary DC Breaker Current",
        Fast: false,
        ManId: 137,
        Decoder: DecodeMaretronProprietaryDcBreakerCurrent,
        Instance: &MaretronProprietaryDcBreakerCurrent {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 137,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "BankInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "IndicatorNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "BreakerCurrent",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved7",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "AirmarBootStateAcknowledgment",
        PGN: 65285,
        Description: "Airmar: Boot State Acknowledgment",
        Fast: false,
        ManId: 135,
        Decoder: DecodeAirmarBootStateAcknowledgment,
        Instance: &AirmarBootStateAcknowledgment {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 3,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "BootState",
            GolangType:"BootStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 45,
            BitOffset: 19,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved5",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "LowranceTemperature",
        PGN: 65285,
        Description: "Lowrance: Temperature",
        Fast: false,
        ManId: 140,
        Decoder: DecodeLowranceTemperature,
        Instance: &LowranceTemperature {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 140,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TemperatureSource",
            GolangType:"TemperatureSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "ActualTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "AirmarBootStateRequest",
        PGN: 65286,
        Description: "Airmar: Boot State Request",
        Fast: false,
        ManId: 135,
        Decoder: DecodeAirmarBootStateRequest,
        Instance: &AirmarBootStateRequest {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 48,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved4",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "AirmarAccessLevel",
        PGN: 65287,
        Description: "Airmar: Access Level",
        Fast: false,
        ManId: 135,
        Decoder: DecodeAirmarAccessLevel,
        Instance: &AirmarAccessLevel {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "FormatCode",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 3,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AccessLevel",
            GolangType:"AccessLevelConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 5,
            BitOffset: 27,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AccessSeedKey",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "SimnetDeviceStatus",
        PGN: 65305,
        Description: "Simnet: Device Status",
        Fast: false,
        ManId: 1857,
        Decoder: DecodeSimnetDeviceStatus,
        Instance: &SimnetDeviceStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 1857,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Model",
            GolangType:"SimnetDeviceModelConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 2,
            Id: "Report",
            GolangType:"SimnetDeviceReportConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Status",
            GolangType:"SimnetApStatusConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "Spare7",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "SimnetDeviceStatusRequest",
        PGN: 65305,
        Description: "Simnet: Device Status Request",
        Fast: false,
        ManId: 1857,
        Decoder: DecodeSimnetDeviceStatusRequest,
        Instance: &SimnetDeviceStatusRequest {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 1857,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Model",
            GolangType:"SimnetDeviceModelConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 3,
            Id: "Report",
            GolangType:"SimnetDeviceReportConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "Spare6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "SimnetPilotMode",
        PGN: 65305,
        Description: "Simnet: Pilot Mode",
        Fast: false,
        ManId: 1857,
        Decoder: DecodeSimnetPilotMode,
        Instance: &SimnetPilotMode {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 1857,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Model",
            GolangType:"SimnetDeviceModelConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 10,
            Id: "Report",
            GolangType:"SimnetDeviceReportConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "BITLOOKUP",
            Resolution:1,
            Id: "Mode",
            GolangType:"SimnetApModeBitfieldConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65535,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "Spare7",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "SimnetDeviceModeRequest",
        PGN: 65305,
        Description: "Simnet: Device Mode Request",
        Fast: false,
        ManId: 1857,
        Decoder: DecodeSimnetDeviceModeRequest,
        Instance: &SimnetDeviceModeRequest {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 1857,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Model",
            GolangType:"SimnetDeviceModelConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 11,
            Id: "Report",
            GolangType:"SimnetDeviceReportConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "Spare6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "SeatalkPilotLockedHeading",
        PGN: 65360,
        Description: "Seatalk: Pilot Locked Heading",
        Fast: false,
        ManId: 1851,
        Decoder: DecodeSeatalkPilotLockedHeading,
        Instance: &SeatalkPilotLockedHeading {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 1851,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "Sid",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "TargetHeadingTrue",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "TargetHeadingMagnetic",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved7",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "SeatalkSilenceAlarm",
        PGN: 65361,
        Description: "Seatalk: Silence Alarm",
        Fast: false,
        ManId: 1851,
        Decoder: DecodeSeatalkSilenceAlarm,
        Instance: &SeatalkSilenceAlarm {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 1851,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlarmId",
            GolangType:"SeatalkAlarmIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlarmGroup",
            GolangType:"SeatalkAlarmGroupConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "AirmarSpeedPulseCount",
        PGN: 65409,
        Description: "Airmar: Speed Pulse Count",
        Fast: false,
        ManId: 135,
        Decoder: DecodeAirmarSpeedPulseCount,
        Instance: &AirmarSpeedPulseCount {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.001,
            Id: "DurationOfInterval",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65.533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfPulsesReceived",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved7",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "NmeaRequestGroupFunction",
        PGN: 126208,
        Description: "NMEA - Request group function",
        Fast: true,
        ManId: 0,
        Decoder: DecodeNmeaRequestGroupFunction,
        Instance: &NmeaRequestGroupFunction {},
        Repeating1CountField: 5,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 0,
            Id: "FunctionCode",
            GolangType:"GroupFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 24,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.001,
            Id: "TransmissionInterval",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293000001e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.01,
            Id: "TransmissionIntervalOffset",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfParameters",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "NmeaCommandGroupFunction",
        PGN: 126208,
        Description: "NMEA - Command group function",
        Fast: true,
        ManId: 0,
        Decoder: DecodeNmeaCommandGroupFunction,
        Instance: &NmeaCommandGroupFunction {},
        Repeating1CountField: 5,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 1,
            Id: "FunctionCode",
            GolangType:"GroupFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 24,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 4,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Priority",
            GolangType:"PriorityConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 4,
            BitOffset: 36,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfParameters",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "NmeaAcknowledgeGroupFunction",
        PGN: 126208,
        Description: "NMEA - Acknowledge group function",
        Fast: true,
        ManId: 0,
        Decoder: DecodeNmeaAcknowledgeGroupFunction,
        Instance: &NmeaAcknowledgeGroupFunction {},
        Repeating1CountField: 5,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 2,
            Id: "FunctionCode",
            GolangType:"GroupFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 24,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 4,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PgnErrorCode",
            GolangType:"PgnErrorCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 4,
            BitOffset: 36,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TransmissionIntervalPriorityErrorCode",
            GolangType:"TransmissionIntervalConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfParameters",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "NmeaReadFieldsReplyGroupFunction",
        PGN: 126208,
        Description: "NMEA - Read Fields reply group function",
        Fast: true,
        ManId: 0,
        Decoder: DecodeNmeaReadFieldsReplyGroupFunction,
        Instance: &NmeaReadFieldsReplyGroupFunction {},
        Repeating1CountField: 7,
        Repeating2CountField: 8,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "FunctionCode",
            GolangType:"GroupFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 24,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 11,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 3,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "UniqueId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfSelectionPairs",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfParameters",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "NmeaWriteFieldsGroupFunction",
        PGN: 126208,
        Description: "NMEA - Write Fields group function",
        Fast: true,
        ManId: 0,
        Decoder: DecodeNmeaWriteFieldsGroupFunction,
        Instance: &NmeaWriteFieldsGroupFunction {},
        Repeating1CountField: 7,
        Repeating2CountField: 8,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 5,
            Id: "FunctionCode",
            GolangType:"GroupFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 24,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 11,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 3,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "UniqueId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfSelectionPairs",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfParameters",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "NmeaWriteFieldsReplyGroupFunction",
        PGN: 126208,
        Description: "NMEA - Write Fields reply group function",
        Fast: true,
        ManId: 0,
        Decoder: DecodeNmeaWriteFieldsReplyGroupFunction,
        Instance: &NmeaWriteFieldsReplyGroupFunction {},
        Repeating1CountField: 7,
        Repeating2CountField: 8,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 6,
            Id: "FunctionCode",
            GolangType:"GroupFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 24,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Pgn",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 11,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 3,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "UniqueId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfSelectionPairs",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfParameters",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "PgnListTransmitAndReceive",
        PGN: 126464,
        Description: "PGN List (Transmit and Receive)",
        Fast: true,
        ManId: 0,
        Decoder: DecodePgnListTransmitAndReceive,
        Instance: &PgnListTransmitAndReceive {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "FunctionCode",
            GolangType:"PgnListFunctionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        },
    },
    {
        Id: "AirmarAttitudeOffset",
        PGN: 126720,
        Description: "Airmar: Attitude Offset",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarAttitudeOffset,
        Instance: &AirmarAttitudeOffset {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 32,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "AzimuthOffset",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "PitchOffset",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "RollOffset",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "AirmarSimulateMode",
        PGN: 126720,
        Description: "Airmar: Simulate Mode",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarSimulateMode,
        Instance: &AirmarSimulateMode {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 35,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SimulateMode",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 22,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "AirmarCalibrateDepth",
        PGN: 126720,
        Description: "Airmar: Calibrate Depth",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarCalibrateDepth,
        Instance: &AirmarCalibrateDepth {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 40,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "SpeedOfSoundMode",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "AirmarCalibrateSpeed",
        PGN: 126720,
        Description: "Airmar: Calibrate Speed",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarCalibrateSpeed,
        Instance: &AirmarCalibrateSpeed {},
        Repeating1CountField: 5,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 41,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfPairsOfDataPoints",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "AirmarCalibrateTemperature",
        PGN: 126720,
        Description: "Airmar: Calibrate Temperature",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarCalibrateTemperature,
        Instance: &AirmarCalibrateTemperature {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 42,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TemperatureInstance",
            GolangType:"AirmarTemperatureInstanceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 6,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "TemperatureOffset",
            GolangType:"*units.Temperature",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "AirmarSpeedFilterNone",
        PGN: 126720,
        Description: "Airmar: Speed Filter None",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarSpeedFilterNone,
        Instance: &AirmarSpeedFilterNone {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 43,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 4,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Match: 0,
            Id: "FilterType",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 4,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.01,
            Id: "SampleInterval",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "AirmarSpeedFilterIir",
        PGN: 126720,
        Description: "Airmar: Speed Filter IIR",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarSpeedFilterIir,
        Instance: &AirmarSpeedFilterIir {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 43,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 4,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Match: 1,
            Id: "FilterType",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 4,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.01,
            Id: "SampleInterval",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.01,
            Id: "FilterDuration",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "AirmarTemperatureFilterNone",
        PGN: 126720,
        Description: "Airmar: Temperature Filter None",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarTemperatureFilterNone,
        Instance: &AirmarTemperatureFilterNone {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 44,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 4,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Match: 0,
            Id: "FilterType",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 4,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.01,
            Id: "SampleInterval",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "AirmarTemperatureFilterIir",
        PGN: 126720,
        Description: "Airmar: Temperature Filter IIR",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarTemperatureFilterIir,
        Instance: &AirmarTemperatureFilterIir {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 44,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 4,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Match: 1,
            Id: "FilterType",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 4,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.01,
            Id: "SampleInterval",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.01,
            Id: "FilterDuration",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "AirmarNmea2000Options",
        PGN: 126720,
        Description: "Airmar: NMEA 2000 options",
        Fast: true,
        ManId: 135,
        Decoder: DecodeAirmarNmea2000Options,
        Instance: &AirmarNmea2000Options {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 135,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 46,
            Id: "ProprietaryId",
            GolangType:"AirmarCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TransmissionInterval",
            GolangType:"AirmarTransmissionIntervalConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 22,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "MaretronSlaveResponse",
        PGN: 126720,
        Description: "Maretron: Slave Response",
        Fast: true,
        ManId: 137,
        Decoder: DecodeMaretronSlaveResponse,
        Instance: &MaretronSlaveResponse {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 137,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ProductCode",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SoftwareCode",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Command",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Status",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "Alert",
        PGN: 126983,
        Description: "Alert",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAlert,
        Instance: &Alert {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 4,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlertType",
            GolangType:"AlertTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 4,
            BitOffset: 4,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlertCategory",
            GolangType:"AlertCategoryConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertSystem",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertSubSystem",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertId",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 64,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceNetworkIdName",
            GolangType:"*uint64",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.8446744073709552e+19,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceIndexSource",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 8,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertOccurrenceNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 1,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TemporarySilenceStatus",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 1,
            BitOffset: 129,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AcknowledgeStatus",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 1,
            BitOffset: 130,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "EscalationStatus",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 1,
            BitOffset: 131,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TemporarySilenceSupport",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 1,
            BitOffset: 132,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AcknowledgeSupport",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 1,
            BitOffset: 133,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "EscalationSupport",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 2,
            BitOffset: 134,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 64,
            BitOffset: 136,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcknowledgeSourceNetworkIdName",
            GolangType:"*uint64",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.8446744073709552e+19,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 4,
            BitOffset: 200,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TriggerCondition",
            GolangType:"AlertTriggerConditionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        19: { 
            BitLength: 4,
            BitOffset: 204,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ThresholdStatus",
            GolangType:"AlertThresholdStatusConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 19,
            },
        20: { 
            BitLength: 8,
            BitOffset: 208,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertPriority",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 20,
            },
        21: { 
            BitLength: 8,
            BitOffset: 216,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlertState",
            GolangType:"AlertStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 21,
            },
        },
    },
    {
        Id: "AlertResponse",
        PGN: 126984,
        Description: "Alert Response",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAlertResponse,
        Instance: &AlertResponse {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 4,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlertType",
            GolangType:"AlertTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 4,
            BitOffset: 4,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlertCategory",
            GolangType:"AlertCategoryConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertSystem",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertSubSystem",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertId",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 64,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceNetworkIdName",
            GolangType:"*uint64",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.8446744073709552e+19,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceIndexSource",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 8,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertOccurrenceNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 64,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcknowledgeSourceNetworkIdName",
            GolangType:"*uint64",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.8446744073709552e+19,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 2,
            BitOffset: 192,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ResponseCommand",
            GolangType:"AlertResponseCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 6,
            BitOffset: 194,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        },
    },
    {
        Id: "AlertText",
        PGN: 126985,
        Description: "Alert Text",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAlertText,
        Instance: &AlertText {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 4,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlertType",
            GolangType:"AlertTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 4,
            BitOffset: 4,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AlertCategory",
            GolangType:"AlertCategoryConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertSystem",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertSubSystem",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertId",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 64,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceNetworkIdName",
            GolangType:"*uint64",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.8446744073709552e+19,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DataSourceIndexSource",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 8,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AlertOccurrenceNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 8,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "LanguageId",
            GolangType:"AlertLanguageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "AlertTextDescription",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "AlertLocationTextDescription",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        },
    },
    {
        Id: "SystemTime",
        PGN: 126992,
        Description: "System Time",
        Fast: false,
        ManId: 0,
        Decoder: DecodeSystemTime,
        Instance: &SystemTime {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 4,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Source",
            GolangType:"SystemTimeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 4,
            BitOffset: 12,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "Date",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "Time",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "Heartbeat",
        PGN: 126993,
        Description: "Heartbeat",
        Fast: false,
        ManId: 0,
        Decoder: DecodeHeartbeat,
        Instance: &Heartbeat {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.001,
            Id: "DataTransmitOffset",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65.533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SequenceCounter",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Controller1State",
            GolangType:"ControllerStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Controller2State",
            GolangType:"ControllerStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "EquipmentStatus",
            GolangType:"EquipmentStatusConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 34,
            BitOffset: 30,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "ProductInformation",
        PGN: 126996,
        Description: "Product Information",
        Fast: true,
        ManId: 0,
        Decoder: DecodeProductInformation,
        Instance: &ProductInformation {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "Nmea2000Version",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65.533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ProductCode",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 256,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "ModelId",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 256,
            BitOffset: 288,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "SoftwareVersionCode",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 256,
            BitOffset: 544,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "ModelVersion",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 256,
            BitOffset: 800,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "ModelSerialCode",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 1056,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "CertificationLevel",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 1064,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LoadEquivalency",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "ConfigurationInformation",
        PGN: 126998,
        Description: "Configuration Information",
        Fast: true,
        ManId: 0,
        Decoder: DecodeConfigurationInformation,
        Instance: &ConfigurationInformation {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "InstallationDescription1",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "InstallationDescription2",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "ManufacturerInformation",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        },
    },
    {
        Id: "ManOverboardNotification",
        PGN: 127233,
        Description: "Man Overboard Notification",
        Fast: true,
        ManId: 0,
        Decoder: DecodeManOverboardNotification,
        Instance: &ManOverboardNotification {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "MobEmitterId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ManOverboardStatus",
            GolangType:"MobStatusConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 5,
            BitOffset: 43,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "ActivationTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 3,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PositionSource",
            GolangType:"MobPositionSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 5,
            BitOffset: 83,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved7",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 88,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "PositionDate",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 32,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "PositionTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 32,
            BitOffset: 136,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Latitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -90,
            DomainMax: 90, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 32,
            BitOffset: 168,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Longitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -180,
            DomainMax: 180, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 2,
            BitOffset: 200,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "CogReference",
            GolangType:"DirectionReferenceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 6,
            BitOffset: 202,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved13",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 16,
            BitOffset: 208,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Cog",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 16,
            BitOffset: 224,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Sog",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 32,
            BitOffset: 240,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "MmsiOfVesselOfOrigin",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 3,
            BitOffset: 272,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MobEmitterBatteryLowStatus",
            GolangType:"LowBatteryConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 5,
            BitOffset: 275,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved18",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        },
    },
    {
        Id: "HeadingTrackControl",
        PGN: 127237,
        Description: "Heading/Track control",
        Fast: true,
        ManId: 0,
        Decoder: DecodeHeadingTrackControl,
        Instance: &HeadingTrackControl {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 2,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RudderLimitExceeded",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 2,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "OffHeadingLimitExceeded",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 4,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "OffTrackLimitExceeded",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Override",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 3,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SteeringMode",
            GolangType:"SteeringModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 3,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TurnMode",
            GolangType:"TurnModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 2,
            BitOffset: 14,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "HeadingReference",
            GolangType:"DirectionReferenceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 5,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 3,
            BitOffset: 21,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "CommandedRudderDirection",
            GolangType:"DirectionRudderConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "CommandedRudderAngle",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "HeadingToSteerCourse",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 16,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Track",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 16,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "RudderLimit",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 16,
            BitOffset: 88,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "OffHeadingLimit",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 16,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "RadiusOfTurnOrder",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 16,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:3.125e-05,
            Id: "RateOfTurnOrder",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -1.02396875,
            RangeMax: 1.02390625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 16,
            BitOffset: 136,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "OffTrackLimit",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -32767,
            RangeMax: 32765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 16,
            BitOffset: 152,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "VesselHeading",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        },
    },
    {
        Id: "Rudder",
        PGN: 127245,
        Description: "Rudder",
        Fast: false,
        ManId: 0,
        Decoder: DecodeRudder,
        Instance: &Rudder {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 3,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DirectionOrder",
            GolangType:"DirectionRudderConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 5,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "AngleOrder",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Position",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "VesselHeading",
        PGN: 127250,
        Description: "Vessel Heading",
        Fast: false,
        ManId: 0,
        Decoder: DecodeVesselHeading,
        Instance: &VesselHeading {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Heading",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Deviation",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Variation",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Reference",
            GolangType:"DirectionReferenceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 6,
            BitOffset: 58,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "RateOfTurn",
        PGN: 127251,
        Description: "Rate of Turn",
        Fast: false,
        ManId: 0,
        Decoder: DecodeRateOfTurn,
        Instance: &RateOfTurn {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:3.125e-08,
            Id: "Rate",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -67.10886396875,
            RangeMax: 67.10886390625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 24,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        },
    },
    {
        Id: "Attitude",
        PGN: 127257,
        Description: "Attitude",
        Fast: false,
        ManId: 0,
        Decoder: DecodeAttitude,
        Instance: &Attitude {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Yaw",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Pitch",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Roll",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "MagneticVariation",
        PGN: 127258,
        Description: "Magnetic Variation",
        Fast: false,
        ManId: 0,
        Decoder: DecodeMagneticVariation,
        Instance: &MagneticVariation {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 4,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Source",
            GolangType:"MagneticVariationConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 4,
            BitOffset: 12,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "AgeOfService",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Variation",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "EngineParametersRapidUpdate",
        PGN: 127488,
        Description: "Engine Parameters, Rapid Update",
        Fast: false,
        ManId: 0,
        Decoder: DecodeEngineParametersRapidUpdate,
        Instance: &EngineParametersRapidUpdate {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Instance",
            GolangType:"EngineInstanceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.25,
            Id: "Speed",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 16383.25,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:100,
            Id: "BoostPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "TiltTrim",
            GolangType:"*int8",
            Signed: true,
            RangeMin: -127,
            RangeMax: 125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "EngineParametersDynamic",
        PGN: 127489,
        Description: "Engine Parameters, Dynamic",
        Fast: true,
        ManId: 0,
        Decoder: DecodeEngineParametersDynamic,
        Instance: &EngineParametersDynamic {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Instance",
            GolangType:"EngineInstanceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:100,
            Id: "OilPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "OilTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Temperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "AlternatorPotential",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "FuelRate",
            GolangType:"*units.Flow",
            Signed: true,
            RangeMin: -3276.7,
            RangeMax: 3276.5,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 88,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:1,
            Id: "TotalEngineHours",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:100,
            Id: "CoolantPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 136,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1000,
            Id: "FuelPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 8,
            BitOffset: 152,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 16,
            BitOffset: 160,
            BitLengthVariable: false,
            CanboatType: "BITLOOKUP",
            Resolution:1,
            Id: "DiscreteStatus1",
            GolangType:"EngineStatus1Const",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65535,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 16,
            BitOffset: 176,
            BitLengthVariable: false,
            CanboatType: "BITLOOKUP",
            Resolution:1,
            Id: "DiscreteStatus2",
            GolangType:"EngineStatus2Const",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65535,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 8,
            BitOffset: 192,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "EngineLoad",
            GolangType:"*int8",
            Signed: true,
            RangeMin: -127,
            RangeMax: 125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 8,
            BitOffset: 200,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "EngineTorque",
            GolangType:"*int8",
            Signed: true,
            RangeMin: -127,
            RangeMax: 125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        },
    },
    {
        Id: "TransmissionParametersDynamic",
        PGN: 127493,
        Description: "Transmission Parameters, Dynamic",
        Fast: false,
        ManId: 0,
        Decoder: DecodeTransmissionParametersDynamic,
        Instance: &TransmissionParametersDynamic {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Instance",
            GolangType:"EngineInstanceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TransmissionGear",
            GolangType:"GearStatusConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 6,
            BitOffset: 10,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:100,
            Id: "OilPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "OilTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DiscreteStatus1",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved7",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "TripParametersVessel",
        PGN: 127496,
        Description: "Trip Parameters, Vessel",
        Fast: true,
        ManId: 0,
        Decoder: DecodeTripParametersVessel,
        Instance: &TripParametersVessel {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.001,
            Id: "TimeToEmpty",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293000001e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "DistanceToEmpty",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "EstimatedFuelRemaining",
            GolangType:"*units.Volume",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.001,
            Id: "TripRunTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293000001e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "TripParametersEngine",
        PGN: 127497,
        Description: "Trip Parameters, Engine",
        Fast: true,
        ManId: 0,
        Decoder: DecodeTripParametersEngine,
        Instance: &TripParametersEngine {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Instance",
            GolangType:"EngineInstanceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "TripFuelUsed",
            GolangType:"*units.Volume",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "FuelRateAverage",
            GolangType:"*units.Flow",
            Signed: true,
            RangeMin: -3276.7,
            RangeMax: 3276.5,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "FuelRateEconomy",
            GolangType:"*units.Flow",
            Signed: true,
            RangeMin: -3276.7,
            RangeMax: 3276.5,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "InstantaneousFuelEconomy",
            GolangType:"*units.Flow",
            Signed: true,
            RangeMin: -3276.7,
            RangeMax: 3276.5,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "EngineParametersStatic",
        PGN: 127498,
        Description: "Engine Parameters, Static",
        Fast: true,
        ManId: 0,
        Decoder: DecodeEngineParametersStatic,
        Instance: &EngineParametersStatic {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Instance",
            GolangType:"EngineInstanceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.25,
            Id: "RatedEngineSpeed",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 16383.25,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 136,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "Vin",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 256,
            BitOffset: 160,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "SoftwareId",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "LoadControllerConnectionStateControl",
        PGN: 127500,
        Description: "Load Controller Connection State/Control",
        Fast: false,
        ManId: 0,
        Decoder: DecodeLoadControllerConnectionStateControl,
        Instance: &LoadControllerConnectionStateControl {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SequenceId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ConnectionId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "State",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Status",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "OperationalStatusControl",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "PwmDutyCycle",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Timeon",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Timeoff",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "BinarySwitchBankStatus",
        PGN: 127501,
        Description: "Binary Switch Bank Status",
        Fast: false,
        ManId: 0,
        Decoder: DecodeBinarySwitchBankStatus,
        Instance: &BinarySwitchBankStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator1",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 10,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator2",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 12,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator3",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 14,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator4",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator5",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 2,
            BitOffset: 18,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator6",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 2,
            BitOffset: 20,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator7",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 2,
            BitOffset: 22,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator8",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator9",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 2,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator10",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 2,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator11",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 2,
            BitOffset: 30,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator12",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 2,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator13",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 2,
            BitOffset: 34,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator14",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 2,
            BitOffset: 36,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator15",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 2,
            BitOffset: 38,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator16",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 2,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator17",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        19: { 
            BitLength: 2,
            BitOffset: 42,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator18",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 19,
            },
        20: { 
            BitLength: 2,
            BitOffset: 44,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator19",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 20,
            },
        21: { 
            BitLength: 2,
            BitOffset: 46,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator20",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 21,
            },
        22: { 
            BitLength: 2,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator21",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 22,
            },
        23: { 
            BitLength: 2,
            BitOffset: 50,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator22",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 23,
            },
        24: { 
            BitLength: 2,
            BitOffset: 52,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator23",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 24,
            },
        25: { 
            BitLength: 2,
            BitOffset: 54,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator24",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 25,
            },
        26: { 
            BitLength: 2,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator25",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 26,
            },
        27: { 
            BitLength: 2,
            BitOffset: 58,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator26",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 27,
            },
        28: { 
            BitLength: 2,
            BitOffset: 60,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator27",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 28,
            },
        29: { 
            BitLength: 2,
            BitOffset: 62,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Indicator28",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 29,
            },
        },
    },
    {
        Id: "SwitchBankControl",
        PGN: 127502,
        Description: "Switch Bank Control",
        Fast: false,
        ManId: 0,
        Decoder: DecodeSwitchBankControl,
        Instance: &SwitchBankControl {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch1",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 10,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch2",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 12,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch3",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 14,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch4",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch5",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 2,
            BitOffset: 18,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch6",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 2,
            BitOffset: 20,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch7",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 2,
            BitOffset: 22,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch8",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch9",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 2,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch10",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 2,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch11",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 2,
            BitOffset: 30,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch12",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 2,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch13",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 2,
            BitOffset: 34,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch14",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 2,
            BitOffset: 36,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch15",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 2,
            BitOffset: 38,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch16",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 2,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch17",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        19: { 
            BitLength: 2,
            BitOffset: 42,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch18",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 19,
            },
        20: { 
            BitLength: 2,
            BitOffset: 44,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch19",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 20,
            },
        21: { 
            BitLength: 2,
            BitOffset: 46,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch20",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 21,
            },
        22: { 
            BitLength: 2,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch21",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 22,
            },
        23: { 
            BitLength: 2,
            BitOffset: 50,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch22",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 23,
            },
        24: { 
            BitLength: 2,
            BitOffset: 52,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch23",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 24,
            },
        25: { 
            BitLength: 2,
            BitOffset: 54,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch24",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 25,
            },
        26: { 
            BitLength: 2,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch25",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 26,
            },
        27: { 
            BitLength: 2,
            BitOffset: 58,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch26",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 27,
            },
        28: { 
            BitLength: 2,
            BitOffset: 60,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch27",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 28,
            },
        29: { 
            BitLength: 2,
            BitOffset: 62,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Switch28",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 29,
            },
        },
    },
    {
        Id: "AcInputStatus",
        PGN: 127503,
        Description: "AC Input Status",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAcInputStatus,
        Instance: &AcInputStatus {},
        Repeating1CountField: 2,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfLines",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        },
    },
    {
        Id: "AcOutputStatus",
        PGN: 127504,
        Description: "AC Output Status",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAcOutputStatus,
        Instance: &AcOutputStatus {},
        Repeating1CountField: 2,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfLines",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        },
    },
    {
        Id: "FluidLevel",
        PGN: 127505,
        Description: "Fluid Level",
        Fast: false,
        ManId: 0,
        Decoder: DecodeFluidLevel,
        Instance: &FluidLevel {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 4,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 4,
            BitOffset: 4,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Type",
            GolangType:"TankTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.004,
            Id: "Level",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -131.068,
            RangeMax: 131.06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "Capacity",
            GolangType:"*units.Volume",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "DcDetailedStatus",
        PGN: 127506,
        Description: "DC Detailed Status",
        Fast: true,
        ManId: 0,
        Decoder: DecodeDcDetailedStatus,
        Instance: &DcDetailedStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DcType",
            GolangType:"DcSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "StateOfCharge",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "StateOfHealth",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:60,
            Id: "TimeRemaining",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.93198e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "RippleVoltage",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RemainingCapacity",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "ChargerStatus",
        PGN: 127507,
        Description: "Charger Status",
        Fast: true,
        ManId: 0,
        Decoder: DecodeChargerStatus,
        Instance: &ChargerStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "BatteryInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 4,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "OperatingState",
            GolangType:"ChargerStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 4,
            BitOffset: 20,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ChargeMode",
            GolangType:"ChargerModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Enabled",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "EqualizationPending",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 4,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:60,
            Id: "EqualizationTimeRemaining",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.93198e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "BatteryStatus",
        PGN: 127508,
        Description: "Battery Status",
        Fast: false,
        ManId: 0,
        Decoder: DecodeBatteryStatus,
        Instance: &BatteryStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Voltage",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "Current",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3276.7,
            RangeMax: 3276.5,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Temperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "InverterStatus",
        PGN: 127509,
        Description: "Inverter Status",
        Fast: true,
        ManId: 0,
        Decoder: DecodeInverterStatus,
        Instance: &InverterStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "AcInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DcInstance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 4,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "OperatingState",
            GolangType:"InverterStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "InverterEnable",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 30,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "AcPowerCurrentPhaseA",
        PGN: 127744,
        Description: "AC Power / Current - Phase A",
        Fast: false,
        ManId: 0,
        Decoder: DecodeAcPowerCurrentPhaseA,
        Instance: &AcPowerCurrentPhaseA {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ConnectionNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "AcRmsCurrent",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Power",
            GolangType:"*int32",
            Signed: true,
            RangeMin: -2.147483647e+09,
            RangeMax: 2.147483645e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "AcPowerCurrentPhaseB",
        PGN: 127745,
        Description: "AC Power / Current - Phase B",
        Fast: false,
        ManId: 0,
        Decoder: DecodeAcPowerCurrentPhaseB,
        Instance: &AcPowerCurrentPhaseB {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ConnectionNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "AcRmsCurrent",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Power",
            GolangType:"*int32",
            Signed: true,
            RangeMin: -2.147483647e+09,
            RangeMax: 2.147483645e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "AcPowerCurrentPhaseC",
        PGN: 127746,
        Description: "AC Power / Current - Phase C",
        Fast: false,
        ManId: 0,
        Decoder: DecodeAcPowerCurrentPhaseC,
        Instance: &AcPowerCurrentPhaseC {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ConnectionNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "AcRmsCurrent",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Power",
            GolangType:"*int32",
            Signed: true,
            RangeMin: -2.147483647e+09,
            RangeMax: 2.147483645e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "ConverterStatus",
        PGN: 127750,
        Description: "Converter Status",
        Fast: false,
        ManId: 0,
        Decoder: DecodeConverterStatus,
        Instance: &ConverterStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "Sid",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ConnectionNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "OperatingState",
            GolangType:"ConverterStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TemperatureState",
            GolangType:"GoodWarningErrorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "OverloadState",
            GolangType:"GoodWarningErrorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "LowDcVoltageState",
            GolangType:"GoodWarningErrorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 2,
            BitOffset: 30,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RippleState",
            GolangType:"GoodWarningErrorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "DcVoltageCurrent",
        PGN: 127751,
        Description: "DC Voltage/Current",
        Fast: false,
        ManId: 0,
        Decoder: DecodeDcVoltageCurrent,
        Instance: &DcVoltageCurrent {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "Sid",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ConnectionNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "DcVoltage",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 24,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "DcCurrent",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -83886.07,
            RangeMax: 83886.05,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "LeewayAngle",
        PGN: 128000,
        Description: "Leeway Angle",
        Fast: false,
        ManId: 0,
        Decoder: DecodeLeewayAngle,
        Instance: &LeewayAngle {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "LeewayAngle",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 40,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        },
    },
    {
        Id: "ThrusterControlStatus",
        PGN: 128006,
        Description: "Thruster Control Status",
        Fast: false,
        ManId: 0,
        Decoder: DecodeThrusterControlStatus,
        Instance: &ThrusterControlStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Identifier",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 4,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DirectionControl",
            GolangType:"ThrusterDirectionControlConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 20,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerEnabled",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 22,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RetractControl",
            GolangType:"ThrusterRetractControlConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SpeedControl",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "BITLOOKUP",
            Resolution:1,
            Id: "ControlEvents",
            GolangType:"ThrusterControlEventsConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 255,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.005,
            Id: "CommandTimeout",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.265,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "AzimuthControl",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        },
    },
    {
        Id: "ThrusterInformation",
        PGN: 128007,
        Description: "Thruster Information",
        Fast: false,
        ManId: 0,
        Decoder: DecodeThrusterInformation,
        Instance: &ThrusterInformation {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Identifier",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 4,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MotorType",
            GolangType:"ThrusterMotorTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 4,
            BitOffset: 12,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "PowerRating",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "MaximumTemperatureRating",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.25,
            Id: "MaximumRotationalSpeed",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 16383.25,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "ThrusterMotorStatus",
        PGN: 128008,
        Description: "Thruster Motor Status",
        Fast: false,
        ManId: 0,
        Decoder: DecodeThrusterMotorStatus,
        Instance: &ThrusterMotorStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Identifier",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "BITLOOKUP",
            Resolution:1,
            Id: "MotorEvents",
            GolangType:"ThrusterMotorEventsConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 255,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Current",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Temperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:60,
            Id: "OperatingTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.93198e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "Speed",
        PGN: 128259,
        Description: "Speed",
        Fast: false,
        ManId: 0,
        Decoder: DecodeSpeed,
        Instance: &Speed {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "SpeedWaterReferenced",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "SpeedGroundReferenced",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SpeedWaterReferencedType",
            GolangType:"WaterReferenceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 4,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SpeedDirection",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 12,
            BitOffset: 52,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "WaterDepth",
        PGN: 128267,
        Description: "Water Depth",
        Fast: false,
        ManId: 0,
        Decoder: DecodeWaterDepth,
        Instance: &WaterDepth {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Depth",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "Offset",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:10,
            Id: "Range",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2530,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "DistanceLog",
        PGN: 128275,
        Description: "Distance Log",
        Fast: true,
        ManId: 0,
        Decoder: DecodeDistanceLog,
        Instance: &DistanceLog {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "Date",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "Time",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Log",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "TripLog",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "WindlassControlStatus",
        PGN: 128776,
        Description: "Windlass Control Status",
        Fast: false,
        ManId: 0,
        Decoder: DecodeWindlassControlStatus,
        Instance: &WindlassControlStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "WindlassId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "WindlassDirectionControl",
            GolangType:"WindlassDirectionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 18,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AnchorDockingControl",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 20,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SpeedControlType",
            GolangType:"SpeedTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 22,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "SpeedControl",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 2,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PowerEnable",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 2,
            BitOffset: 34,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MechanicalLock",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 2,
            BitOffset: 36,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DeckAndAnchorWash",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 2,
            BitOffset: 38,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AnchorLight",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.005,
            Id: "CommandTimeout",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.265,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 4,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "BITLOOKUP",
            Resolution:1,
            Id: "WindlassControlEvents",
            GolangType:"WindlassControlConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 15,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 12,
            BitOffset: 52,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved14",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        },
    },
    {
        Id: "AnchorWindlassOperatingStatus",
        PGN: 128777,
        Description: "Anchor Windlass Operating Status",
        Fast: false,
        ManId: 0,
        Decoder: DecodeAnchorWindlassOperatingStatus,
        Instance: &AnchorWindlassOperatingStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "WindlassId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "WindlassDirectionControl",
            GolangType:"WindlassDirectionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 18,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "WindlassMotionStatus",
            GolangType:"WindlassMotionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 20,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RodeTypeStatus",
            GolangType:"RodeTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 22,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "RodeCounterValue",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "WindlassLineSpeed",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 2,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AnchorDockingStatus",
            GolangType:"DockingStatusConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 6,
            BitOffset: 58,
            BitLengthVariable: false,
            CanboatType: "BITLOOKUP",
            Resolution:1,
            Id: "WindlassOperatingEvents",
            GolangType:"WindlassOperationConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 63,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        },
    },
    {
        Id: "AnchorWindlassMonitoringStatus",
        PGN: 128778,
        Description: "Anchor Windlass Monitoring Status",
        Fast: false,
        ManId: 0,
        Decoder: DecodeAnchorWindlassMonitoringStatus,
        Instance: &AnchorWindlassMonitoringStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "WindlassId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "BITLOOKUP",
            Resolution:1,
            Id: "WindlassMonitoringEvents",
            GolangType:"WindlassMonitoringConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 255,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.2,
            Id: "ControllerVoltage",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 50.6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "MotorCurrent",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:60,
            Id: "TotalMotorTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3.93198e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "PositionRapidUpdate",
        PGN: 129025,
        Description: "Position, Rapid Update",
        Fast: false,
        ManId: 0,
        Decoder: DecodePositionRapidUpdate,
        Instance: &PositionRapidUpdate {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Latitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -90,
            DomainMax: 90, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Longitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -180,
            DomainMax: 180, 
            Match: -1,
            Order: 2,
            },
        },
    },
    {
        Id: "CogSogRapidUpdate",
        PGN: 129026,
        Description: "COG & SOG, Rapid Update",
        Fast: false,
        ManId: 0,
        Decoder: DecodeCogSogRapidUpdate,
        Instance: &CogSogRapidUpdate {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "CogReference",
            GolangType:"DirectionReferenceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 6,
            BitOffset: 10,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Cog",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Sog",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "GnssPositionData",
        PGN: 129029,
        Description: "GNSS Position Data",
        Fast: true,
        ManId: 0,
        Decoder: DecodeGnssPositionData,
        Instance: &GnssPositionData {},
        Repeating1CountField: 15,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "Date",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "Time",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 64,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-16,
            Id: "Latitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -922.3372036854776,
            RangeMax: 922.3372036854776,
            DomainMin: -90,
            DomainMax: 90, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 64,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-16,
            Id: "Longitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -922.3372036854776,
            RangeMax: 922.3372036854776,
            DomainMin: -180,
            DomainMax: 180, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 64,
            BitOffset: 184,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-06,
            Id: "Altitude",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -9.223372036854775e+12,
            RangeMax: 9.223372036854775e+12,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 4,
            BitOffset: 248,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "GnssType",
            GolangType:"GnsConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 4,
            BitOffset: 252,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Method",
            GolangType:"GnsMethodConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 2,
            BitOffset: 256,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Integrity",
            GolangType:"GnsIntegrityConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 6,
            BitOffset: 258,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 8,
            BitOffset: 264,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfSvs",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 16,
            BitOffset: 272,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Hdop",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 16,
            BitOffset: 288,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Pdop",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 32,
            BitOffset: 304,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "GeoidalSeparation",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -2.147483647e+07,
            RangeMax: 2.147483645e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 8,
            BitOffset: 336,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReferenceStations",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        },
    },
    {
        Id: "TimeDate",
        PGN: 129033,
        Description: "Time & Date",
        Fast: false,
        ManId: 0,
        Decoder: DecodeTimeDate,
        Instance: &TimeDate {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "Date",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "Time",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:60,
            Id: "LocalOffset",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -1.96602e+06,
            RangeMax: 1.9659e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        },
    },
    {
        Id: "AisClassAPositionReport",
        PGN: 129038,
        Description: "AIS Class A Position Report",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisClassAPositionReport,
        Instance: &AisClassAPositionReport {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "UserId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Longitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -180,
            DomainMax: 180, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Latitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -90,
            DomainMax: 90, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 1,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PositionAccuracy",
            GolangType:"PositionAccuracyConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 1,
            BitOffset: 105,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Raim",
            GolangType:"RaimFlagConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 6,
            BitOffset: 106,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TimeStamp",
            GolangType:"TimeStampConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 63,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Cog",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 16,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Sog",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 19,
            BitOffset: 144,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "CommunicationState",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 5,
            BitOffset: 163,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 16,
            BitOffset: 168,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Heading",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 16,
            BitOffset: 184,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:3.125e-05,
            Id: "RateOfTurn",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -1.02396875,
            RangeMax: 1.02390625,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 4,
            BitOffset: 200,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "NavStatus",
            GolangType:"NavStatusConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 14,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 2,
            BitOffset: 204,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SpecialManeuverIndicator",
            GolangType:"AisSpecialManeuverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 2,
            BitOffset: 206,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 3,
            BitOffset: 208,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "Spare18",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        19: { 
            BitLength: 5,
            BitOffset: 211,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved19",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 19,
            },
        20: { 
            BitLength: 8,
            BitOffset: 216,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SequenceId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 20,
            },
        },
    },
    {
        Id: "AisClassBPositionReport",
        PGN: 129039,
        Description: "AIS Class B Position Report",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisClassBPositionReport,
        Instance: &AisClassBPositionReport {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "UserId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Longitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -180,
            DomainMax: 180, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Latitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -90,
            DomainMax: 90, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 1,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PositionAccuracy",
            GolangType:"PositionAccuracyConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 1,
            BitOffset: 105,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Raim",
            GolangType:"RaimFlagConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 6,
            BitOffset: 106,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TimeStamp",
            GolangType:"TimeStampConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 63,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Cog",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 16,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Sog",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 19,
            BitOffset: 144,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "CommunicationState",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 5,
            BitOffset: 163,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 16,
            BitOffset: 168,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Heading",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 8,
            BitOffset: 184,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "RegionalApplication",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 2,
            BitOffset: 192,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "RegionalApplicationB",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 1,
            BitOffset: 194,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "UnitType",
            GolangType:"AisTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 1,
            BitOffset: 195,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "IntegratedDisplay",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 1,
            BitOffset: 196,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Dsc",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        19: { 
            BitLength: 1,
            BitOffset: 197,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Band",
            GolangType:"AisBandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 19,
            },
        20: { 
            BitLength: 1,
            BitOffset: 198,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "CanHandleMsg22",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 20,
            },
        21: { 
            BitLength: 1,
            BitOffset: 199,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisMode",
            GolangType:"AisModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 21,
            },
        22: { 
            BitLength: 1,
            BitOffset: 200,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisCommunicationState",
            GolangType:"AisCommunicationStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 22,
            },
        23: { 
            BitLength: 15,
            BitOffset: 201,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 23,
            },
        },
    },
    {
        Id: "AisAidsToNavigationAtonReport",
        PGN: 129041,
        Description: "AIS Aids to Navigation (AtoN) Report",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisAidsToNavigationAtonReport,
        Instance: &AisAidsToNavigationAtonReport {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "UserId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Longitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -180,
            DomainMax: 180, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "Latitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: -90,
            DomainMax: 90, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 1,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PositionAccuracy",
            GolangType:"PositionAccuracyConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 1,
            BitOffset: 105,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Raim",
            GolangType:"RaimFlagConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 6,
            BitOffset: 106,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TimeStamp",
            GolangType:"TimeStampConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 63,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "LengthDiameter",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 16,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "BeamDiameter",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 16,
            BitOffset: 144,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "PositionReferenceFromStarboardEdge",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 16,
            BitOffset: 160,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "PositionReferenceFromTrueNorthFacingEdge",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 5,
            BitOffset: 176,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AtonType",
            GolangType:"AtonTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 31,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 1,
            BitOffset: 181,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "OffPositionIndicator",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 1,
            BitOffset: 182,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "VirtualAtonFlag",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 1,
            BitOffset: 183,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AssignedModeFlag",
            GolangType:"AisAssignedModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 1,
            BitOffset: 184,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "Spare",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 4,
            BitOffset: 185,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PositionFixingDeviceType",
            GolangType:"PositionFixDeviceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 15,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        19: { 
            BitLength: 3,
            BitOffset: 189,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved19",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 19,
            },
        20: { 
            BitLength: 8,
            BitOffset: 192,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "AtonStatus",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 20,
            },
        21: { 
            BitLength: 5,
            BitOffset: 200,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 21,
            },
        22: { 
            BitLength: 3,
            BitOffset: 205,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved22",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 22,
            },
        23: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "AtonName",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 23,
            },
        },
    },
    {
        Id: "Datum",
        PGN: 129044,
        Description: "Datum",
        Fast: true,
        ManId: 0,
        Decoder: DecodeDatum,
        Instance: &Datum {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "LocalDatum",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "DeltaLatitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "DeltaLongitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 96,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "DeltaAltitude",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -2.147483647e+07,
            RangeMax: 2.147483645e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "ReferenceDatum",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "UserDatum",
        PGN: 129045,
        Description: "User Datum",
        Fast: true,
        ManId: 0,
        Decoder: DecodeUserDatum,
        Instance: &UserDatum {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 32,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "DeltaX",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -2.147483647e+07,
            RangeMax: 2.147483645e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "DeltaY",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -2.147483647e+07,
            RangeMax: 2.147483645e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "DeltaZ",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -2.147483647e+07,
            RangeMax: 2.147483645e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 96,
            BitLengthVariable: false,
            CanboatType: "FLOAT",
            Resolution:1,
            Id: "RotationInX",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.402823466385289e+38,
            RangeMax: 3.402823466385289e+38,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "FLOAT",
            Resolution:1,
            Id: "RotationInY",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.402823466385289e+38,
            RangeMax: 3.402823466385289e+38,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 32,
            BitOffset: 160,
            BitLengthVariable: false,
            CanboatType: "FLOAT",
            Resolution:1,
            Id: "RotationInZ",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.402823466385289e+38,
            RangeMax: 3.402823466385289e+38,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 192,
            BitLengthVariable: false,
            CanboatType: "FLOAT",
            Resolution:1,
            Id: "Scale",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.402823466385289e+38,
            RangeMax: 3.402823466385289e+38,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 32,
            BitOffset: 224,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "EllipsoidSemiMajorAxis",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -2.147483647e+07,
            RangeMax: 2.147483645e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 32,
            BitOffset: 256,
            BitLengthVariable: false,
            CanboatType: "FLOAT",
            Resolution:1,
            Id: "EllipsoidFlatteningInverse",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -3.402823466385289e+38,
            RangeMax: 3.402823466385289e+38,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 32,
            BitOffset: 288,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "DatumName",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        },
    },
    {
        Id: "CrossTrackError",
        PGN: 129283,
        Description: "Cross Track Error",
        Fast: false,
        ManId: 0,
        Decoder: DecodeCrossTrackError,
        Instance: &CrossTrackError {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 4,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "XteMode",
            GolangType:"ResidualModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 12,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 14,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "NavigationTerminated",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Xte",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -2.147483647e+07,
            RangeMax: 2.147483645e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "NavigationData",
        PGN: 129284,
        Description: "Navigation Data",
        Fast: true,
        ManId: 0,
        Decoder: DecodeNavigationData,
        Instance: &NavigationData {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "DistanceToWaypoint",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "CourseBearingReference",
            GolangType:"DirectionReferenceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 42,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "PerpendicularCrossed",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 44,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ArrivalCircleEntered",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 46,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "CalculationType",
            GolangType:"BearingModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "EtaTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "EtaDate",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 96,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "BearingOriginToDestinationWaypoint",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 16,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "BearingPositionToDestinationWaypoint",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 32,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "OriginWaypointNumber",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 32,
            BitOffset: 160,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DestinationWaypointNumber",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 32,
            BitOffset: 192,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "DestinationLatitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 32,
            BitOffset: 224,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "DestinationLongitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 16,
            BitOffset: 256,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "WaypointClosingVelocity",
            GolangType:"*units.Velocity",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        },
    },
    {
        Id: "NavigationRouteWpInformation",
        PGN: 129285,
        Description: "Navigation - Route/WP Information",
        Fast: true,
        ManId: 0,
        Decoder: DecodeNavigationRouteWpInformation,
        Instance: &NavigationRouteWpInformation {},
        Repeating1CountField: 2,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "StartRps",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Nitems",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DatabaseId",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RouteId",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 3,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "NavigationDirectionInRoute",
            GolangType:"DirectionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 67,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SupplementaryRouteWpDataAvailable",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 3,
            BitOffset: 69,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "RouteName",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved9",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        },
    },
    {
        Id: "GnssDops",
        PGN: 129539,
        Description: "GNSS DOPs",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGnssDops,
        Instance: &GnssDops {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 3,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DesiredMode",
            GolangType:"GnssModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ActualMode",
            GolangType:"GnssModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 14,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Hdop",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Vdop",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Tdop",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "GnssSatsInView",
        PGN: 129540,
        Description: "GNSS Sats in View",
        Fast: true,
        ManId: 0,
        Decoder: DecodeGnssSatsInView,
        Instance: &GnssSatsInView {},
        Repeating1CountField: 4,
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RangeResidualMode",
            GolangType:"RangeResidualModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 6,
            BitOffset: 10,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SatsInView",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        },
    },
    {
        Id: "GnssRaimSettings",
        PGN: 129546,
        Description: "GNSS RAIM Settings",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGnssRaimSettings,
        Instance: &GnssRaimSettings {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "RadialPositionErrorMaximumThreshold",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ProbabilityOfFalseAlarm",
            GolangType:"*int8",
            Signed: true,
            RangeMin: -127,
            RangeMax: 125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ProbabilityOfMissedDetection",
            GolangType:"*int8",
            Signed: true,
            RangeMin: -127,
            RangeMax: 125,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:1,
            Id: "PseudorangeResidualFilteringTimeConstant",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "GnssPseudorangeErrorStatistics",
        PGN: 129547,
        Description: "GNSS Pseudorange Error Statistics",
        Fast: true,
        ManId: 0,
        Decoder: DecodeGnssPseudorangeErrorStatistics,
        Instance: &GnssPseudorangeErrorStatistics {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "RmsStdDevOfRangeInputs",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "StdDevOfMajorErrorEllipse",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "StdDevOfMinorErrorEllipse",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "OrientationOfErrorEllipse",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "StdDevLatError",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 88,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "StdDevLonError",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "StdDevAltError",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "DgnssCorrections",
        PGN: 129549,
        Description: "DGNSS Corrections",
        Fast: true,
        ManId: 0,
        Decoder: DecodeDgnssCorrections,
        Instance: &DgnssCorrections {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 12,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReferenceStationId",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4093,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 4,
            BitOffset: 20,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ReferenceStationType",
            GolangType:"GnsConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.001,
            Id: "TimeOfCorrections",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65.533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 4,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "StationHealth",
            GolangType:"StationHealthConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 4,
            BitOffset: 44,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SatelliteId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 32,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Prc",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -214748.3647,
            RangeMax: 214748.3645,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 88,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "Rrc",
            GolangType:"*units.Velocity",
            Signed: true,
            RangeMin: -3.2767,
            RangeMax: 3.2765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 16,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Udre",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 8,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Iod",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        },
    },
    {
        Id: "GnssDifferentialCorrectionReceiverInterface",
        PGN: 129550,
        Description: "GNSS Differential Correction Receiver Interface",
        Fast: false,
        ManId: 0,
        Decoder: DecodeGnssDifferentialCorrectionReceiverInterface,
        Instance: &GnssDifferentialCorrectionReceiverInterface {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Channel",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:10,
            Id: "Frequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+10,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 5,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SerialInterfaceBitRate",
            GolangType:"SerialBitRateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 3,
            BitOffset: 45,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SerialInterfaceDetectionMode",
            GolangType:"SerialDetectionModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 4,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DifferentialSource",
            GolangType:"DifferentialSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 4,
            BitOffset: 52,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DifferentialOperationMode",
            GolangType:"DifferentialModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "GnssDifferentialCorrectionReceiverSignal",
        PGN: 129551,
        Description: "GNSS Differential Correction Receiver Signal",
        Fast: true,
        ManId: 0,
        Decoder: DecodeGnssDifferentialCorrectionReceiverSignal,
        Instance: &GnssDifferentialCorrectionReceiverSignal {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Channel",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "SignalStrength",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -2.147483647e+07,
            RangeMax: 2.147483645e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "SignalSnr",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -327.67,
            RangeMax: 327.65,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:10,
            Id: "Frequency",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+10,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 4,
            BitOffset: 96,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "StationType",
            GolangType:"GnsConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 12,
            BitOffset: 100,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ReferenceStationId",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4093,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 5,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DifferentialSignalBitRate",
            GolangType:"SerialBitRateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 3,
            BitOffset: 117,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DifferentialSignalDetectionMode",
            GolangType:"SerialDetectionModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 2,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "UsedAsCorrectionSource",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 2,
            BitOffset: 122,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 4,
            BitOffset: 124,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "DifferentialSource",
            GolangType:"DifferentialSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 16,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.01,
            Id: "TimeSinceLastSatDifferentialSync",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 16,
            BitOffset: 144,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SatelliteServiceIdNo",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        },
    },
    {
        Id: "GlonassAlmanacData",
        PGN: 129556,
        Description: "GLONASS Almanac Data",
        Fast: true,
        ManId: 0,
        Decoder: DecodeGlonassAlmanacData,
        Instance: &GlonassAlmanacData {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Prn",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Na",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 1,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Cna",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 5,
            BitOffset: 27,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Hna",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "EpsilonNa",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DeltatnaDot",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "OmegaNa",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 24,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DeltaTna",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 24,
            BitOffset: 96,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Tna",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 24,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "LambdaNa",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 24,
            BitOffset: 144,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DeltaIna",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1.6777213e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 28,
            BitOffset: 168,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "TauCa",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2.68435453e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 12,
            BitOffset: 196,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "TauNa",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4093,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        },
    },
    {
        Id: "AisClassAStaticAndVoyageRelatedData",
        PGN: 129794,
        Description: "AIS Class A Static and Voyage Related Data",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisClassAStaticAndVoyageRelatedData,
        Instance: &AisClassAStaticAndVoyageRelatedData {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "UserId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ImoNumber",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 56,
            BitOffset: 72,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "Callsign",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 160,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "Name",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 288,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TypeOfShip",
            GolangType:"ShipTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 296,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "Length",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 312,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "Beam",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 16,
            BitOffset: 328,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "PositionReferenceFromStarboard",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 16,
            BitOffset: 344,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "PositionReferenceFromBow",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 16,
            BitOffset: 360,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "EtaDate",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 32,
            BitOffset: 376,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "EtaTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 16,
            BitOffset: 408,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Draft",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 160,
            BitOffset: 424,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "Destination",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 2,
            BitOffset: 584,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisVersionIndicator",
            GolangType:"AisVersionConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 4,
            BitOffset: 586,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "GnssType",
            GolangType:"PositionFixDeviceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 15,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 1,
            BitOffset: 590,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Dte",
            GolangType:"AvailableConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        19: { 
            BitLength: 1,
            BitOffset: 591,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 19,
            },
        20: { 
            BitLength: 5,
            BitOffset: 592,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 20,
            },
        21: { 
            BitLength: 3,
            BitOffset: 597,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved21",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 21,
            },
        },
    },
    {
        Id: "AisAddressedBinaryMessage",
        PGN: 129795,
        Description: "AIS Addressed Binary Message",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisAddressedBinaryMessage,
        Instance: &AisAddressedBinaryMessage {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "SourceId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 1,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 5,
            BitOffset: 41,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 46,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SequenceNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "DestinationId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 6,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved8",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 1,
            BitOffset: 86,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "RetransmitFlag",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 1,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 1,
            BitOffset: 87,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved10",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 16,
            BitOffset: 88,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfBitsInBinaryDataField",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 1680, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "BinaryData",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        },
    },
    {
        Id: "AisAcknowledge",
        PGN: 129796,
        Description: "AIS Acknowledge",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisAcknowledge,
        Instance: &AisAcknowledge {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "SourceId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 1,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 5,
            BitOffset: 41,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 46,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "DestinationId1",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 2,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "SequenceNumberForId1",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 6,
            BitOffset: 82,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved9",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 2,
            BitOffset: 88,
            BitLengthVariable: false,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "SequenceNumberForIdN",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 6,
            BitOffset: 90,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved11",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        },
    },
    {
        Id: "AisBinaryBroadcastMessage",
        PGN: 129797,
        Description: "AIS Binary Broadcast Message",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisBinaryBroadcastMessage,
        Instance: &AisBinaryBroadcastMessage {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SourceId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 1,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 5,
            BitOffset: 41,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 46,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved6",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "NumberOfBitsInBinaryDataField",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 1720, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "BINARY",
            Resolution:1,
            Id: "BinaryData",
            GolangType:"[]uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "AisClassBStaticDataMsg24PartA",
        PGN: 129809,
        Description: "AIS Class B static data (msg 24 Part A)",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisClassBStaticDataMsg24PartA,
        Instance: &AisClassBStaticDataMsg24PartA {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "UserId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 160,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "Name",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 5,
            BitOffset: 200,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 3,
            BitOffset: 205,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 208,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SequenceId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        },
    },
    {
        Id: "AisClassBStaticDataMsg24PartB",
        PGN: 129810,
        Description: "AIS Class B static data (msg 24 Part B)",
        Fast: true,
        ManId: 0,
        Decoder: DecodeAisClassBStaticDataMsg24PartB,
        Instance: &AisClassBStaticDataMsg24PartB {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "MessageId",
            GolangType:"AisMessageIdConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RepeatIndicator",
            GolangType:"RepeatIndicatorConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 32,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "UserId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TypeOfShip",
            GolangType:"ShipTypeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 56,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "VendorId",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 56,
            BitOffset: 104,
            BitLengthVariable: false,
            CanboatType: "STRING_FIX",
            Resolution:1,
            Id: "Callsign",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 160,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "Length",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 176,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "Beam",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 192,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "PositionReferenceFromStarboard",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 16,
            BitOffset: 208,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "PositionReferenceFromBow",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 32,
            BitOffset: 224,
            BitLengthVariable: false,
            CanboatType: "MMSI",
            Resolution:1,
            Id: "MothershipUserId",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 2e+06,
            RangeMax: 9.99999999e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 2,
            BitOffset: 256,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 2,
            BitOffset: 258,
            BitLengthVariable: false,
            CanboatType: "SPARE",
            Resolution:1,
            Id: "Spare13",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 4,
            BitOffset: 260,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "GnssType",
            GolangType:"PositionFixDeviceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 15,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 5,
            BitOffset: 264,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "AisTransceiverInformation",
            GolangType:"AisTransceiverConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 29,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 3,
            BitOffset: 269,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved16",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 8,
            BitOffset: 272,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "SequenceId",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        },
    },
    {
        Id: "WindData",
        PGN: 130306,
        Description: "Wind Data",
        Fast: false,
        ManId: 0,
        Decoder: DecodeWindData,
        Instance: &WindData {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "WindSpeed",
            GolangType:"*units.Velocity",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.0001,
            Id: "WindAngle",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 3,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Reference",
            GolangType:"WindReferenceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 21,
            BitOffset: 43,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "EnvironmentalParametersObsolete",
        PGN: 130310,
        Description: "Environmental Parameters (obsolete)",
        Fast: false,
        ManId: 0,
        Decoder: DecodeEnvironmentalParametersObsolete,
        Instance: &EnvironmentalParametersObsolete {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "WaterTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "OutsideAmbientAirTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:100,
            Id: "AtmosphericPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "EnvironmentalParameters",
        PGN: 130311,
        Description: "Environmental Parameters",
        Fast: false,
        ManId: 0,
        Decoder: DecodeEnvironmentalParameters,
        Instance: &EnvironmentalParameters {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 6,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TemperatureSource",
            GolangType:"TemperatureSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 14,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "HumiditySource",
            GolangType:"HumiditySourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "Temperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.004,
            Id: "Humidity",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -131.068,
            RangeMax: 131.06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:100,
            Id: "AtmosphericPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "Temperature",
        PGN: 130312,
        Description: "Temperature",
        Fast: false,
        ManId: 0,
        Decoder: DecodeTemperature,
        Instance: &Temperature {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Source",
            GolangType:"TemperatureSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "ActualTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "SetTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "Humidity",
        PGN: 130313,
        Description: "Humidity",
        Fast: false,
        ManId: 0,
        Decoder: DecodeHumidity,
        Instance: &Humidity {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Source",
            GolangType:"HumiditySourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.004,
            Id: "ActualHumidity",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -131.068,
            RangeMax: 131.06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.004,
            Id: "SetHumidity",
            GolangType:"*float32",
            Signed: true,
            RangeMin: -131.068,
            RangeMax: 131.06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "ActualPressure",
        PGN: 130314,
        Description: "Actual Pressure",
        Fast: false,
        ManId: 0,
        Decoder: DecodeActualPressure,
        Instance: &ActualPressure {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Source",
            GolangType:"PressureSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "Pressure",
            GolangType:"*units.Pressure",
            Signed: true,
            RangeMin: -2.147483647e+08,
            RangeMax: 2.147483645e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "SetPressure",
        PGN: 130315,
        Description: "Set Pressure",
        Fast: false,
        ManId: 0,
        Decoder: DecodeSetPressure,
        Instance: &SetPressure {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Source",
            GolangType:"PressureSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 32,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "Pressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+08,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "TemperatureExtendedRange",
        PGN: 130316,
        Description: "Temperature Extended Range",
        Fast: false,
        ManId: 0,
        Decoder: DecodeTemperatureExtendedRange,
        Instance: &TemperatureExtendedRange {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 8,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 8,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Source",
            GolangType:"TemperatureSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 24,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "Temperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 16777.213,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "SetTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        },
    },
    {
        Id: "TideStationData",
        PGN: 130320,
        Description: "Tide Station Data",
        Fast: true,
        ManId: 0,
        Decoder: DecodeTideStationData,
        Instance: &TideStationData {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 4,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Mode",
            GolangType:"ResidualModeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 13,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 4,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "TideTendency",
            GolangType:"TideConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "MeasurementDate",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 32,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "MeasurementTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 32,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "StationLatitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 88,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1e-07,
            Id: "StationLongitude",
            GolangType:"*float64",
            Signed: true,
            RangeMin: -214.7483647,
            RangeMax: 214.7483645,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 120,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "TideLevel",
            GolangType:"*units.Distance",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 16,
            BitOffset: 136,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "TideLevelStandardDeviation",
            GolangType:"*units.Distance",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "StationId",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 0,
            BitOffset: 0,
            BitLengthVariable: true,
            CanboatType: "STRING_LAU",
            Resolution:1,
            Id: "StationName",
            GolangType:"string",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        },
    },
    {
        Id: "WatermakerInputSettingAndStatus",
        PGN: 130567,
        Description: "Watermaker Input Setting and Status",
        Fast: true,
        ManId: 0,
        Decoder: DecodeWatermakerInputSettingAndStatus,
        Instance: &WatermakerInputSettingAndStatus {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 6,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "WatermakerOperatingState",
            GolangType:"WatermakerStateConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 61,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 6,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ProductionStartStop",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 2,
            BitOffset: 8,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "RinseStartStop",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 2,
            BitOffset: 10,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "LowPressurePumpStatus",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 2,
            BitOffset: 12,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "HighPressurePumpStatus",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 2,
            BitOffset: 14,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "EmergencyStop",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 2,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "ProductSolenoidValveStatus",
            GolangType:"OkWarningConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 2,
            BitOffset: 18,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "FlushModeStatus",
            GolangType:"YesNoConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 2,
            BitOffset: 20,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SalinityStatus",
            GolangType:"OkWarningConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 2,
            BitOffset: 22,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SensorStatus",
            GolangType:"OkWarningConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 2,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "OilChangeIndicatorStatus",
            GolangType:"OkWarningConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 2,
            BitOffset: 26,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "FilterStatus",
            GolangType:"OkWarningConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        13: { 
            BitLength: 2,
            BitOffset: 28,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SystemStatus",
            GolangType:"OkWarningConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 13,
            },
        14: { 
            BitLength: 2,
            BitOffset: 30,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 14,
            },
        15: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Salinity",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 15,
            },
        16: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.01,
            Id: "ProductWaterTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 655.33,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 16,
            },
        17: { 
            BitLength: 16,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:100,
            Id: "PreFilterPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 17,
            },
        18: { 
            BitLength: 16,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:100,
            Id: "PostFilterPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+06,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 18,
            },
        19: { 
            BitLength: 16,
            BitOffset: 96,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1000,
            Id: "FeedPressure",
            GolangType:"*units.Pressure",
            Signed: true,
            RangeMin: -3.2767e+07,
            RangeMax: 3.2765e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 19,
            },
        20: { 
            BitLength: 16,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1000,
            Id: "SystemHighPressure",
            GolangType:"*units.Pressure",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6.5533e+07,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 20,
            },
        21: { 
            BitLength: 16,
            BitOffset: 128,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "ProductWaterFlow",
            GolangType:"*units.Flow",
            Signed: true,
            RangeMin: -3276.7,
            RangeMax: 3276.5,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 21,
            },
        22: { 
            BitLength: 16,
            BitOffset: 144,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "BrineWaterFlow",
            GolangType:"*units.Flow",
            Signed: true,
            RangeMin: -3276.7,
            RangeMax: 3276.5,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 22,
            },
        23: { 
            BitLength: 32,
            BitOffset: 160,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:1,
            Id: "RunTime",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 23,
            },
        },
    },
    {
        Id: "VesselSpeedComponents",
        PGN: 130578,
        Description: "Vessel Speed Components",
        Fast: true,
        ManId: 0,
        Decoder: DecodeVesselSpeedComponents,
        Instance: &VesselSpeedComponents {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 16,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "LongitudinalSpeedWaterReferenced",
            GolangType:"*units.Velocity",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 1,
            },
        2: { 
            BitLength: 16,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "TransverseSpeedWaterReferenced",
            GolangType:"*units.Velocity",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "LongitudinalSpeedGroundReferenced",
            GolangType:"*units.Velocity",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 3,
            },
        4: { 
            BitLength: 16,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "TransverseSpeedGroundReferenced",
            GolangType:"*units.Velocity",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 16,
            BitOffset: 64,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "SternSpeedWaterReferenced",
            GolangType:"*units.Velocity",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.001,
            Id: "SternSpeedGroundReferenced",
            GolangType:"*units.Velocity",
            Signed: true,
            RangeMin: -32.767,
            RangeMax: 32.765,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        },
    },
    {
        Id: "SonichubVolume",
        PGN: 130816,
        Description: "SonicHub: Volume",
        Fast: true,
        ManId: 275,
        Decoder: DecodeSonichubVolume,
        Instance: &SonichubVolume {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 275,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved4",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 24,
            Id: "ProprietaryId",
            GolangType:"SonichubCommandConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Control",
            GolangType:"SonichubControlConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 8,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Zone",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 8,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Level",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "MaretronProprietaryTemperatureHighRange",
        PGN: 130823,
        Description: "Maretron: Proprietary Temperature High Range",
        Fast: true,
        ManId: 137,
        Decoder: DecodeMaretronProprietaryTemperatureHighRange,
        Instance: &MaretronProprietaryTemperatureHighRange {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 137,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Sid",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 8,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "Source",
            GolangType:"TemperatureSourceConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 16,
            BitOffset: 40,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "ActualTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 16,
            BitOffset: 56,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:0.1,
            Id: "SetTemperature",
            GolangType:"*units.Temperature",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6553.3,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        },
    },
    {
        Id: "BGKeyValueData",
        PGN: 130824,
        Description: "B&G: key-value data",
        Fast: true,
        ManId: 381,
        Decoder: DecodeBGKeyValueData,
        Instance: &BGKeyValueData {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 381,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        },
    },
    {
        Id: "MaretronSwitchStatusCounter",
        PGN: 130836,
        Description: "Maretron: Switch Status Counter",
        Fast: true,
        ManId: 137,
        Decoder: DecodeMaretronSwitchStatusCounter,
        Instance: &MaretronSwitchStatusCounter {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 137,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "IndicatorNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "StartDate",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "StartTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 32,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "OffCounter",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 32,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "OnCounter",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 32,
            BitOffset: 144,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "ErrorCounter",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 2,
            BitOffset: 176,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SwitchStatus",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 6,
            BitOffset: 178,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved12",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        },
    },
    {
        Id: "MaretronSwitchStatusTimer",
        PGN: 130837,
        Description: "Maretron: Switch Status Timer",
        Fast: true,
        ManId: 137,
        Decoder: DecodeMaretronSwitchStatusTimer,
        Instance: &MaretronSwitchStatusTimer {},
        Fields: map[int]*FieldDescriptor{
        1: { 
            BitLength: 11,
            BitOffset: 0,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 137,
            Id: "ManufacturerCode",
            GolangType:"ManufacturerCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2045,
            DomainMin: 0,
            DomainMax: 0,
            Order: 1,
            },
        2: { 
            BitLength: 2,
            BitOffset: 11,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 2,
            },
        3: { 
            BitLength: 3,
            BitOffset: 13,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Match: 4,
            Id: "IndustryCode",
            GolangType:"IndustryCodeConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 6,
            DomainMin: 0,
            DomainMax: 0,
            Order: 3,
            },
        4: { 
            BitLength: 8,
            BitOffset: 16,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "Instance",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 4,
            },
        5: { 
            BitLength: 8,
            BitOffset: 24,
            BitLengthVariable: false,
            CanboatType: "NUMBER",
            Resolution:1,
            Id: "IndicatorNumber",
            GolangType:"*uint8",
            Signed: false,
            RangeMin: 0,
            RangeMax: 253,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 5,
            },
        6: { 
            BitLength: 16,
            BitOffset: 32,
            BitLengthVariable: false,
            CanboatType: "DATE",
            Resolution:1,
            Id: "StartDate",
            GolangType:"*uint16",
            Signed: false,
            RangeMin: 0,
            RangeMax: 65533,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 6,
            },
        7: { 
            BitLength: 32,
            BitOffset: 48,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:0.0001,
            Id: "StartTime",
            GolangType:"*float32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 86402,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 7,
            },
        8: { 
            BitLength: 32,
            BitOffset: 80,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:1,
            Id: "AccumulatedOffPeriod",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 8,
            },
        9: { 
            BitLength: 32,
            BitOffset: 112,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:1,
            Id: "AccumulatedOnPeriod",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 9,
            },
        10: { 
            BitLength: 32,
            BitOffset: 144,
            BitLengthVariable: false,
            CanboatType: "TIME",
            Resolution:1,
            Id: "AccumulatedErrorPeriod",
            GolangType:"*uint32",
            Signed: false,
            RangeMin: 0,
            RangeMax: 4.294967293e+09,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 10,
            },
        11: { 
            BitLength: 2,
            BitOffset: 176,
            BitLengthVariable: false,
            CanboatType: "LOOKUP",
            Resolution:1,
            Id: "SwitchStatus",
            GolangType:"OffOnConst",
            Signed: false,
            RangeMin: 0,
            RangeMax: 2,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 11,
            },
        12: { 
            BitLength: 6,
            BitOffset: 178,
            BitLengthVariable: false,
            CanboatType: "RESERVED",
            Resolution:1,
            Id: "Reserved12",
            GolangType:"",
            Signed: false,
            RangeMin: 0,
            RangeMax: 0,
            DomainMin: 0,
            DomainMax: 0, 
            Match: -1,
            Order: 12,
            },
        },
    },
}

// Build structs for each PGN

type IsoAcknowledgement struct {
    Info MessageInfo
    Control IsoControlConst
    GroupFunction *uint8
    Pgn *uint32
}
func DecodeIsoAcknowledgement(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoAcknowledgement
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAcknowledgement-Control: %w", err)
    } else {
        val.Control = IsoControlConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAcknowledgement-GroupFunction: %w", err)
    } else {
        val.GroupFunction = v
    }
    stream.skipBits(24)
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAcknowledgement-Pgn: %w", err)
    } else {
        val.Pgn = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoAcknowledgement) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.Control), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.GroupFunction, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(24, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoRequest struct {
    Info MessageInfo
    Pgn *uint32
}
func DecodeIsoRequest(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoRequest
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for IsoRequest-Pgn: %w", err)
    } else {
        val.Pgn = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoRequest) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint32(p.Pgn, 24, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoTransportProtocolDataTransfer struct {
    Info MessageInfo
    Sid *uint8
    Data []uint8
}
func DecodeIsoTransportProtocolDataTransfer(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoTransportProtocolDataTransfer
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolDataTransfer-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readBinaryData(56); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolDataTransfer-Data: %w", err)
    } else {
        val.Data = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoTransportProtocolDataTransfer) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.Data, 56, 8 )
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoTransportProtocolConnectionManagementRequestToSend struct {
    Info MessageInfo
    GroupFunctionCode IsoCommandConst
    MessageSize *uint16
    Packets *uint8
    PacketsReply *uint8
    Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementRequestToSend(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoTransportProtocolConnectionManagementRequestToSend
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-GroupFunctionCode: %w", err)
    } else {
        val.GroupFunctionCode = IsoCommandConst(v)
        if v != 16 {
            return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementRequestToSend-GroupFunctionCode: Expected %d != %d", 16, v)
        }
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-MessageSize: %w", err)
    } else {
        val.MessageSize = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-Packets: %w", err)
    } else {
        val.Packets = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-PacketsReply: %w", err)
    } else {
        val.PacketsReply = v
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-Pgn: %w", err)
    } else {
        val.Pgn = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoTransportProtocolConnectionManagementRequestToSend) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.MessageSize, 16, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Packets, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.PacketsReply, 8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoTransportProtocolConnectionManagementClearToSend struct {
    Info MessageInfo
    GroupFunctionCode IsoCommandConst
    MaxPackets *uint8
    NextSid *uint8
    Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementClearToSend(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoTransportProtocolConnectionManagementClearToSend
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-GroupFunctionCode: %w", err)
    } else {
        val.GroupFunctionCode = IsoCommandConst(v)
        if v != 17 {
            return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementClearToSend-GroupFunctionCode: Expected %d != %d", 17, v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-MaxPackets: %w", err)
    } else {
        val.MaxPackets = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-NextSid: %w", err)
    } else {
        val.NextSid = v
    }
    stream.skipBits(16)
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-Pgn: %w", err)
    } else {
        val.Pgn = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoTransportProtocolConnectionManagementClearToSend) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.MaxPackets, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NextSid, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoTransportProtocolConnectionManagementEndOfMessage struct {
    Info MessageInfo
    GroupFunctionCode IsoCommandConst
    TotalMessageSize *uint16
    TotalNumberOfFramesReceived *uint8
    Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementEndOfMessage(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoTransportProtocolConnectionManagementEndOfMessage
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-GroupFunctionCode: %w", err)
    } else {
        val.GroupFunctionCode = IsoCommandConst(v)
        if v != 19 {
            return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementEndOfMessage-GroupFunctionCode: Expected %d != %d", 19, v)
        }
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-TotalMessageSize: %w", err)
    } else {
        val.TotalMessageSize = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-TotalNumberOfFramesReceived: %w", err)
    } else {
        val.TotalNumberOfFramesReceived = v
    }
    stream.skipBits(8)
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-Pgn: %w", err)
    } else {
        val.Pgn = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoTransportProtocolConnectionManagementEndOfMessage) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.TotalMessageSize, 16, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.TotalNumberOfFramesReceived, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoTransportProtocolConnectionManagementBroadcastAnnounce struct {
    Info MessageInfo
    GroupFunctionCode IsoCommandConst
    MessageSize *uint16
    Packets *uint8
    Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementBroadcastAnnounce(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoTransportProtocolConnectionManagementBroadcastAnnounce
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-GroupFunctionCode: %w", err)
    } else {
        val.GroupFunctionCode = IsoCommandConst(v)
        if v != 32 {
            return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-GroupFunctionCode: Expected %d != %d", 32, v)
        }
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-MessageSize: %w", err)
    } else {
        val.MessageSize = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-Packets: %w", err)
    } else {
        val.Packets = v
    }
    stream.skipBits(8)
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-Pgn: %w", err)
    } else {
        val.Pgn = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoTransportProtocolConnectionManagementBroadcastAnnounce) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.MessageSize, 16, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Packets, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoTransportProtocolConnectionManagementAbort struct {
    Info MessageInfo
    GroupFunctionCode IsoCommandConst
    Reason []uint8
    Pgn *uint32
}
func DecodeIsoTransportProtocolConnectionManagementAbort(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoTransportProtocolConnectionManagementAbort
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-GroupFunctionCode: %w", err)
    } else {
        val.GroupFunctionCode = IsoCommandConst(v)
        if v != 255 {
            return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementAbort-GroupFunctionCode: Expected %d != %d", 255, v)
        }
    }
    if v, err := stream.readBinaryData(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-Reason: %w", err)
    } else {
        val.Reason = v
    }
    stream.skipBits(24)
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-Pgn: %w", err)
    } else {
        val.Pgn = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoTransportProtocolConnectionManagementAbort) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.Reason, 8, 8 )
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(24, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoAddressClaim struct {
    Info MessageInfo
    UniqueNumber *uint32
    ManufacturerCode ManufacturerCodeConst
    DeviceInstanceLower *uint8
    DeviceInstanceUpper *uint8
    DeviceFunction DeviceFunctionConst
    DeviceClass DeviceClassConst
    SystemInstance *uint8
    IndustryGroup IndustryCodeConst
    ArbitraryAddressCapable *uint8
}
func DecodeIsoAddressClaim(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoAddressClaim
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt32(21); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-UniqueNumber: %w", err)
    } else {
        val.UniqueNumber = v
    }
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
    }
    if v, err := stream.readUInt8(3); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceInstanceLower: %w", err)
    } else {
        val.DeviceInstanceLower = v
    }
    if v, err := stream.readUInt8(5); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceInstanceUpper: %w", err)
    } else {
        val.DeviceInstanceUpper = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceFunction: %w", err)
    } else {
        val.DeviceFunction = DeviceFunctionConst(v)
    }
    stream.skipBits(1)
    if v, err := stream.readLookupField(7); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceClass: %w", err)
    } else {
        val.DeviceClass = DeviceClassConst(v)
    }
    if v, err := stream.readUInt8(4); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-SystemInstance: %w", err)
    } else {
        val.SystemInstance = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-IndustryGroup: %w", err)
    } else {
        val.IndustryGroup = IndustryCodeConst(v)
    }
    if v, err := stream.readUInt8(1); err != nil {
        return nil, fmt.Errorf("parse failed for IsoAddressClaim-ArbitraryAddressCapable: %w", err)
    } else {
        val.ArbitraryAddressCapable = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoAddressClaim) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint32(p.UniqueNumber, 21, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 21)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DeviceInstanceLower, 3, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DeviceInstanceUpper, 5, 35)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DeviceFunction), 8, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(1, 48)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DeviceClass), 7, 49)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SystemInstance, 4, 56)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryGroup), 3, 60)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.ArbitraryAddressCapable, 1, 63)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Bus1PhaseCBasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
}
func DecodeBus1PhaseCBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val Bus1PhaseCBasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p Bus1PhaseCBasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Bus1PhaseBBasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
}
func DecodeBus1PhaseBBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val Bus1PhaseBBasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p Bus1PhaseBBasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Bus1PhaseABasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
}
func DecodeBus1PhaseABasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val Bus1PhaseABasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p Bus1PhaseABasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseCAcReactivePower struct {
    Info MessageInfo
    ReactivePower *uint16
    PowerFactor *float32
    PowerFactorLagging PowerFactorConst
}
func DecodeUtilityPhaseCAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseCAcReactivePower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-ReactivePower: %w", err)
    } else {
        val.ReactivePower = v
    }
    if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-PowerFactor: %w", err)
    } else {
        val.PowerFactor = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-PowerFactorLagging: %w", err)
    } else {
        val.PowerFactorLagging = PowerFactorConst(v)
    }
    stream.skipBits(30)	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseCAcReactivePower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.ReactivePower, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(30, 34)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseCAcPower struct {
    Info MessageInfo
    RealPower *float32
    ApparentPower *float32
}
func DecodeUtilityPhaseCAcPower(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseCAcPower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCAcPower-RealPower: %w", err)
    } else {
        val.RealPower = v
    }
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCAcPower-ApparentPower: %w", err)
    } else {
        val.ApparentPower = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseCAcPower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseCBasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
    AcRmsCurrent *uint16
}
func DecodeUtilityPhaseCBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseCBasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseCBasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseBAcReactivePower struct {
    Info MessageInfo
    ReactivePower *uint16
    PowerFactor *float32
    PowerFactorLagging PowerFactorConst
}
func DecodeUtilityPhaseBAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseBAcReactivePower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-ReactivePower: %w", err)
    } else {
        val.ReactivePower = v
    }
    if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-PowerFactor: %w", err)
    } else {
        val.PowerFactor = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-PowerFactorLagging: %w", err)
    } else {
        val.PowerFactorLagging = PowerFactorConst(v)
    }
    stream.skipBits(30)	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseBAcReactivePower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.ReactivePower, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(30, 34)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseBAcPower struct {
    Info MessageInfo
    RealPower *float32
    ApparentPower *float32
}
func DecodeUtilityPhaseBAcPower(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseBAcPower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBAcPower-RealPower: %w", err)
    } else {
        val.RealPower = v
    }
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBAcPower-ApparentPower: %w", err)
    } else {
        val.ApparentPower = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseBAcPower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseBBasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
    AcRmsCurrent *uint16
}
func DecodeUtilityPhaseBBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseBBasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseBBasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseAAcReactivePower struct {
    Info MessageInfo
    ReactivePower *float32
    PowerFactor *float32
    PowerFactorLagging PowerFactorConst
}
func DecodeUtilityPhaseAAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseAAcReactivePower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-ReactivePower: %w", err)
    } else {
        val.ReactivePower = v
    }
    if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-PowerFactor: %w", err)
    } else {
        val.PowerFactor = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-PowerFactorLagging: %w", err)
    } else {
        val.PowerFactorLagging = PowerFactorConst(v)
    }
    stream.skipBits(14)	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseAAcReactivePower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(14, 50)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseAAcPower struct {
    Info MessageInfo
    RealPower *float32
    ApparentPower *float32
}
func DecodeUtilityPhaseAAcPower(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseAAcPower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseAAcPower-RealPower: %w", err)
    } else {
        val.RealPower = v
    }
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseAAcPower-ApparentPower: %w", err)
    } else {
        val.ApparentPower = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseAAcPower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityPhaseABasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
    AcRmsCurrent *uint16
}
func DecodeUtilityPhaseABasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityPhaseABasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityPhaseABasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityTotalAcReactivePower struct {
    Info MessageInfo
    ReactivePower *float32
    PowerFactor *float32
    PowerFactorLagging PowerFactorConst
}
func DecodeUtilityTotalAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityTotalAcReactivePower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-ReactivePower: %w", err)
    } else {
        val.ReactivePower = v
    }
    if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-PowerFactor: %w", err)
    } else {
        val.PowerFactor = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-PowerFactorLagging: %w", err)
    } else {
        val.PowerFactorLagging = PowerFactorConst(v)
    }
    stream.skipBits(14)	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityTotalAcReactivePower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(14, 50)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityTotalAcPower struct {
    Info MessageInfo
    RealPower *float32
    ApparentPower *float32
}
func DecodeUtilityTotalAcPower(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityTotalAcPower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityTotalAcPower-RealPower: %w", err)
    } else {
        val.RealPower = v
    }
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityTotalAcPower-ApparentPower: %w", err)
    } else {
        val.ApparentPower = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityTotalAcPower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UtilityAverageBasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
    AcRmsCurrent *uint16
}
func DecodeUtilityAverageBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val UtilityAverageBasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UtilityAverageBasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseCAcReactivePower struct {
    Info MessageInfo
    ReactivePower *float32
    PowerFactor *float32
    PowerFactorLagging PowerFactorConst
}
func DecodeGeneratorPhaseCAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseCAcReactivePower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-ReactivePower: %w", err)
    } else {
        val.ReactivePower = v
    }
    if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-PowerFactor: %w", err)
    } else {
        val.PowerFactor = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-PowerFactorLagging: %w", err)
    } else {
        val.PowerFactorLagging = PowerFactorConst(v)
    }
    stream.skipBits(14)	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseCAcReactivePower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(14, 50)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseCAcPower struct {
    Info MessageInfo
    RealPower *float32
    ApparentPower *float32
}
func DecodeGeneratorPhaseCAcPower(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseCAcPower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcPower-RealPower: %w", err)
    } else {
        val.RealPower = v
    }
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcPower-ApparentPower: %w", err)
    } else {
        val.ApparentPower = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseCAcPower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseCBasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
    AcRmsCurrent *uint16
}
func DecodeGeneratorPhaseCBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseCBasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseCBasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseBAcReactivePower struct {
    Info MessageInfo
    ReactivePower *float32
    PowerFactor *float32
    PowerFactorLagging PowerFactorConst
}
func DecodeGeneratorPhaseBAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseBAcReactivePower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-ReactivePower: %w", err)
    } else {
        val.ReactivePower = v
    }
    if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-PowerFactor: %w", err)
    } else {
        val.PowerFactor = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-PowerFactorLagging: %w", err)
    } else {
        val.PowerFactorLagging = PowerFactorConst(v)
    }
    stream.skipBits(14)	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseBAcReactivePower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(14, 50)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseBAcPower struct {
    Info MessageInfo
    RealPower *float32
    ApparentPower *float32
}
func DecodeGeneratorPhaseBAcPower(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseBAcPower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcPower-RealPower: %w", err)
    } else {
        val.RealPower = v
    }
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcPower-ApparentPower: %w", err)
    } else {
        val.ApparentPower = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseBAcPower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseBBasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
    AcRmsCurrent *uint16
}
func DecodeGeneratorPhaseBBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseBBasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseBBasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseAAcReactivePower struct {
    Info MessageInfo
    ReactivePower *float32
    PowerFactor *float32
    PowerFactorLagging PowerFactorConst
}
func DecodeGeneratorPhaseAAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseAAcReactivePower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-ReactivePower: %w", err)
    } else {
        val.ReactivePower = v
    }
    if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-PowerFactor: %w", err)
    } else {
        val.PowerFactor = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-PowerFactorLagging: %w", err)
    } else {
        val.PowerFactorLagging = PowerFactorConst(v)
    }
    stream.skipBits(14)	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseAAcReactivePower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(14, 50)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseAAcPower struct {
    Info MessageInfo
    RealPower *float32
    ApparentPower *float32
}
func DecodeGeneratorPhaseAAcPower(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseAAcPower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcPower-RealPower: %w", err)
    } else {
        val.RealPower = v
    }
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcPower-ApparentPower: %w", err)
    } else {
        val.ApparentPower = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseAAcPower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorPhaseABasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
    AcRmsCurrent *uint16
}
func DecodeGeneratorPhaseABasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorPhaseABasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorPhaseABasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorTotalAcReactivePower struct {
    Info MessageInfo
    ReactivePower *float32
    PowerFactor *float32
    PowerFactorLagging PowerFactorConst
}
func DecodeGeneratorTotalAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorTotalAcReactivePower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-ReactivePower: %w", err)
    } else {
        val.ReactivePower = v
    }
    if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-PowerFactor: %w", err)
    } else {
        val.PowerFactor = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-PowerFactorLagging: %w", err)
    } else {
        val.PowerFactorLagging = PowerFactorConst(v)
    }
    stream.skipBits(14)	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorTotalAcReactivePower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(14, 50)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorTotalAcPower struct {
    Info MessageInfo
    RealPower *float32
    ApparentPower *float32
}
func DecodeGeneratorTotalAcPower(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorTotalAcPower
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorTotalAcPower-RealPower: %w", err)
    } else {
        val.RealPower = v
    }
    if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorTotalAcPower-ApparentPower: %w", err)
    } else {
        val.ApparentPower = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorTotalAcPower) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GeneratorAverageBasicAcQuantities struct {
    Info MessageInfo
    LineLineAcRmsVoltage *uint16
    LineNeutralAcRmsVoltage *uint16
    AcFrequency *float32
    AcRmsCurrent *uint16
}
func DecodeGeneratorAverageBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
    var val GeneratorAverageBasicAcQuantities
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
    } else {
        val.LineLineAcRmsVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
    } else {
        val.LineNeutralAcRmsVoltage = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-AcFrequency: %w", err)
    } else {
        val.AcFrequency = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GeneratorAverageBasicAcQuantities) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type IsoCommandedAddress struct {
    Info MessageInfo
    UniqueNumber []uint8
    ManufacturerCode ManufacturerCodeConst
    DeviceInstanceLower *uint8
    DeviceInstanceUpper *uint8
    DeviceFunction DeviceFunctionConst
    DeviceClass DeviceClassConst
    SystemInstance *uint8
    IndustryCode IndustryCodeConst
    NewSourceAddress *uint8
}
func DecodeIsoCommandedAddress(Info MessageInfo, stream *DataStream) (any, error) {
    var val IsoCommandedAddress
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readBinaryData(21); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-UniqueNumber: %w", err)
    } else {
        val.UniqueNumber = v
    }
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
    }
    if v, err := stream.readUInt8(3); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceInstanceLower: %w", err)
    } else {
        val.DeviceInstanceLower = v
    }
    if v, err := stream.readUInt8(5); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceInstanceUpper: %w", err)
    } else {
        val.DeviceInstanceUpper = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceFunction: %w", err)
    } else {
        val.DeviceFunction = DeviceFunctionConst(v)
    }
    stream.skipBits(1)
    if v, err := stream.readLookupField(7); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceClass: %w", err)
    } else {
        val.DeviceClass = DeviceClassConst(v)
    }
    if v, err := stream.readUInt8(4); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-SystemInstance: %w", err)
    } else {
        val.SystemInstance = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
    }
    stream.skipBits(1)
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for IsoCommandedAddress-NewSourceAddress: %w", err)
    } else {
        val.NewSourceAddress = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p IsoCommandedAddress) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeBinary(p.UniqueNumber, 21, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 21)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DeviceInstanceLower, 3, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DeviceInstanceUpper, 5, 35)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DeviceFunction), 8, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(1, 48)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DeviceClass), 7, 49)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SystemInstance, 4, 56)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 60)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(1, 63)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NewSourceAddress, 8, 64)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type MaretronProprietaryDcBreakerCurrent struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    BankInstance *uint8
    IndicatorNumber *uint8
    BreakerCurrent *float32
}
func DecodeMaretronProprietaryDcBreakerCurrent(Info MessageInfo, stream *DataStream) (any, error) {
    var val MaretronProprietaryDcBreakerCurrent
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 137 {
            return nil, fmt.Errorf("match failed for MaretronProprietaryDcBreakerCurrent-ManufacturerCode: Expected %d != %d", 137, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for MaretronProprietaryDcBreakerCurrent-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-BankInstance: %w", err)
    } else {
        val.BankInstance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-IndicatorNumber: %w", err)
    } else {
        val.IndicatorNumber = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-BreakerCurrent: %w", err)
    } else {
        val.BreakerCurrent = v
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p MaretronProprietaryDcBreakerCurrent) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.BankInstance, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.IndicatorNumber, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.BreakerCurrent, 16, 0.1, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarBootStateAcknowledgment struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    BootState BootStateConst
}
func DecodeAirmarBootStateAcknowledgment(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarBootStateAcknowledgment
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarBootStateAcknowledgment-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarBootStateAcknowledgment-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-BootState: %w", err)
    } else {
        val.BootState = BootStateConst(v)
    }
    stream.skipBits(45)	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarBootStateAcknowledgment) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.BootState), 3, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(45, 19)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type LowranceTemperature struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    TemperatureSource TemperatureSourceConst
    ActualTemperature *units.Temperature
}
func DecodeLowranceTemperature(Info MessageInfo, stream *DataStream) (any, error) {
    var val LowranceTemperature
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for LowranceTemperature-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 140 {
            return nil, fmt.Errorf("match failed for LowranceTemperature-ManufacturerCode: Expected %d != %d", 140, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for LowranceTemperature-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for LowranceTemperature-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for LowranceTemperature-TemperatureSource: %w", err)
    } else {
        val.TemperatureSource = TemperatureSourceConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for LowranceTemperature-ActualTemperature: %w", err)
    } else {
        val.ActualTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    stream.skipBits(24)	
    return val, nil
}

// Encode implementation for complete variant
func (p LowranceTemperature) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TemperatureSource), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.ActualTemperature, 16, 0.010000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarBootStateRequest struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
}
func DecodeAirmarBootStateRequest(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarBootStateRequest
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarBootStateRequest-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarBootStateRequest-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarBootStateRequest-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarBootStateRequest-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    stream.skipBits(48)	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarBootStateRequest) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(48, 16)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarAccessLevel struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    FormatCode *uint8
    AccessLevel AccessLevelConst
    AccessSeedKey *uint32
}
func DecodeAirmarAccessLevel(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarAccessLevel
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAccessLevel-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarAccessLevel-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAccessLevel-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarAccessLevel-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAccessLevel-FormatCode: %w", err)
    } else {
        val.FormatCode = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAccessLevel-AccessLevel: %w", err)
    } else {
        val.AccessLevel = AccessLevelConst(v)
    }
    stream.skipBits(5)
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAccessLevel-AccessSeedKey: %w", err)
    } else {
        val.AccessSeedKey = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarAccessLevel) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.FormatCode, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AccessLevel), 3, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(5, 27)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.AccessSeedKey, 32, 32)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SimnetDeviceStatus struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Model SimnetDeviceModelConst
    Report SimnetDeviceReportConst
    Status SimnetApStatusConst
}
func DecodeSimnetDeviceStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val SimnetDeviceStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 1857 {
            return nil, fmt.Errorf("match failed for SimnetDeviceStatus-ManufacturerCode: Expected %d != %d", 1857, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for SimnetDeviceStatus-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-Model: %w", err)
    } else {
        val.Model = SimnetDeviceModelConst(v)
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-Report: %w", err)
    } else {
        val.Report = SimnetDeviceReportConst(v)
        if v != 2 {
            return nil, fmt.Errorf("match failed for SimnetDeviceStatus-Report: Expected %d != %d", 2, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-Status: %w", err)
    } else {
        val.Status = SimnetApStatusConst(v)
    }
    stream.skipBits(24)	
    return val, nil
}

// Encode implementation for complete variant
func (p SimnetDeviceStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Model), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Report), 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Status), 8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SimnetDeviceStatusRequest struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Model SimnetDeviceModelConst
    Report SimnetDeviceReportConst
}
func DecodeSimnetDeviceStatusRequest(Info MessageInfo, stream *DataStream) (any, error) {
    var val SimnetDeviceStatusRequest
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatusRequest-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 1857 {
            return nil, fmt.Errorf("match failed for SimnetDeviceStatusRequest-ManufacturerCode: Expected %d != %d", 1857, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatusRequest-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for SimnetDeviceStatusRequest-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatusRequest-Model: %w", err)
    } else {
        val.Model = SimnetDeviceModelConst(v)
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceStatusRequest-Report: %w", err)
    } else {
        val.Report = SimnetDeviceReportConst(v)
        if v != 3 {
            return nil, fmt.Errorf("match failed for SimnetDeviceStatusRequest-Report: Expected %d != %d", 3, v)
        }
    }
    stream.skipBits(32)	
    return val, nil
}

// Encode implementation for complete variant
func (p SimnetDeviceStatusRequest) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Model), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Report), 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(32, 32)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SimnetPilotMode struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Model SimnetDeviceModelConst
    Report SimnetDeviceReportConst
    Mode SimnetApModeBitfieldConst
}
func DecodeSimnetPilotMode(Info MessageInfo, stream *DataStream) (any, error) {
    var val SimnetPilotMode
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetPilotMode-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 1857 {
            return nil, fmt.Errorf("match failed for SimnetPilotMode-ManufacturerCode: Expected %d != %d", 1857, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetPilotMode-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for SimnetPilotMode-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetPilotMode-Model: %w", err)
    } else {
        val.Model = SimnetDeviceModelConst(v)
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetPilotMode-Report: %w", err)
    } else {
        val.Report = SimnetDeviceReportConst(v)
        if v != 10 {
            return nil, fmt.Errorf("match failed for SimnetPilotMode-Report: Expected %d != %d", 10, v)
        }
    }
    if v, err := stream.readLookupField(16); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetPilotMode-Mode: %w", err)
    } else {
        val.Mode = SimnetApModeBitfieldConst(v)
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p SimnetPilotMode) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Model), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Report), 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Mode), 16, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SimnetDeviceModeRequest struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Model SimnetDeviceModelConst
    Report SimnetDeviceReportConst
}
func DecodeSimnetDeviceModeRequest(Info MessageInfo, stream *DataStream) (any, error) {
    var val SimnetDeviceModeRequest
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceModeRequest-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 1857 {
            return nil, fmt.Errorf("match failed for SimnetDeviceModeRequest-ManufacturerCode: Expected %d != %d", 1857, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceModeRequest-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for SimnetDeviceModeRequest-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceModeRequest-Model: %w", err)
    } else {
        val.Model = SimnetDeviceModelConst(v)
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SimnetDeviceModeRequest-Report: %w", err)
    } else {
        val.Report = SimnetDeviceReportConst(v)
        if v != 11 {
            return nil, fmt.Errorf("match failed for SimnetDeviceModeRequest-Report: Expected %d != %d", 11, v)
        }
    }
    stream.skipBits(32)	
    return val, nil
}

// Encode implementation for complete variant
func (p SimnetDeviceModeRequest) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Model), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Report), 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(32, 32)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SeatalkPilotLockedHeading struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Sid []uint8
    TargetHeadingTrue *float32
    TargetHeadingMagnetic *float32
}
func DecodeSeatalkPilotLockedHeading(Info MessageInfo, stream *DataStream) (any, error) {
    var val SeatalkPilotLockedHeading
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 1851 {
            return nil, fmt.Errorf("match failed for SeatalkPilotLockedHeading-ManufacturerCode: Expected %d != %d", 1851, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for SeatalkPilotLockedHeading-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readBinaryData(8); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-TargetHeadingTrue: %w", err)
    } else {
        val.TargetHeadingTrue = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-TargetHeadingMagnetic: %w", err)
    } else {
        val.TargetHeadingMagnetic = v
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p SeatalkPilotLockedHeading) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.Sid, 8, 16 )
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TargetHeadingTrue, 16, 0.0001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TargetHeadingMagnetic, 16, 0.0001, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SeatalkSilenceAlarm struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    AlarmId SeatalkAlarmIdConst
    AlarmGroup SeatalkAlarmGroupConst
}
func DecodeSeatalkSilenceAlarm(Info MessageInfo, stream *DataStream) (any, error) {
    var val SeatalkSilenceAlarm
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 1851 {
            return nil, fmt.Errorf("match failed for SeatalkSilenceAlarm-ManufacturerCode: Expected %d != %d", 1851, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for SeatalkSilenceAlarm-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-AlarmId: %w", err)
    } else {
        val.AlarmId = SeatalkAlarmIdConst(v)
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-AlarmGroup: %w", err)
    } else {
        val.AlarmGroup = SeatalkAlarmGroupConst(v)
    }
    stream.skipBits(32)	
    return val, nil
}

// Encode implementation for complete variant
func (p SeatalkSilenceAlarm) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AlarmId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AlarmGroup), 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(32, 32)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarSpeedPulseCount struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Sid *uint8
    DurationOfInterval *float32
    NumberOfPulsesReceived *uint16
}
func DecodeAirmarSpeedPulseCount(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarSpeedPulseCount
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarSpeedPulseCount-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarSpeedPulseCount-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-DurationOfInterval: %w", err)
    } else {
        val.DurationOfInterval = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-NumberOfPulsesReceived: %w", err)
    } else {
        val.NumberOfPulsesReceived = v
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarSpeedPulseCount) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Sid, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.DurationOfInterval, 16, 0.001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.NumberOfPulsesReceived, 16, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
type NmeaRequestGroupFunctionRepeating1 struct {
    Parameter *uint8
    Value []uint8
}

type NmeaRequestGroupFunction struct {
    Info MessageInfo
    FunctionCode GroupFunctionConst
    Pgn *uint32
    TransmissionInterval *float32
    TransmissionIntervalOffset *float32
    NumberOfParameters *uint8
    Repeating1 []NmeaRequestGroupFunctionRepeating1
}
func DecodeNmeaRequestGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
    var val NmeaRequestGroupFunction
    val.Info = Info
    var repeat1Count uint16 = 0
    var fieldIndex uint8

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-FunctionCode: %w", err)
    } else {
        val.FunctionCode = GroupFunctionConst(v)
        if v != 0 {
            return nil, fmt.Errorf("match failed for NmeaRequestGroupFunction-FunctionCode: Expected %d != %d", 0, v)
        }
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-Pgn: %w", err)
    } else {
        val.Pgn = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-TransmissionInterval: %w", err)
    } else {
        val.TransmissionInterval = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-TransmissionIntervalOffset: %w", err)
    } else {
        val.TransmissionIntervalOffset = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-NumberOfParameters: %w", err)
    } else {
        val.NumberOfParameters = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    // For PGN 126208, check if commanded PGN is proprietary or unknown
    if IsProprietaryPGN(*val.Pgn) || GetPgnInfo(*val.Pgn) == nil {
        var partial NmeaRequestGroupFunctionPartial
        partial.Info = Info
        partial.FunctionCode = val.FunctionCode
        partial.Pgn = val.Pgn
        partial.TransmissionInterval = val.TransmissionInterval
        partial.TransmissionIntervalOffset = val.TransmissionIntervalOffset
        partial.NumberOfParameters = val.NumberOfParameters
        if v, err := stream.readBinaryData(stream.remainingLength() / 8); err != nil {
            return nil, fmt.Errorf("failed to read remaining bytes: %w", err)
        } else {
            partial.RawData = v
        }
        return partial, nil
    }
    val.Repeating1 = make([]NmeaRequestGroupFunctionRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep NmeaRequestGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p NmeaRequestGroupFunction) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TransmissionInterval, 32, 0.001, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TransmissionIntervalOffset, 16, 0.01, 64, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfParameters, 8, 80)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p NmeaRequestGroupFunction) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint8(p.Repeating1[index].Parameter, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating1[index].Value, 0, 0 )
        if err != nil {
            return err
        }
    }
    return nil
}
type NmeaCommandGroupFunctionRepeating1 struct {
    Parameter *uint8
    Value []uint8
}

type NmeaCommandGroupFunction struct {
    Info MessageInfo
    FunctionCode GroupFunctionConst
    Pgn *uint32
    Priority PriorityConst
    NumberOfParameters *uint8
    Repeating1 []NmeaCommandGroupFunctionRepeating1
}
func DecodeNmeaCommandGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
    var val NmeaCommandGroupFunction
    val.Info = Info
    var repeat1Count uint16 = 0
    var fieldIndex uint8

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-FunctionCode: %w", err)
    } else {
        val.FunctionCode = GroupFunctionConst(v)
        if v != 1 {
            return nil, fmt.Errorf("match failed for NmeaCommandGroupFunction-FunctionCode: Expected %d != %d", 1, v)
        }
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Pgn: %w", err)
    } else {
        val.Pgn = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Priority: %w", err)
    } else {
        val.Priority = PriorityConst(v)
    }
    stream.skipBits(4)
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-NumberOfParameters: %w", err)
    } else {
        val.NumberOfParameters = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    // For PGN 126208, check if commanded PGN is proprietary or unknown
    if IsProprietaryPGN(*val.Pgn) || GetPgnInfo(*val.Pgn) == nil {
        var partial NmeaCommandGroupFunctionPartial
        partial.Info = Info
        partial.FunctionCode = val.FunctionCode
        partial.Pgn = val.Pgn
        partial.Priority = val.Priority
        partial.NumberOfParameters = val.NumberOfParameters
        if v, err := stream.readBinaryData(stream.remainingLength() / 8); err != nil {
            return nil, fmt.Errorf("failed to read remaining bytes: %w", err)
        } else {
            partial.RawData = v
        }
        return partial, nil
    }
    val.Repeating1 = make([]NmeaCommandGroupFunctionRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep NmeaCommandGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p NmeaCommandGroupFunction) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Priority), 4, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 36)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfParameters, 8, 40)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p NmeaCommandGroupFunction) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint8(p.Repeating1[index].Parameter, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating1[index].Value, 0, 0 )
        if err != nil {
            return err
        }
    }
    return nil
}
type NmeaAcknowledgeGroupFunctionRepeating1 struct {
    Parameter ParameterFieldConst
}

type NmeaAcknowledgeGroupFunction struct {
    Info MessageInfo
    FunctionCode GroupFunctionConst
    Pgn *uint32
    PgnErrorCode PgnErrorCodeConst
    TransmissionIntervalPriorityErrorCode TransmissionIntervalConst
    NumberOfParameters *uint8
    Repeating1 []NmeaAcknowledgeGroupFunctionRepeating1
}
func DecodeNmeaAcknowledgeGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
    var val NmeaAcknowledgeGroupFunction
    val.Info = Info
    var repeat1Count uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-FunctionCode: %w", err)
    } else {
        val.FunctionCode = GroupFunctionConst(v)
        if v != 2 {
            return nil, fmt.Errorf("match failed for NmeaAcknowledgeGroupFunction-FunctionCode: Expected %d != %d", 2, v)
        }
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-Pgn: %w", err)
    } else {
        val.Pgn = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-PgnErrorCode: %w", err)
    } else {
        val.PgnErrorCode = PgnErrorCodeConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-TransmissionIntervalPriorityErrorCode: %w", err)
    } else {
        val.TransmissionIntervalPriorityErrorCode = TransmissionIntervalConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-NumberOfParameters: %w", err)
    } else {
        val.NumberOfParameters = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    // For PGN 126208, check if commanded PGN is proprietary or unknown
    if IsProprietaryPGN(*val.Pgn) || GetPgnInfo(*val.Pgn) == nil {
        var partial NmeaAcknowledgeGroupFunctionPartial
        partial.Info = Info
        partial.FunctionCode = val.FunctionCode
        partial.Pgn = val.Pgn
        partial.PgnErrorCode = val.PgnErrorCode
        partial.TransmissionIntervalPriorityErrorCode = val.TransmissionIntervalPriorityErrorCode
        partial.NumberOfParameters = val.NumberOfParameters
        if v, err := stream.readBinaryData(stream.remainingLength() / 8); err != nil {
            return nil, fmt.Errorf("failed to read remaining bytes: %w", err)
        } else {
            partial.RawData = v
        }
        return partial, nil
    }
    val.Repeating1 = make([]NmeaAcknowledgeGroupFunctionRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep NmeaAcknowledgeGroupFunctionRepeating1
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = ParameterFieldConst(v)
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p NmeaAcknowledgeGroupFunction) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PgnErrorCode), 4, 32)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TransmissionIntervalPriorityErrorCode), 4, 36)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfParameters, 8, 40)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p NmeaAcknowledgeGroupFunction) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.putNumberRaw(uint64(p.Repeating1[index].Parameter), 4, 0)
        if err != nil {
            return err
        }
    }
    return nil
}
type NmeaReadFieldsReplyGroupFunctionRepeating1 struct {
    SelectionParameter *uint8
    SelectionValue []uint8
}
type NmeaReadFieldsReplyGroupFunctionRepeating2 struct {
    Parameter *uint8
    Value []uint8
}

type NmeaReadFieldsReplyGroupFunction struct {
    Info MessageInfo
    FunctionCode GroupFunctionConst
    Pgn *uint32
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    UniqueId *uint8
    NumberOfSelectionPairs *uint8
    NumberOfParameters *uint8
    Repeating1 []NmeaReadFieldsReplyGroupFunctionRepeating1
    Repeating2 []NmeaReadFieldsReplyGroupFunctionRepeating2
}
func DecodeNmeaReadFieldsReplyGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
    var val NmeaReadFieldsReplyGroupFunction
    val.Info = Info
    var repeat1Count uint16 = 0
    var repeat2Count uint16 = 0
    var fieldIndex uint8

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-FunctionCode: %w", err)
    } else {
        val.FunctionCode = GroupFunctionConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for NmeaReadFieldsReplyGroupFunction-FunctionCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Pgn: %w", err)
    } else {
        val.Pgn = v
    }
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-UniqueId: %w", err)
    } else {
        val.UniqueId = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-NumberOfSelectionPairs: %w", err)
    } else {
        val.NumberOfSelectionPairs = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-NumberOfParameters: %w", err)
    } else {
        val.NumberOfParameters = v
    }
    // For PGN 126208, check if commanded PGN is proprietary or unknown
    if IsProprietaryPGN(*val.Pgn) || GetPgnInfo(*val.Pgn) == nil {
        var partial NmeaReadFieldsReplyGroupFunctionPartial
        partial.Info = Info
        partial.FunctionCode = val.FunctionCode
        partial.Pgn = val.Pgn
        partial.ManufacturerCode = val.ManufacturerCode
        partial.IndustryCode = val.IndustryCode
        partial.UniqueId = val.UniqueId
        partial.NumberOfSelectionPairs = val.NumberOfSelectionPairs
        partial.NumberOfParameters = val.NumberOfParameters
        if v, err := stream.readBinaryData(stream.remainingLength() / 8); err != nil {
            return nil, fmt.Errorf("failed to read remaining bytes: %w", err)
        } else {
            partial.RawData = v
        }
        return partial, nil
    }
    val.Repeating1 = make([]NmeaReadFieldsReplyGroupFunctionRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep NmeaReadFieldsReplyGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-SelectionParameter: %w", err)
		} else {
			rep.SelectionParameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-SelectionValue: %w", err)
		} else {
			rep.SelectionValue = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaReadFieldsReplyGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaReadFieldsReplyGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
    return val, nil
}

// Encode implementation for complete variant
func (p NmeaReadFieldsReplyGroupFunction) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.UniqueId, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfSelectionPairs, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfParameters, 8, 0)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating2(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p NmeaReadFieldsReplyGroupFunction) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint8(p.Repeating1[index].SelectionParameter, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating1[index].SelectionValue, 0, 0 )
        if err != nil {
            return err
        }
    }
    return nil
}
func (p NmeaReadFieldsReplyGroupFunction) encodeRepeating2(stream *DataStream) error {
    var err error
	if len(p.Repeating2) == 0 {
		return nil
	}
    for index, _ := range p.Repeating2 {
        err = stream.writeUint8(p.Repeating2[index].Parameter, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating2[index].Value, 0, 0 )
        if err != nil {
            return err
        }
    }
    return nil
}
type NmeaWriteFieldsGroupFunctionRepeating1 struct {
    SelectionParameter *uint8
    SelectionValue []uint8
}
type NmeaWriteFieldsGroupFunctionRepeating2 struct {
    Parameter *uint8
    Value []uint8
}

type NmeaWriteFieldsGroupFunction struct {
    Info MessageInfo
    FunctionCode GroupFunctionConst
    Pgn *uint32
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    UniqueId *uint8
    NumberOfSelectionPairs *uint8
    NumberOfParameters *uint8
    Repeating1 []NmeaWriteFieldsGroupFunctionRepeating1
    Repeating2 []NmeaWriteFieldsGroupFunctionRepeating2
}
func DecodeNmeaWriteFieldsGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
    var val NmeaWriteFieldsGroupFunction
    val.Info = Info
    var repeat1Count uint16 = 0
    var repeat2Count uint16 = 0
    var fieldIndex uint8

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-FunctionCode: %w", err)
    } else {
        val.FunctionCode = GroupFunctionConst(v)
        if v != 5 {
            return nil, fmt.Errorf("match failed for NmeaWriteFieldsGroupFunction-FunctionCode: Expected %d != %d", 5, v)
        }
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Pgn: %w", err)
    } else {
        val.Pgn = v
    }
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-UniqueId: %w", err)
    } else {
        val.UniqueId = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-NumberOfSelectionPairs: %w", err)
    } else {
        val.NumberOfSelectionPairs = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-NumberOfParameters: %w", err)
    } else {
        val.NumberOfParameters = v
    }
    // For PGN 126208, check if commanded PGN is proprietary or unknown
    if IsProprietaryPGN(*val.Pgn) || GetPgnInfo(*val.Pgn) == nil {
        var partial NmeaWriteFieldsGroupFunctionPartial
        partial.Info = Info
        partial.FunctionCode = val.FunctionCode
        partial.Pgn = val.Pgn
        partial.ManufacturerCode = val.ManufacturerCode
        partial.IndustryCode = val.IndustryCode
        partial.UniqueId = val.UniqueId
        partial.NumberOfSelectionPairs = val.NumberOfSelectionPairs
        partial.NumberOfParameters = val.NumberOfParameters
        if v, err := stream.readBinaryData(stream.remainingLength() / 8); err != nil {
            return nil, fmt.Errorf("failed to read remaining bytes: %w", err)
        } else {
            partial.RawData = v
        }
        return partial, nil
    }
    val.Repeating1 = make([]NmeaWriteFieldsGroupFunctionRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep NmeaWriteFieldsGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-SelectionParameter: %w", err)
		} else {
			rep.SelectionParameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-SelectionValue: %w", err)
		} else {
			rep.SelectionValue = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaWriteFieldsGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaWriteFieldsGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
    return val, nil
}

// Encode implementation for complete variant
func (p NmeaWriteFieldsGroupFunction) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.UniqueId, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfSelectionPairs, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfParameters, 8, 0)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating2(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p NmeaWriteFieldsGroupFunction) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint8(p.Repeating1[index].SelectionParameter, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating1[index].SelectionValue, 0, 0 )
        if err != nil {
            return err
        }
    }
    return nil
}
func (p NmeaWriteFieldsGroupFunction) encodeRepeating2(stream *DataStream) error {
    var err error
	if len(p.Repeating2) == 0 {
		return nil
	}
    for index, _ := range p.Repeating2 {
        err = stream.writeUint8(p.Repeating2[index].Parameter, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating2[index].Value, 0, 0 )
        if err != nil {
            return err
        }
    }
    return nil
}
type NmeaWriteFieldsReplyGroupFunctionRepeating1 struct {
    SelectionParameter *uint8
    SelectionValue []uint8
}
type NmeaWriteFieldsReplyGroupFunctionRepeating2 struct {
    Parameter *uint8
    Value []uint8
}

type NmeaWriteFieldsReplyGroupFunction struct {
    Info MessageInfo
    FunctionCode GroupFunctionConst
    Pgn *uint32
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    UniqueId *uint8
    NumberOfSelectionPairs *uint8
    NumberOfParameters *uint8
    Repeating1 []NmeaWriteFieldsReplyGroupFunctionRepeating1
    Repeating2 []NmeaWriteFieldsReplyGroupFunctionRepeating2
}
func DecodeNmeaWriteFieldsReplyGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
    var val NmeaWriteFieldsReplyGroupFunction
    val.Info = Info
    var repeat1Count uint16 = 0
    var repeat2Count uint16 = 0
    var fieldIndex uint8

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-FunctionCode: %w", err)
    } else {
        val.FunctionCode = GroupFunctionConst(v)
        if v != 6 {
            return nil, fmt.Errorf("match failed for NmeaWriteFieldsReplyGroupFunction-FunctionCode: Expected %d != %d", 6, v)
        }
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Pgn: %w", err)
    } else {
        val.Pgn = v
    }
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-UniqueId: %w", err)
    } else {
        val.UniqueId = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-NumberOfSelectionPairs: %w", err)
    } else {
        val.NumberOfSelectionPairs = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-NumberOfParameters: %w", err)
    } else {
        val.NumberOfParameters = v
    }
    // For PGN 126208, check if commanded PGN is proprietary or unknown
    if IsProprietaryPGN(*val.Pgn) || GetPgnInfo(*val.Pgn) == nil {
        var partial NmeaWriteFieldsReplyGroupFunctionPartial
        partial.Info = Info
        partial.FunctionCode = val.FunctionCode
        partial.Pgn = val.Pgn
        partial.ManufacturerCode = val.ManufacturerCode
        partial.IndustryCode = val.IndustryCode
        partial.UniqueId = val.UniqueId
        partial.NumberOfSelectionPairs = val.NumberOfSelectionPairs
        partial.NumberOfParameters = val.NumberOfParameters
        if v, err := stream.readBinaryData(stream.remainingLength() / 8); err != nil {
            return nil, fmt.Errorf("failed to read remaining bytes: %w", err)
        } else {
            partial.RawData = v
        }
        return partial, nil
    }
    val.Repeating1 = make([]NmeaWriteFieldsReplyGroupFunctionRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep NmeaWriteFieldsReplyGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-SelectionParameter: %w", err)
		} else {
			rep.SelectionParameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-SelectionValue: %w", err)
		} else {
			rep.SelectionValue = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaWriteFieldsReplyGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaWriteFieldsReplyGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
    return val, nil
}

// Encode implementation for complete variant
func (p NmeaWriteFieldsReplyGroupFunction) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Pgn, 24, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.UniqueId, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfSelectionPairs, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfParameters, 8, 0)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating2(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p NmeaWriteFieldsReplyGroupFunction) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint8(p.Repeating1[index].SelectionParameter, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating1[index].SelectionValue, 0, 0 )
        if err != nil {
            return err
        }
    }
    return nil
}
func (p NmeaWriteFieldsReplyGroupFunction) encodeRepeating2(stream *DataStream) error {
    var err error
	if len(p.Repeating2) == 0 {
		return nil
	}
    for index, _ := range p.Repeating2 {
        err = stream.writeUint8(p.Repeating2[index].Parameter, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating2[index].Value, 0, 0 )
        if err != nil {
            return err
        }
    }
    return nil
}
type PgnListTransmitAndReceiveRepeating1 struct {
    Pgn *uint32
}

type PgnListTransmitAndReceive struct {
    Info MessageInfo
    FunctionCode PgnListFunctionConst
    Repeating1 []PgnListTransmitAndReceiveRepeating1
}
func DecodePgnListTransmitAndReceive(Info MessageInfo, stream *DataStream) (any, error) {
    var val PgnListTransmitAndReceive
    val.Info = Info
    var repeat1Count uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for PgnListTransmitAndReceive-FunctionCode: %w", err)
    } else {
        val.FunctionCode = PgnListFunctionConst(v)
    }
    val.Repeating1 = make([]PgnListTransmitAndReceiveRepeating1, 0)
    if stream.isEOF() {
        return val, nil
    }

    i := 0 
	for {
		var rep PgnListTransmitAndReceiveRepeating1
		if v, err := stream.readUInt32(24); err != nil {
			return nil, fmt.Errorf("parse failed for PgnListTransmitAndReceive-Pgn: %w", err)
		} else {
			rep.Pgn = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p PgnListTransmitAndReceive) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p PgnListTransmitAndReceive) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint32(p.Repeating1[index].Pgn, 24, 0)
        if err != nil {
            return err
        }
    }
    return nil
}

type AirmarAttitudeOffset struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    AzimuthOffset *float32
    PitchOffset *float32
    RollOffset *float32
}
func DecodeAirmarAttitudeOffset(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarAttitudeOffset
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 32 {
            return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-ProprietaryId: Expected %d != %d", 32, v)
        }
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-AzimuthOffset: %w", err)
    } else {
        val.AzimuthOffset = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-PitchOffset: %w", err)
    } else {
        val.PitchOffset = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-RollOffset: %w", err)
    } else {
        val.RollOffset = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarAttitudeOffset) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.AzimuthOffset, 16, 0.0001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.PitchOffset, 16, 0.0001, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.RollOffset, 16, 0.0001, 56, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarSimulateMode struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    SimulateMode OffOnConst
}
func DecodeAirmarSimulateMode(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarSimulateMode
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSimulateMode-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarSimulateMode-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSimulateMode-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarSimulateMode-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSimulateMode-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 35 {
            return nil, fmt.Errorf("match failed for AirmarSimulateMode-ProprietaryId: Expected %d != %d", 35, v)
        }
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSimulateMode-SimulateMode: %w", err)
    } else {
        val.SimulateMode = OffOnConst(v)
    }
    stream.skipBits(22)	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarSimulateMode) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SimulateMode), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(22, 26)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarCalibrateDepth struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    SpeedOfSoundMode *units.Velocity
}
func DecodeAirmarCalibrateDepth(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarCalibrateDepth
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 40 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-ProprietaryId: Expected %d != %d", 40, v)
        }
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-SpeedOfSoundMode: %w", err)
    } else {
        val.SpeedOfSoundMode = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarCalibrateDepth) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SpeedOfSoundMode, 16, 0.100000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
type AirmarCalibrateSpeedRepeating1 struct {
    InputFrequency *float32
    OutputSpeed *units.Velocity
}

type AirmarCalibrateSpeed struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    NumberOfPairsOfDataPoints *uint8
    Repeating1 []AirmarCalibrateSpeedRepeating1
}
func DecodeAirmarCalibrateSpeed(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarCalibrateSpeed
    val.Info = Info
    var repeat1Count uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 41 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-ProprietaryId: Expected %d != %d", 41, v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-NumberOfPairsOfDataPoints: %w", err)
    } else {
        val.NumberOfPairsOfDataPoints = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    val.Repeating1 = make([]AirmarCalibrateSpeedRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep AirmarCalibrateSpeedRepeating1
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-InputFrequency: %w", err)
		} else {
			rep.InputFrequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-OutputSpeed: %w", err)
		} else {
			rep.OutputSpeed = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarCalibrateSpeed) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfPairsOfDataPoints, 8, 24)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p AirmarCalibrateSpeed) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUnsignedResolution32(p.Repeating1[index].InputFrequency, 16, 0.1, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnit(p.Repeating1[index].OutputSpeed, 16, 0.010000, 0, 0, false)
        if err != nil {
            return err
        }
    }
    return nil
}

type AirmarCalibrateTemperature struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    TemperatureInstance AirmarTemperatureInstanceConst
    TemperatureOffset *units.Temperature
}
func DecodeAirmarCalibrateTemperature(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarCalibrateTemperature
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 42 {
            return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-ProprietaryId: Expected %d != %d", 42, v)
        }
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-TemperatureInstance: %w", err)
    } else {
        val.TemperatureInstance = AirmarTemperatureInstanceConst(v)
    }
    stream.skipBits(6)
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-TemperatureOffset: %w", err)
    } else {
        val.TemperatureOffset = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarCalibrateTemperature) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TemperatureInstance), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 26)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.TemperatureOffset, 16, 0.001000, 32, 0, true)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarSpeedFilterNone struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    FilterType *uint8
    SampleInterval *float32
}
func DecodeAirmarSpeedFilterNone(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarSpeedFilterNone
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 43 {
            return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-ProprietaryId: Expected %d != %d", 43, v)
        }
    }
    if v, err := stream.readUInt8(4); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-FilterType: %w", err)
    } else {
        val.FilterType = v
        if v != nil && *v != 0 {
            return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-FilterType: Expected %d != %d", 0, *v)
        }
    }
    stream.skipBits(4)
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-SampleInterval: %w", err)
    } else {
        val.SampleInterval = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarSpeedFilterNone) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.FilterType, 4, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 28)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.SampleInterval, 16, 0.01, 32, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarSpeedFilterIir struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    FilterType *uint8
    SampleInterval *float32
    FilterDuration *float32
}
func DecodeAirmarSpeedFilterIir(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarSpeedFilterIir
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 43 {
            return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-ProprietaryId: Expected %d != %d", 43, v)
        }
    }
    if v, err := stream.readUInt8(4); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-FilterType: %w", err)
    } else {
        val.FilterType = v
        if v != nil && *v != 1 {
            return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-FilterType: Expected %d != %d", 1, *v)
        }
    }
    stream.skipBits(4)
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-SampleInterval: %w", err)
    } else {
        val.SampleInterval = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-FilterDuration: %w", err)
    } else {
        val.FilterDuration = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarSpeedFilterIir) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.FilterType, 4, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 28)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.SampleInterval, 16, 0.01, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.FilterDuration, 16, 0.01, 48, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarTemperatureFilterNone struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    FilterType *uint8
    SampleInterval *float32
}
func DecodeAirmarTemperatureFilterNone(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarTemperatureFilterNone
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 44 {
            return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-ProprietaryId: Expected %d != %d", 44, v)
        }
    }
    if v, err := stream.readUInt8(4); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-FilterType: %w", err)
    } else {
        val.FilterType = v
        if v != nil && *v != 0 {
            return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-FilterType: Expected %d != %d", 0, *v)
        }
    }
    stream.skipBits(4)
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-SampleInterval: %w", err)
    } else {
        val.SampleInterval = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarTemperatureFilterNone) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.FilterType, 4, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 28)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.SampleInterval, 16, 0.01, 32, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarTemperatureFilterIir struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    FilterType *uint8
    SampleInterval *float32
    FilterDuration *float32
}
func DecodeAirmarTemperatureFilterIir(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarTemperatureFilterIir
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 44 {
            return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-ProprietaryId: Expected %d != %d", 44, v)
        }
    }
    if v, err := stream.readUInt8(4); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-FilterType: %w", err)
    } else {
        val.FilterType = v
        if v != nil && *v != 1 {
            return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-FilterType: Expected %d != %d", 1, *v)
        }
    }
    stream.skipBits(4)
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-SampleInterval: %w", err)
    } else {
        val.SampleInterval = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-FilterDuration: %w", err)
    } else {
        val.FilterDuration = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarTemperatureFilterIir) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.FilterType, 4, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 28)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.SampleInterval, 16, 0.01, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.FilterDuration, 16, 0.01, 48, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AirmarNmea2000Options struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId AirmarCommandConst
    TransmissionInterval AirmarTransmissionIntervalConst
}
func DecodeAirmarNmea2000Options(Info MessageInfo, stream *DataStream) (any, error) {
    var val AirmarNmea2000Options
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 135 {
            return nil, fmt.Errorf("match failed for AirmarNmea2000Options-ManufacturerCode: Expected %d != %d", 135, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for AirmarNmea2000Options-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = AirmarCommandConst(v)
        if v != 46 {
            return nil, fmt.Errorf("match failed for AirmarNmea2000Options-ProprietaryId: Expected %d != %d", 46, v)
        }
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-TransmissionInterval: %w", err)
    } else {
        val.TransmissionInterval = AirmarTransmissionIntervalConst(v)
    }
    stream.skipBits(22)	
    return val, nil
}

// Encode implementation for complete variant
func (p AirmarNmea2000Options) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TransmissionInterval), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(22, 26)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type MaretronSlaveResponse struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProductCode *uint16
    SoftwareCode *uint16
    Command *uint8
    Status *uint8
}
func DecodeMaretronSlaveResponse(Info MessageInfo, stream *DataStream) (any, error) {
    var val MaretronSlaveResponse
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 137 {
            return nil, fmt.Errorf("match failed for MaretronSlaveResponse-ManufacturerCode: Expected %d != %d", 137, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for MaretronSlaveResponse-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-ProductCode: %w", err)
    } else {
        val.ProductCode = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-SoftwareCode: %w", err)
    } else {
        val.SoftwareCode = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-Command: %w", err)
    } else {
        val.Command = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-Status: %w", err)
    } else {
        val.Status = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p MaretronSlaveResponse) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.ProductCode, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.SoftwareCode, 16, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Command, 8, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Status, 8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Alert struct {
    Info MessageInfo
    AlertType AlertTypeConst
    AlertCategory AlertCategoryConst
    AlertSystem *uint8
    AlertSubSystem *uint8
    AlertId *uint16
    DataSourceNetworkIdName *uint64
    DataSourceInstance *uint8
    DataSourceIndexSource *uint8
    AlertOccurrenceNumber *uint8
    TemporarySilenceStatus YesNoConst
    AcknowledgeStatus YesNoConst
    EscalationStatus YesNoConst
    TemporarySilenceSupport YesNoConst
    AcknowledgeSupport YesNoConst
    EscalationSupport YesNoConst
    AcknowledgeSourceNetworkIdName *uint64
    TriggerCondition AlertTriggerConditionConst
    ThresholdStatus AlertThresholdStatusConst
    AlertPriority *uint8
    AlertState AlertStateConst
}
func DecodeAlert(Info MessageInfo, stream *DataStream) (any, error) {
    var val Alert
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AlertType: %w", err)
    } else {
        val.AlertType = AlertTypeConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AlertCategory: %w", err)
    } else {
        val.AlertCategory = AlertCategoryConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AlertSystem: %w", err)
    } else {
        val.AlertSystem = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AlertSubSystem: %w", err)
    } else {
        val.AlertSubSystem = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AlertId: %w", err)
    } else {
        val.AlertId = v
    }
    if v, err := stream.readUInt64(64); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-DataSourceNetworkIdName: %w", err)
    } else {
        val.DataSourceNetworkIdName = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-DataSourceInstance: %w", err)
    } else {
        val.DataSourceInstance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-DataSourceIndexSource: %w", err)
    } else {
        val.DataSourceIndexSource = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AlertOccurrenceNumber: %w", err)
    } else {
        val.AlertOccurrenceNumber = v
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-TemporarySilenceStatus: %w", err)
    } else {
        val.TemporarySilenceStatus = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AcknowledgeStatus: %w", err)
    } else {
        val.AcknowledgeStatus = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-EscalationStatus: %w", err)
    } else {
        val.EscalationStatus = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-TemporarySilenceSupport: %w", err)
    } else {
        val.TemporarySilenceSupport = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AcknowledgeSupport: %w", err)
    } else {
        val.AcknowledgeSupport = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-EscalationSupport: %w", err)
    } else {
        val.EscalationSupport = YesNoConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readUInt64(64); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AcknowledgeSourceNetworkIdName: %w", err)
    } else {
        val.AcknowledgeSourceNetworkIdName = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-TriggerCondition: %w", err)
    } else {
        val.TriggerCondition = AlertTriggerConditionConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-ThresholdStatus: %w", err)
    } else {
        val.ThresholdStatus = AlertThresholdStatusConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AlertPriority: %w", err)
    } else {
        val.AlertPriority = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for Alert-AlertState: %w", err)
    } else {
        val.AlertState = AlertStateConst(v)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p Alert) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.AlertType), 4, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AlertCategory), 4, 4)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertSystem, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertSubSystem, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AlertId, 16, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint64(p.DataSourceNetworkIdName, 64, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DataSourceInstance, 8, 104)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DataSourceIndexSource, 8, 112)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertOccurrenceNumber, 8, 120)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TemporarySilenceStatus), 1, 128)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AcknowledgeStatus), 1, 129)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.EscalationStatus), 1, 130)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TemporarySilenceSupport), 1, 131)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AcknowledgeSupport), 1, 132)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.EscalationSupport), 1, 133)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 134)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint64(p.AcknowledgeSourceNetworkIdName, 64, 136)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TriggerCondition), 4, 200)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ThresholdStatus), 4, 204)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertPriority, 8, 208)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AlertState), 8, 216)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AlertResponse struct {
    Info MessageInfo
    AlertType AlertTypeConst
    AlertCategory AlertCategoryConst
    AlertSystem *uint8
    AlertSubSystem *uint8
    AlertId *uint16
    DataSourceNetworkIdName *uint64
    DataSourceInstance *uint8
    DataSourceIndexSource *uint8
    AlertOccurrenceNumber *uint8
    AcknowledgeSourceNetworkIdName *uint64
    ResponseCommand AlertResponseCommandConst
}
func DecodeAlertResponse(Info MessageInfo, stream *DataStream) (any, error) {
    var val AlertResponse
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-AlertType: %w", err)
    } else {
        val.AlertType = AlertTypeConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-AlertCategory: %w", err)
    } else {
        val.AlertCategory = AlertCategoryConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-AlertSystem: %w", err)
    } else {
        val.AlertSystem = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-AlertSubSystem: %w", err)
    } else {
        val.AlertSubSystem = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-AlertId: %w", err)
    } else {
        val.AlertId = v
    }
    if v, err := stream.readUInt64(64); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceNetworkIdName: %w", err)
    } else {
        val.DataSourceNetworkIdName = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceInstance: %w", err)
    } else {
        val.DataSourceInstance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceIndexSource: %w", err)
    } else {
        val.DataSourceIndexSource = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-AlertOccurrenceNumber: %w", err)
    } else {
        val.AlertOccurrenceNumber = v
    }
    if v, err := stream.readUInt64(64); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-AcknowledgeSourceNetworkIdName: %w", err)
    } else {
        val.AcknowledgeSourceNetworkIdName = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AlertResponse-ResponseCommand: %w", err)
    } else {
        val.ResponseCommand = AlertResponseCommandConst(v)
    }
    stream.skipBits(6)	
    return val, nil
}

// Encode implementation for complete variant
func (p AlertResponse) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.AlertType), 4, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AlertCategory), 4, 4)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertSystem, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertSubSystem, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AlertId, 16, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint64(p.DataSourceNetworkIdName, 64, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DataSourceInstance, 8, 104)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DataSourceIndexSource, 8, 112)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertOccurrenceNumber, 8, 120)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint64(p.AcknowledgeSourceNetworkIdName, 64, 128)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ResponseCommand), 2, 192)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 194)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AlertText struct {
    Info MessageInfo
    AlertType AlertTypeConst
    AlertCategory AlertCategoryConst
    AlertSystem *uint8
    AlertSubSystem *uint8
    AlertId *uint16
    DataSourceNetworkIdName *uint64
    DataSourceInstance *uint8
    DataSourceIndexSource *uint8
    AlertOccurrenceNumber *uint8
    LanguageId AlertLanguageIdConst
    AlertTextDescription string
    AlertLocationTextDescription string
}
func DecodeAlertText(Info MessageInfo, stream *DataStream) (any, error) {
    var val AlertText
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-AlertType: %w", err)
    } else {
        val.AlertType = AlertTypeConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-AlertCategory: %w", err)
    } else {
        val.AlertCategory = AlertCategoryConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-AlertSystem: %w", err)
    } else {
        val.AlertSystem = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-AlertSubSystem: %w", err)
    } else {
        val.AlertSubSystem = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-AlertId: %w", err)
    } else {
        val.AlertId = v
    }
    if v, err := stream.readUInt64(64); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-DataSourceNetworkIdName: %w", err)
    } else {
        val.DataSourceNetworkIdName = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-DataSourceInstance: %w", err)
    } else {
        val.DataSourceInstance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-DataSourceIndexSource: %w", err)
    } else {
        val.DataSourceIndexSource = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-AlertOccurrenceNumber: %w", err)
    } else {
        val.AlertOccurrenceNumber = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-LanguageId: %w", err)
    } else {
        val.LanguageId = AlertLanguageIdConst(v)
    }
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-AlertTextDescription: %w", err)
    } else {
        val.AlertTextDescription = v
    }
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for AlertText-AlertLocationTextDescription: %w", err)
    } else {
        val.AlertLocationTextDescription = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AlertText) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.AlertType), 4, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AlertCategory), 4, 4)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertSystem, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertSubSystem, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AlertId, 16, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint64(p.DataSourceNetworkIdName, 64, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DataSourceInstance, 8, 104)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DataSourceIndexSource, 8, 112)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AlertOccurrenceNumber, 8, 120)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.LanguageId), 8, 128)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringLau(p.AlertTextDescription, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringLau(p.AlertLocationTextDescription, 0 )
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SystemTime struct {
    Info MessageInfo
    Sid *uint8
    Source SystemTimeConst
    Date *uint16
    Time *float32
}
func DecodeSystemTime(Info MessageInfo, stream *DataStream) (any, error) {
    var val SystemTime
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for SystemTime-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for SystemTime-Source: %w", err)
    } else {
        val.Source = SystemTimeConst(v)
    }
    stream.skipBits(4)
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for SystemTime-Date: %w", err)
    } else {
        val.Date = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for SystemTime-Time: %w", err)
    } else {
        val.Time = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p SystemTime) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Source), 4, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 12)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.Date, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Time, 32, 0.0001, 32, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Heartbeat struct {
    Info MessageInfo
    DataTransmitOffset *float32
    SequenceCounter *uint8
    Controller1State ControllerStateConst
    Controller2State ControllerStateConst
    EquipmentStatus EquipmentStatusConst
}
func DecodeHeartbeat(Info MessageInfo, stream *DataStream) (any, error) {
    var val Heartbeat
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUnsignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Heartbeat-DataTransmitOffset: %w", err)
    } else {
        val.DataTransmitOffset = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Heartbeat-SequenceCounter: %w", err)
    } else {
        val.SequenceCounter = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for Heartbeat-Controller1State: %w", err)
    } else {
        val.Controller1State = ControllerStateConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for Heartbeat-Controller2State: %w", err)
    } else {
        val.Controller2State = ControllerStateConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for Heartbeat-EquipmentStatus: %w", err)
    } else {
        val.EquipmentStatus = EquipmentStatusConst(v)
    }
    stream.skipBits(34)	
    return val, nil
}

// Encode implementation for complete variant
func (p Heartbeat) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUnsignedResolution32(p.DataTransmitOffset, 16, 0.001, 0, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SequenceCounter, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Controller1State), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Controller2State), 2, 26)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.EquipmentStatus), 2, 28)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(34, 30)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ProductInformation struct {
    Info MessageInfo
    Nmea2000Version *float32
    ProductCode *uint16
    ModelId string
    SoftwareVersionCode string
    ModelVersion string
    ModelSerialCode string
    CertificationLevel *uint8
    LoadEquivalency *uint8
}
func DecodeProductInformation(Info MessageInfo, stream *DataStream) (any, error) {
    var val ProductInformation
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUnsignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ProductInformation-Nmea2000Version: %w", err)
    } else {
        val.Nmea2000Version = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for ProductInformation-ProductCode: %w", err)
    } else {
        val.ProductCode = v
    }
    if v, err := stream.readFixedString(256); err != nil {
        return nil, fmt.Errorf("parse failed for ProductInformation-ModelId: %w", err)
    } else {
        val.ModelId = v
    }
    if v, err := stream.readFixedString(256); err != nil {
        return nil, fmt.Errorf("parse failed for ProductInformation-SoftwareVersionCode: %w", err)
    } else {
        val.SoftwareVersionCode = v
    }
    if v, err := stream.readFixedString(256); err != nil {
        return nil, fmt.Errorf("parse failed for ProductInformation-ModelVersion: %w", err)
    } else {
        val.ModelVersion = v
    }
    if v, err := stream.readFixedString(256); err != nil {
        return nil, fmt.Errorf("parse failed for ProductInformation-ModelSerialCode: %w", err)
    } else {
        val.ModelSerialCode = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ProductInformation-CertificationLevel: %w", err)
    } else {
        val.CertificationLevel = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ProductInformation-LoadEquivalency: %w", err)
    } else {
        val.LoadEquivalency = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p ProductInformation) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUnsignedResolution32(p.Nmea2000Version, 16, 0.001, 0, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.ProductCode, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.ModelId), 256, 32 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.SoftwareVersionCode), 256, 288 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.ModelVersion), 256, 544 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.ModelSerialCode), 256, 800 )
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.CertificationLevel, 8, 1056)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.LoadEquivalency, 8, 1064)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ConfigurationInformation struct {
    Info MessageInfo
    InstallationDescription1 string
    InstallationDescription2 string
    ManufacturerInformation string
}
func DecodeConfigurationInformation(Info MessageInfo, stream *DataStream) (any, error) {
    var val ConfigurationInformation
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for ConfigurationInformation-InstallationDescription1: %w", err)
    } else {
        val.InstallationDescription1 = v
    }
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for ConfigurationInformation-InstallationDescription2: %w", err)
    } else {
        val.InstallationDescription2 = v
    }
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for ConfigurationInformation-ManufacturerInformation: %w", err)
    } else {
        val.ManufacturerInformation = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p ConfigurationInformation) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeStringLau(p.InstallationDescription1, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringLau(p.InstallationDescription2, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringLau(p.ManufacturerInformation, 0 )
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ManOverboardNotification struct {
    Info MessageInfo
    Sid *uint8
    MobEmitterId *uint32
    ManOverboardStatus MobStatusConst
    ActivationTime *float32
    PositionSource MobPositionSourceConst
    PositionDate *uint16
    PositionTime *float32
    Latitude *float64
    Longitude *float64
    CogReference DirectionReferenceConst
    Cog *float32
    Sog *units.Velocity
    MmsiOfVesselOfOrigin *uint32
    MobEmitterBatteryLowStatus LowBatteryConst
}
func DecodeManOverboardNotification(Info MessageInfo, stream *DataStream) (any, error) {
    var val ManOverboardNotification
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-MobEmitterId: %w", err)
    } else {
        val.MobEmitterId = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-ManOverboardStatus: %w", err)
    } else {
        val.ManOverboardStatus = MobStatusConst(v)
    }
    stream.skipBits(5)
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-ActivationTime: %w", err)
    } else {
        val.ActivationTime = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionSource: %w", err)
    } else {
        val.PositionSource = MobPositionSourceConst(v)
    }
    stream.skipBits(5)
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionDate: %w", err)
    } else {
        val.PositionDate = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionTime: %w", err)
    } else {
        val.PositionTime = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-Latitude: %w", err)
    } else {
        val.Latitude = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-Longitude: %w", err)
    } else {
        val.Longitude = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-CogReference: %w", err)
    } else {
        val.CogReference = DirectionReferenceConst(v)
    }
    stream.skipBits(6)
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-Cog: %w", err)
    } else {
        val.Cog = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-Sog: %w", err)
    } else {
        val.Sog = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-MmsiOfVesselOfOrigin: %w", err)
    } else {
        val.MmsiOfVesselOfOrigin = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for ManOverboardNotification-MobEmitterBatteryLowStatus: %w", err)
    } else {
        val.MobEmitterBatteryLowStatus = LowBatteryConst(v)
    }
    stream.skipBits(5)	
    return val, nil
}

// Encode implementation for complete variant
func (p ManOverboardNotification) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.MobEmitterId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ManOverboardStatus), 3, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(5, 43)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.ActivationTime, 32, 0.0001, 48, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PositionSource), 3, 80)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(5, 83)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.PositionDate, 16, 88)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.PositionTime, 32, 0.0001, 104, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 136, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 168, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.CogReference), 2, 200)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 202)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Cog, 16, 0.0001, 208, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Sog, 16, 0.010000, 224, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.MmsiOfVesselOfOrigin, 32, 240)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.MobEmitterBatteryLowStatus), 3, 272)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(5, 275)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type HeadingTrackControl struct {
    Info MessageInfo
    RudderLimitExceeded YesNoConst
    OffHeadingLimitExceeded YesNoConst
    OffTrackLimitExceeded YesNoConst
    Override YesNoConst
    SteeringMode SteeringModeConst
    TurnMode TurnModeConst
    HeadingReference DirectionReferenceConst
    CommandedRudderDirection DirectionRudderConst
    CommandedRudderAngle *float32
    HeadingToSteerCourse *float32
    Track *float32
    RudderLimit *float32
    OffHeadingLimit *float32
    RadiusOfTurnOrder *float32
    RateOfTurnOrder *float32
    OffTrackLimit *units.Distance
    VesselHeading *float32
}
func DecodeHeadingTrackControl(Info MessageInfo, stream *DataStream) (any, error) {
    var val HeadingTrackControl
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-RudderLimitExceeded: %w", err)
    } else {
        val.RudderLimitExceeded = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffHeadingLimitExceeded: %w", err)
    } else {
        val.OffHeadingLimitExceeded = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffTrackLimitExceeded: %w", err)
    } else {
        val.OffTrackLimitExceeded = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-Override: %w", err)
    } else {
        val.Override = YesNoConst(v)
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-SteeringMode: %w", err)
    } else {
        val.SteeringMode = SteeringModeConst(v)
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-TurnMode: %w", err)
    } else {
        val.TurnMode = TurnModeConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-HeadingReference: %w", err)
    } else {
        val.HeadingReference = DirectionReferenceConst(v)
    }
    stream.skipBits(5)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-CommandedRudderDirection: %w", err)
    } else {
        val.CommandedRudderDirection = DirectionRudderConst(v)
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-CommandedRudderAngle: %w", err)
    } else {
        val.CommandedRudderAngle = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-HeadingToSteerCourse: %w", err)
    } else {
        val.HeadingToSteerCourse = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-Track: %w", err)
    } else {
        val.Track = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-RudderLimit: %w", err)
    } else {
        val.RudderLimit = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffHeadingLimit: %w", err)
    } else {
        val.OffHeadingLimit = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-RadiusOfTurnOrder: %w", err)
    } else {
        val.RadiusOfTurnOrder = v
    }
    if v, err := stream.readSignedResolution(16, 3.125e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-RateOfTurnOrder: %w", err)
    } else {
        val.RateOfTurnOrder = v
    }
    if v, err := stream.readInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffTrackLimit: %w", err)
    } else {
        val.OffTrackLimit = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for HeadingTrackControl-VesselHeading: %w", err)
    } else {
        val.VesselHeading = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p HeadingTrackControl) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.RudderLimitExceeded), 2, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.OffHeadingLimitExceeded), 2, 2)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.OffTrackLimitExceeded), 2, 4)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Override), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SteeringMode), 3, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TurnMode), 3, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.HeadingReference), 2, 14)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(5, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.CommandedRudderDirection), 3, 21)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.CommandedRudderAngle, 16, 0.0001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.HeadingToSteerCourse, 16, 0.0001, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Track, 16, 0.0001, 56, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.RudderLimit, 16, 0.0001, 72, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.OffHeadingLimit, 16, 0.0001, 88, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.RadiusOfTurnOrder, 16, 0.0001, 104, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.RateOfTurnOrder, 16, 3.125e-05, 120, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.OffTrackLimit, 16, 1.000000, 136, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.VesselHeading, 16, 0.0001, 152, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Rudder struct {
    Info MessageInfo
    Instance *uint8
    DirectionOrder DirectionRudderConst
    AngleOrder *float32
    Position *float32
}
func DecodeRudder(Info MessageInfo, stream *DataStream) (any, error) {
    var val Rudder
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Rudder-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for Rudder-DirectionOrder: %w", err)
    } else {
        val.DirectionOrder = DirectionRudderConst(v)
    }
    stream.skipBits(5)
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Rudder-AngleOrder: %w", err)
    } else {
        val.AngleOrder = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Rudder-Position: %w", err)
    } else {
        val.Position = v
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p Rudder) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DirectionOrder), 3, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(5, 11)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.AngleOrder, 16, 0.0001, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Position, 16, 0.0001, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type VesselHeading struct {
    Info MessageInfo
    Sid *uint8
    Heading *float32
    Deviation *float32
    Variation *float32
    Reference DirectionReferenceConst
}
func DecodeVesselHeading(Info MessageInfo, stream *DataStream) (any, error) {
    var val VesselHeading
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for VesselHeading-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselHeading-Heading: %w", err)
    } else {
        val.Heading = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselHeading-Deviation: %w", err)
    } else {
        val.Deviation = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselHeading-Variation: %w", err)
    } else {
        val.Variation = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for VesselHeading-Reference: %w", err)
    } else {
        val.Reference = DirectionReferenceConst(v)
    }
    stream.skipBits(6)	
    return val, nil
}

// Encode implementation for complete variant
func (p VesselHeading) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Heading, 16, 0.0001, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Deviation, 16, 0.0001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Variation, 16, 0.0001, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Reference), 2, 56)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 58)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type RateOfTurn struct {
    Info MessageInfo
    Sid *uint8
    Rate *float64
}
func DecodeRateOfTurn(Info MessageInfo, stream *DataStream) (any, error) {
    var val RateOfTurn
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for RateOfTurn-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readSignedResolution64Override(32, 3.125e-08); err != nil {
        return nil, fmt.Errorf("parse failed for RateOfTurn-Rate: %w", err)
    } else {
        val.Rate = v
    }
    stream.skipBits(24)	
    return val, nil
}

// Encode implementation for complete variant
func (p RateOfTurn) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Rate, 32, 3.125e-08, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(24, 40)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Attitude struct {
    Info MessageInfo
    Sid *uint8
    Yaw *float32
    Pitch *float32
    Roll *float32
}
func DecodeAttitude(Info MessageInfo, stream *DataStream) (any, error) {
    var val Attitude
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Attitude-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Attitude-Yaw: %w", err)
    } else {
        val.Yaw = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Attitude-Pitch: %w", err)
    } else {
        val.Pitch = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Attitude-Roll: %w", err)
    } else {
        val.Roll = v
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p Attitude) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Yaw, 16, 0.0001, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Pitch, 16, 0.0001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Roll, 16, 0.0001, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type MagneticVariation struct {
    Info MessageInfo
    Sid *uint8
    Source MagneticVariationConst
    AgeOfService *uint16
    Variation *float32
}
func DecodeMagneticVariation(Info MessageInfo, stream *DataStream) (any, error) {
    var val MagneticVariation
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MagneticVariation-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for MagneticVariation-Source: %w", err)
    } else {
        val.Source = MagneticVariationConst(v)
    }
    stream.skipBits(4)
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for MagneticVariation-AgeOfService: %w", err)
    } else {
        val.AgeOfService = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for MagneticVariation-Variation: %w", err)
    } else {
        val.Variation = v
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p MagneticVariation) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Source), 4, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 12)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.AgeOfService, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Variation, 16, 0.0001, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type EngineParametersRapidUpdate struct {
    Info MessageInfo
    Instance EngineInstanceConst
    Speed *float32
    BoostPressure *units.Pressure
    TiltTrim *int8
}
func DecodeEngineParametersRapidUpdate(Info MessageInfo, stream *DataStream) (any, error) {
    var val EngineParametersRapidUpdate
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-Instance: %w", err)
    } else {
        val.Instance = EngineInstanceConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.25, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-Speed: %w", err)
    } else {
        val.Speed = v
    }
    if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-BoostPressure: %w", err)
    } else {
        val.BoostPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    if v, err := stream.readInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-TiltTrim: %w", err)
    } else {
        val.TiltTrim = v
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p EngineParametersRapidUpdate) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Speed, 16, 0.25, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.BoostPressure, 16, 100.000000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeInt8(p.TiltTrim, 8, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type EngineParametersDynamic struct {
    Info MessageInfo
    Instance EngineInstanceConst
    OilPressure *units.Pressure
    OilTemperature *units.Temperature
    Temperature *units.Temperature
    AlternatorPotential *float32
    FuelRate *units.Flow
    TotalEngineHours *uint32
    CoolantPressure *units.Pressure
    FuelPressure *units.Pressure
    DiscreteStatus1 EngineStatus1Const
    DiscreteStatus2 EngineStatus2Const
    EngineLoad *int8
    EngineTorque *int8
}
func DecodeEngineParametersDynamic(Info MessageInfo, stream *DataStream) (any, error) {
    var val EngineParametersDynamic
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-Instance: %w", err)
    } else {
        val.Instance = EngineInstanceConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-OilPressure: %w", err)
    } else {
        val.OilPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-OilTemperature: %w", err)
    } else {
        val.OilTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-Temperature: %w", err)
    } else {
        val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-AlternatorPotential: %w", err)
    } else {
        val.AlternatorPotential = v
    }
    if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-FuelRate: %w", err)
    } else {
        val.FuelRate = nullableUnit(units.LitersPerHour, v, units.NewFlow)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-TotalEngineHours: %w", err)
    } else {
        val.TotalEngineHours = v
    }
    if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-CoolantPressure: %w", err)
    } else {
        val.CoolantPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    if v, err := stream.readUnsignedResolution(16, 1000, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-FuelPressure: %w", err)
    } else {
        val.FuelPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    stream.skipBits(8)
    if v, err := stream.readLookupField(16); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-DiscreteStatus1: %w", err)
    } else {
        val.DiscreteStatus1 = EngineStatus1Const(v)
    }
    if v, err := stream.readLookupField(16); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-DiscreteStatus2: %w", err)
    } else {
        val.DiscreteStatus2 = EngineStatus2Const(v)
    }
    if v, err := stream.readInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-EngineLoad: %w", err)
    } else {
        val.EngineLoad = v
    }
    if v, err := stream.readInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersDynamic-EngineTorque: %w", err)
    } else {
        val.EngineTorque = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p EngineParametersDynamic) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.OilPressure, 16, 100.000000, 8, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.OilTemperature, 16, 0.100000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Temperature, 16, 0.010000, 40, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.AlternatorPotential, 16, 0.01, 56, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.FuelRate, 16, 0.100000, 72, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.TotalEngineHours, 32, 88)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.CoolantPressure, 16, 100.000000, 120, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.FuelPressure, 16, 1000.000000, 136, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 152)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DiscreteStatus1), 16, 160)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DiscreteStatus2), 16, 176)
    if err != nil {
        return nil, err
    }
    err = stream.writeInt8(p.EngineLoad, 8, 192)
    if err != nil {
        return nil, err
    }
    err = stream.writeInt8(p.EngineTorque, 8, 200)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type TransmissionParametersDynamic struct {
    Info MessageInfo
    Instance EngineInstanceConst
    TransmissionGear GearStatusConst
    OilPressure *units.Pressure
    OilTemperature *units.Temperature
    DiscreteStatus1 *uint8
}
func DecodeTransmissionParametersDynamic(Info MessageInfo, stream *DataStream) (any, error) {
    var val TransmissionParametersDynamic
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-Instance: %w", err)
    } else {
        val.Instance = EngineInstanceConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-TransmissionGear: %w", err)
    } else {
        val.TransmissionGear = GearStatusConst(v)
    }
    stream.skipBits(6)
    if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-OilPressure: %w", err)
    } else {
        val.OilPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-OilTemperature: %w", err)
    } else {
        val.OilTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-DiscreteStatus1: %w", err)
    } else {
        val.DiscreteStatus1 = v
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p TransmissionParametersDynamic) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TransmissionGear), 2, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 10)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.OilPressure, 16, 100.000000, 16, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.OilTemperature, 16, 0.100000, 32, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DiscreteStatus1, 8, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type TripParametersVessel struct {
    Info MessageInfo
    TimeToEmpty *float32
    DistanceToEmpty *units.Distance
    EstimatedFuelRemaining *units.Volume
    TripRunTime *float32
}
func DecodeTripParametersVessel(Info MessageInfo, stream *DataStream) (any, error) {
    var val TripParametersVessel
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUnsignedResolution(32, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersVessel-TimeToEmpty: %w", err)
    } else {
        val.TimeToEmpty = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersVessel-DistanceToEmpty: %w", err)
    } else {
        val.DistanceToEmpty = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersVessel-EstimatedFuelRemaining: %w", err)
    } else {
        val.EstimatedFuelRemaining = nullableUnit(units.Liter, v, units.NewVolume)
    }
    if v, err := stream.readUnsignedResolution(32, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersVessel-TripRunTime: %w", err)
    } else {
        val.TripRunTime = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p TripParametersVessel) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUnsignedResolution32(p.TimeToEmpty, 32, 0.001, 0, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.DistanceToEmpty, 32, 0.010000, 32, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.EstimatedFuelRemaining, 16, 1.000000, 64, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TripRunTime, 32, 0.001, 80, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type TripParametersEngine struct {
    Info MessageInfo
    Instance EngineInstanceConst
    TripFuelUsed *units.Volume
    FuelRateAverage *units.Flow
    FuelRateEconomy *units.Flow
    InstantaneousFuelEconomy *units.Flow
}
func DecodeTripParametersEngine(Info MessageInfo, stream *DataStream) (any, error) {
    var val TripParametersEngine
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersEngine-Instance: %w", err)
    } else {
        val.Instance = EngineInstanceConst(v)
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersEngine-TripFuelUsed: %w", err)
    } else {
        val.TripFuelUsed = nullableUnit(units.Liter, v, units.NewVolume)
    }
    if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersEngine-FuelRateAverage: %w", err)
    } else {
        val.FuelRateAverage = nullableUnit(units.LitersPerHour, v, units.NewFlow)
    }
    if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersEngine-FuelRateEconomy: %w", err)
    } else {
        val.FuelRateEconomy = nullableUnit(units.LitersPerHour, v, units.NewFlow)
    }
    if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TripParametersEngine-InstantaneousFuelEconomy: %w", err)
    } else {
        val.InstantaneousFuelEconomy = nullableUnit(units.LitersPerHour, v, units.NewFlow)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p TripParametersEngine) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.TripFuelUsed, 16, 1.000000, 8, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.FuelRateAverage, 16, 0.100000, 24, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.FuelRateEconomy, 16, 0.100000, 40, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.InstantaneousFuelEconomy, 16, 0.100000, 56, 0, true)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type EngineParametersStatic struct {
    Info MessageInfo
    Instance EngineInstanceConst
    RatedEngineSpeed *float32
    Vin string
    SoftwareId string
}
func DecodeEngineParametersStatic(Info MessageInfo, stream *DataStream) (any, error) {
    var val EngineParametersStatic
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersStatic-Instance: %w", err)
    } else {
        val.Instance = EngineInstanceConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.25, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersStatic-RatedEngineSpeed: %w", err)
    } else {
        val.RatedEngineSpeed = v
    }
    if v, err := stream.readFixedString(136); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersStatic-Vin: %w", err)
    } else {
        val.Vin = v
    }
    if v, err := stream.readFixedString(256); err != nil {
        return nil, fmt.Errorf("parse failed for EngineParametersStatic-SoftwareId: %w", err)
    } else {
        val.SoftwareId = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p EngineParametersStatic) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.RatedEngineSpeed, 16, 0.25, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.Vin), 136, 24 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.SoftwareId), 256, 160 )
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type LoadControllerConnectionStateControl struct {
    Info MessageInfo
    SequenceId *uint8
    ConnectionId *uint8
    State *uint8
    Status *uint8
    OperationalStatusControl *uint8
    PwmDutyCycle *uint8
    Timeon *uint8
    Timeoff *uint8
}
func DecodeLoadControllerConnectionStateControl(Info MessageInfo, stream *DataStream) (any, error) {
    var val LoadControllerConnectionStateControl
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-SequenceId: %w", err)
    } else {
        val.SequenceId = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-ConnectionId: %w", err)
    } else {
        val.ConnectionId = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-State: %w", err)
    } else {
        val.State = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Status: %w", err)
    } else {
        val.Status = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-OperationalStatusControl: %w", err)
    } else {
        val.OperationalStatusControl = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-PwmDutyCycle: %w", err)
    } else {
        val.PwmDutyCycle = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Timeon: %w", err)
    } else {
        val.Timeon = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Timeoff: %w", err)
    } else {
        val.Timeoff = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p LoadControllerConnectionStateControl) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.SequenceId, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.ConnectionId, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.State, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Status, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.OperationalStatusControl, 8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.PwmDutyCycle, 8, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Timeon, 8, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Timeoff, 8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type BinarySwitchBankStatus struct {
    Info MessageInfo
    Instance *uint8
    Indicator1 OffOnConst
    Indicator2 OffOnConst
    Indicator3 OffOnConst
    Indicator4 OffOnConst
    Indicator5 OffOnConst
    Indicator6 OffOnConst
    Indicator7 OffOnConst
    Indicator8 OffOnConst
    Indicator9 OffOnConst
    Indicator10 OffOnConst
    Indicator11 OffOnConst
    Indicator12 OffOnConst
    Indicator13 OffOnConst
    Indicator14 OffOnConst
    Indicator15 OffOnConst
    Indicator16 OffOnConst
    Indicator17 OffOnConst
    Indicator18 OffOnConst
    Indicator19 OffOnConst
    Indicator20 OffOnConst
    Indicator21 OffOnConst
    Indicator22 OffOnConst
    Indicator23 OffOnConst
    Indicator24 OffOnConst
    Indicator25 OffOnConst
    Indicator26 OffOnConst
    Indicator27 OffOnConst
    Indicator28 OffOnConst
}
func DecodeBinarySwitchBankStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val BinarySwitchBankStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator1: %w", err)
    } else {
        val.Indicator1 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator2: %w", err)
    } else {
        val.Indicator2 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator3: %w", err)
    } else {
        val.Indicator3 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator4: %w", err)
    } else {
        val.Indicator4 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator5: %w", err)
    } else {
        val.Indicator5 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator6: %w", err)
    } else {
        val.Indicator6 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator7: %w", err)
    } else {
        val.Indicator7 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator8: %w", err)
    } else {
        val.Indicator8 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator9: %w", err)
    } else {
        val.Indicator9 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator10: %w", err)
    } else {
        val.Indicator10 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator11: %w", err)
    } else {
        val.Indicator11 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator12: %w", err)
    } else {
        val.Indicator12 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator13: %w", err)
    } else {
        val.Indicator13 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator14: %w", err)
    } else {
        val.Indicator14 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator15: %w", err)
    } else {
        val.Indicator15 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator16: %w", err)
    } else {
        val.Indicator16 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator17: %w", err)
    } else {
        val.Indicator17 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator18: %w", err)
    } else {
        val.Indicator18 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator19: %w", err)
    } else {
        val.Indicator19 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator20: %w", err)
    } else {
        val.Indicator20 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator21: %w", err)
    } else {
        val.Indicator21 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator22: %w", err)
    } else {
        val.Indicator22 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator23: %w", err)
    } else {
        val.Indicator23 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator24: %w", err)
    } else {
        val.Indicator24 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator25: %w", err)
    } else {
        val.Indicator25 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator26: %w", err)
    } else {
        val.Indicator26 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator27: %w", err)
    } else {
        val.Indicator27 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator28: %w", err)
    } else {
        val.Indicator28 = OffOnConst(v)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p BinarySwitchBankStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator1), 2, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator2), 2, 10)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator3), 2, 12)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator4), 2, 14)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator5), 2, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator6), 2, 18)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator7), 2, 20)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator8), 2, 22)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator9), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator10), 2, 26)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator11), 2, 28)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator12), 2, 30)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator13), 2, 32)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator14), 2, 34)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator15), 2, 36)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator16), 2, 38)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator17), 2, 40)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator18), 2, 42)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator19), 2, 44)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator20), 2, 46)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator21), 2, 48)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator22), 2, 50)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator23), 2, 52)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator24), 2, 54)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator25), 2, 56)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator26), 2, 58)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator27), 2, 60)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Indicator28), 2, 62)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SwitchBankControl struct {
    Info MessageInfo
    Instance *uint8
    Switch1 OffOnConst
    Switch2 OffOnConst
    Switch3 OffOnConst
    Switch4 OffOnConst
    Switch5 OffOnConst
    Switch6 OffOnConst
    Switch7 OffOnConst
    Switch8 OffOnConst
    Switch9 OffOnConst
    Switch10 OffOnConst
    Switch11 OffOnConst
    Switch12 OffOnConst
    Switch13 OffOnConst
    Switch14 OffOnConst
    Switch15 OffOnConst
    Switch16 OffOnConst
    Switch17 OffOnConst
    Switch18 OffOnConst
    Switch19 OffOnConst
    Switch20 OffOnConst
    Switch21 OffOnConst
    Switch22 OffOnConst
    Switch23 OffOnConst
    Switch24 OffOnConst
    Switch25 OffOnConst
    Switch26 OffOnConst
    Switch27 OffOnConst
    Switch28 OffOnConst
}
func DecodeSwitchBankControl(Info MessageInfo, stream *DataStream) (any, error) {
    var val SwitchBankControl
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch1: %w", err)
    } else {
        val.Switch1 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch2: %w", err)
    } else {
        val.Switch2 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch3: %w", err)
    } else {
        val.Switch3 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch4: %w", err)
    } else {
        val.Switch4 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch5: %w", err)
    } else {
        val.Switch5 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch6: %w", err)
    } else {
        val.Switch6 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch7: %w", err)
    } else {
        val.Switch7 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch8: %w", err)
    } else {
        val.Switch8 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch9: %w", err)
    } else {
        val.Switch9 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch10: %w", err)
    } else {
        val.Switch10 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch11: %w", err)
    } else {
        val.Switch11 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch12: %w", err)
    } else {
        val.Switch12 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch13: %w", err)
    } else {
        val.Switch13 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch14: %w", err)
    } else {
        val.Switch14 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch15: %w", err)
    } else {
        val.Switch15 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch16: %w", err)
    } else {
        val.Switch16 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch17: %w", err)
    } else {
        val.Switch17 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch18: %w", err)
    } else {
        val.Switch18 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch19: %w", err)
    } else {
        val.Switch19 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch20: %w", err)
    } else {
        val.Switch20 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch21: %w", err)
    } else {
        val.Switch21 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch22: %w", err)
    } else {
        val.Switch22 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch23: %w", err)
    } else {
        val.Switch23 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch24: %w", err)
    } else {
        val.Switch24 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch25: %w", err)
    } else {
        val.Switch25 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch26: %w", err)
    } else {
        val.Switch26 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch27: %w", err)
    } else {
        val.Switch27 = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch28: %w", err)
    } else {
        val.Switch28 = OffOnConst(v)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p SwitchBankControl) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch1), 2, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch2), 2, 10)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch3), 2, 12)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch4), 2, 14)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch5), 2, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch6), 2, 18)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch7), 2, 20)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch8), 2, 22)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch9), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch10), 2, 26)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch11), 2, 28)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch12), 2, 30)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch13), 2, 32)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch14), 2, 34)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch15), 2, 36)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch16), 2, 38)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch17), 2, 40)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch18), 2, 42)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch19), 2, 44)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch20), 2, 46)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch21), 2, 48)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch22), 2, 50)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch23), 2, 52)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch24), 2, 54)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch25), 2, 56)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch26), 2, 58)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch27), 2, 60)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Switch28), 2, 62)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
type AcInputStatusRepeating1 struct {
    Line *uint8
    Acceptability AcceptabilityConst
    Voltage *float32
    Current *float32
    Frequency *float32
    BreakerSize *float32
    RealPower *uint32
    ReactivePower *uint32
    PowerFactor *float32
}

type AcInputStatus struct {
    Info MessageInfo
    Instance *uint8
    NumberOfLines *uint8
    Repeating1 []AcInputStatusRepeating1
}
func DecodeAcInputStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val AcInputStatus
    val.Info = Info
    var repeat1Count uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcInputStatus-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcInputStatus-NumberOfLines: %w", err)
    } else {
        val.NumberOfLines = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    val.Repeating1 = make([]AcInputStatusRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep AcInputStatusRepeating1
		if v, err := stream.readUInt8(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Line: %w", err)
		} else {
			rep.Line = v
		}
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Acceptability: %w", err)
		} else {
			rep.Acceptability = AcceptabilityConst(v)
		}
		stream.skipBits(4)
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Voltage: %w", err)
		} else {
			rep.Voltage = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Current: %w", err)
		} else {
			rep.Current = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Frequency: %w", err)
		} else {
			rep.Frequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-BreakerSize: %w", err)
		} else {
			rep.BreakerSize = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-RealPower: %w", err)
		} else {
			rep.RealPower = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-ReactivePower: %w", err)
		} else {
			rep.ReactivePower = v
		}
		if v, err := stream.readUnsignedResolution(8, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-PowerFactor: %w", err)
		} else {
			rep.PowerFactor = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AcInputStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfLines, 8, 8)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p AcInputStatus) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint8(p.Repeating1[index].Line, 2, 0)
        if err != nil {
            return err
        }
        err = stream.putNumberRaw(uint64(p.Repeating1[index].Acceptability), 2, 0)
        if err != nil {
            return err
        }
        err = stream.writeReserved(4, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].Voltage, 16, 0.01, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].Current, 16, 0.1, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].Frequency, 16, 0.01, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].BreakerSize, 16, 0.1, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUint32(p.Repeating1[index].RealPower, 32, 0)
        if err != nil {
            return err
        }
        err = stream.writeUint32(p.Repeating1[index].ReactivePower, 32, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].PowerFactor, 8, 0.01, 0, 0)
        if err != nil {
            return err
        }
    }
    return nil
}
type AcOutputStatusRepeating1 struct {
    Line LineConst
    Waveform WaveformConst
    Voltage *float32
    Current *float32
    Frequency *float32
    BreakerSize *float32
    RealPower *uint32
    ReactivePower *uint32
    PowerFactor *float32
}

type AcOutputStatus struct {
    Info MessageInfo
    Instance *uint8
    NumberOfLines *uint8
    Repeating1 []AcOutputStatusRepeating1
}
func DecodeAcOutputStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val AcOutputStatus
    val.Info = Info
    var repeat1Count uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcOutputStatus-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcOutputStatus-NumberOfLines: %w", err)
    } else {
        val.NumberOfLines = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    val.Repeating1 = make([]AcOutputStatusRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep AcOutputStatusRepeating1
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Line: %w", err)
		} else {
			rep.Line = LineConst(v)
		}
		if v, err := stream.readLookupField(3); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Waveform: %w", err)
		} else {
			rep.Waveform = WaveformConst(v)
		}
		stream.skipBits(3)
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Voltage: %w", err)
		} else {
			rep.Voltage = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Current: %w", err)
		} else {
			rep.Current = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Frequency: %w", err)
		} else {
			rep.Frequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-BreakerSize: %w", err)
		} else {
			rep.BreakerSize = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-RealPower: %w", err)
		} else {
			rep.RealPower = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-ReactivePower: %w", err)
		} else {
			rep.ReactivePower = v
		}
		if v, err := stream.readUnsignedResolution(8, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-PowerFactor: %w", err)
		} else {
			rep.PowerFactor = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AcOutputStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfLines, 8, 8)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p AcOutputStatus) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.putNumberRaw(uint64(p.Repeating1[index].Line), 2, 0)
        if err != nil {
            return err
        }
        err = stream.putNumberRaw(uint64(p.Repeating1[index].Waveform), 3, 0)
        if err != nil {
            return err
        }
        err = stream.writeReserved(3, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].Voltage, 16, 0.01, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].Current, 16, 0.1, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].Frequency, 16, 0.01, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].BreakerSize, 16, 0.1, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUint32(p.Repeating1[index].RealPower, 32, 0)
        if err != nil {
            return err
        }
        err = stream.writeUint32(p.Repeating1[index].ReactivePower, 32, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].PowerFactor, 8, 0.01, 0, 0)
        if err != nil {
            return err
        }
    }
    return nil
}

type FluidLevel struct {
    Info MessageInfo
    Instance *uint8
    Type TankTypeConst
    Level *float32
    Capacity *units.Volume
}
func DecodeFluidLevel(Info MessageInfo, stream *DataStream) (any, error) {
    var val FluidLevel
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(4); err != nil {
        return nil, fmt.Errorf("parse failed for FluidLevel-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for FluidLevel-Type: %w", err)
    } else {
        val.Type = TankTypeConst(v)
    }
    if v, err := stream.readSignedResolution(16, 0.004, 0); err != nil {
        return nil, fmt.Errorf("parse failed for FluidLevel-Level: %w", err)
    } else {
        val.Level = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for FluidLevel-Capacity: %w", err)
    } else {
        val.Capacity = nullableUnit(units.Liter, v, units.NewVolume)
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p FluidLevel) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 4, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Type), 4, 4)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Level, 16, 0.004, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Capacity, 32, 0.100000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type DcDetailedStatus struct {
    Info MessageInfo
    Sid *uint8
    Instance *uint8
    DcType DcSourceConst
    StateOfCharge *uint8
    StateOfHealth *uint8
    TimeRemaining *float32
    RippleVoltage *float32
    RemainingCapacity *uint16
}
func DecodeDcDetailedStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val DcDetailedStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for DcDetailedStatus-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for DcDetailedStatus-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for DcDetailedStatus-DcType: %w", err)
    } else {
        val.DcType = DcSourceConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for DcDetailedStatus-StateOfCharge: %w", err)
    } else {
        val.StateOfCharge = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for DcDetailedStatus-StateOfHealth: %w", err)
    } else {
        val.StateOfHealth = v
    }
    if v, err := stream.readUnsignedResolution(16, 60, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DcDetailedStatus-TimeRemaining: %w", err)
    } else {
        val.TimeRemaining = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DcDetailedStatus-RippleVoltage: %w", err)
    } else {
        val.RippleVoltage = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for DcDetailedStatus-RemainingCapacity: %w", err)
    } else {
        val.RemainingCapacity = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p DcDetailedStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DcType), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.StateOfCharge, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.StateOfHealth, 8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TimeRemaining, 16, 60, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.RippleVoltage, 16, 0.01, 56, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.RemainingCapacity, 16, 72)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ChargerStatus struct {
    Info MessageInfo
    Instance *uint8
    BatteryInstance *uint8
    OperatingState ChargerStateConst
    ChargeMode ChargerModeConst
    Enabled OffOnConst
    EqualizationPending OffOnConst
    EqualizationTimeRemaining *float32
}
func DecodeChargerStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val ChargerStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ChargerStatus-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ChargerStatus-BatteryInstance: %w", err)
    } else {
        val.BatteryInstance = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for ChargerStatus-OperatingState: %w", err)
    } else {
        val.OperatingState = ChargerStateConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for ChargerStatus-ChargeMode: %w", err)
    } else {
        val.ChargeMode = ChargerModeConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ChargerStatus-Enabled: %w", err)
    } else {
        val.Enabled = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ChargerStatus-EqualizationPending: %w", err)
    } else {
        val.EqualizationPending = OffOnConst(v)
    }
    stream.skipBits(4)
    if v, err := stream.readUnsignedResolution(16, 60, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ChargerStatus-EqualizationTimeRemaining: %w", err)
    } else {
        val.EqualizationTimeRemaining = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p ChargerStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.BatteryInstance, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.OperatingState), 4, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ChargeMode), 4, 20)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Enabled), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.EqualizationPending), 2, 26)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 28)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.EqualizationTimeRemaining, 16, 60, 32, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type BatteryStatus struct {
    Info MessageInfo
    Instance *uint8
    Voltage *float32
    Current *float32
    Temperature *units.Temperature
    Sid *uint8
}
func DecodeBatteryStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val BatteryStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for BatteryStatus-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for BatteryStatus-Voltage: %w", err)
    } else {
        val.Voltage = v
    }
    if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for BatteryStatus-Current: %w", err)
    } else {
        val.Current = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for BatteryStatus-Temperature: %w", err)
    } else {
        val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for BatteryStatus-Sid: %w", err)
    } else {
        val.Sid = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p BatteryStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Voltage, 16, 0.01, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Current, 16, 0.1, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Temperature, 16, 0.010000, 40, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Sid, 8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type InverterStatus struct {
    Info MessageInfo
    Instance *uint8
    AcInstance *uint8
    DcInstance *uint8
    OperatingState InverterStateConst
    InverterEnable OffOnConst
}
func DecodeInverterStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val InverterStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for InverterStatus-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for InverterStatus-AcInstance: %w", err)
    } else {
        val.AcInstance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for InverterStatus-DcInstance: %w", err)
    } else {
        val.DcInstance = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for InverterStatus-OperatingState: %w", err)
    } else {
        val.OperatingState = InverterStateConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for InverterStatus-InverterEnable: %w", err)
    } else {
        val.InverterEnable = OffOnConst(v)
    }
    stream.skipBits(2)	
    return val, nil
}

// Encode implementation for complete variant
func (p InverterStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Instance, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.AcInstance, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DcInstance, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.OperatingState), 4, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.InverterEnable), 2, 28)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 30)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AcPowerCurrentPhaseA struct {
    Info MessageInfo
    Sid *uint8
    ConnectionNumber *uint8
    AcRmsCurrent *float32
    Power *int32
}
func DecodeAcPowerCurrentPhaseA(Info MessageInfo, stream *DataStream) (any, error) {
    var val AcPowerCurrentPhaseA
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-ConnectionNumber: %w", err)
    } else {
        val.ConnectionNumber = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }
    if v, err := stream.readInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-Power: %w", err)
    } else {
        val.Power = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AcPowerCurrentPhaseA) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.ConnectionNumber, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcRmsCurrent, 16, 0.1, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeInt32(p.Power, 32, 32)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AcPowerCurrentPhaseB struct {
    Info MessageInfo
    Sid *uint8
    ConnectionNumber *uint8
    AcRmsCurrent *float32
    Power *int32
}
func DecodeAcPowerCurrentPhaseB(Info MessageInfo, stream *DataStream) (any, error) {
    var val AcPowerCurrentPhaseB
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-ConnectionNumber: %w", err)
    } else {
        val.ConnectionNumber = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }
    if v, err := stream.readInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-Power: %w", err)
    } else {
        val.Power = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AcPowerCurrentPhaseB) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.ConnectionNumber, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcRmsCurrent, 16, 0.1, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeInt32(p.Power, 32, 32)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AcPowerCurrentPhaseC struct {
    Info MessageInfo
    Sid *uint8
    ConnectionNumber *uint8
    AcRmsCurrent *float32
    Power *int32
}
func DecodeAcPowerCurrentPhaseC(Info MessageInfo, stream *DataStream) (any, error) {
    var val AcPowerCurrentPhaseC
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-ConnectionNumber: %w", err)
    } else {
        val.ConnectionNumber = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-AcRmsCurrent: %w", err)
    } else {
        val.AcRmsCurrent = v
    }
    if v, err := stream.readInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-Power: %w", err)
    } else {
        val.Power = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AcPowerCurrentPhaseC) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.ConnectionNumber, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AcRmsCurrent, 16, 0.1, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeInt32(p.Power, 32, 32)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ConverterStatus struct {
    Info MessageInfo
    Sid []uint8
    ConnectionNumber *uint8
    OperatingState ConverterStateConst
    TemperatureState GoodWarningErrorConst
    OverloadState GoodWarningErrorConst
    LowDcVoltageState GoodWarningErrorConst
    RippleState GoodWarningErrorConst
}
func DecodeConverterStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val ConverterStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readBinaryData(8); err != nil {
        return nil, fmt.Errorf("parse failed for ConverterStatus-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ConverterStatus-ConnectionNumber: %w", err)
    } else {
        val.ConnectionNumber = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for ConverterStatus-OperatingState: %w", err)
    } else {
        val.OperatingState = ConverterStateConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ConverterStatus-TemperatureState: %w", err)
    } else {
        val.TemperatureState = GoodWarningErrorConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ConverterStatus-OverloadState: %w", err)
    } else {
        val.OverloadState = GoodWarningErrorConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ConverterStatus-LowDcVoltageState: %w", err)
    } else {
        val.LowDcVoltageState = GoodWarningErrorConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ConverterStatus-RippleState: %w", err)
    } else {
        val.RippleState = GoodWarningErrorConst(v)
    }
    stream.skipBits(32)	
    return val, nil
}

// Encode implementation for complete variant
func (p ConverterStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeBinary(p.Sid, 8, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.ConnectionNumber, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.OperatingState), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TemperatureState), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.OverloadState), 2, 26)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.LowDcVoltageState), 2, 28)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RippleState), 2, 30)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(32, 32)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type DcVoltageCurrent struct {
    Info MessageInfo
    Sid []uint8
    ConnectionNumber *uint8
    DcVoltage *float32
    DcCurrent *float32
}
func DecodeDcVoltageCurrent(Info MessageInfo, stream *DataStream) (any, error) {
    var val DcVoltageCurrent
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readBinaryData(8); err != nil {
        return nil, fmt.Errorf("parse failed for DcVoltageCurrent-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for DcVoltageCurrent-ConnectionNumber: %w", err)
    } else {
        val.ConnectionNumber = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DcVoltageCurrent-DcVoltage: %w", err)
    } else {
        val.DcVoltage = v
    }
    if v, err := stream.readSignedResolution(24, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DcVoltageCurrent-DcCurrent: %w", err)
    } else {
        val.DcCurrent = v
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p DcVoltageCurrent) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeBinary(p.Sid, 8, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.ConnectionNumber, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.DcVoltage, 16, 0.1, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.DcCurrent, 24, 0.01, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type LeewayAngle struct {
    Info MessageInfo
    Sid *uint8
    LeewayAngle *float32
}
func DecodeLeewayAngle(Info MessageInfo, stream *DataStream) (any, error) {
    var val LeewayAngle
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for LeewayAngle-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for LeewayAngle-LeewayAngle: %w", err)
    } else {
        val.LeewayAngle = v
    }
    stream.skipBits(40)	
    return val, nil
}

// Encode implementation for complete variant
func (p LeewayAngle) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.LeewayAngle, 16, 0.0001, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(40, 24)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ThrusterControlStatus struct {
    Info MessageInfo
    Sid *uint8
    Identifier *uint8
    DirectionControl ThrusterDirectionControlConst
    PowerEnabled OffOnConst
    RetractControl ThrusterRetractControlConst
    SpeedControl *uint8
    ControlEvents ThrusterControlEventsConst
    CommandTimeout *float32
    AzimuthControl *float32
}
func DecodeThrusterControlStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val ThrusterControlStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-Identifier: %w", err)
    } else {
        val.Identifier = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-DirectionControl: %w", err)
    } else {
        val.DirectionControl = ThrusterDirectionControlConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-PowerEnabled: %w", err)
    } else {
        val.PowerEnabled = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-RetractControl: %w", err)
    } else {
        val.RetractControl = ThrusterRetractControlConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-SpeedControl: %w", err)
    } else {
        val.SpeedControl = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-ControlEvents: %w", err)
    } else {
        val.ControlEvents = ThrusterControlEventsConst(v)
    }
    if v, err := stream.readUnsignedResolution(8, 0.005, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-CommandTimeout: %w", err)
    } else {
        val.CommandTimeout = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterControlStatus-AzimuthControl: %w", err)
    } else {
        val.AzimuthControl = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p ThrusterControlStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Identifier, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DirectionControl), 4, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerEnabled), 2, 20)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RetractControl), 2, 22)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SpeedControl, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ControlEvents), 8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.CommandTimeout, 8, 0.005, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.AzimuthControl, 16, 0.0001, 48, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ThrusterInformation struct {
    Info MessageInfo
    Identifier *uint8
    MotorType ThrusterMotorTypeConst
    PowerRating *uint16
    MaximumTemperatureRating *units.Temperature
    MaximumRotationalSpeed *float32
}
func DecodeThrusterInformation(Info MessageInfo, stream *DataStream) (any, error) {
    var val ThrusterInformation
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterInformation-Identifier: %w", err)
    } else {
        val.Identifier = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterInformation-MotorType: %w", err)
    } else {
        val.MotorType = ThrusterMotorTypeConst(v)
    }
    stream.skipBits(4)
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterInformation-PowerRating: %w", err)
    } else {
        val.PowerRating = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterInformation-MaximumTemperatureRating: %w", err)
    } else {
        val.MaximumTemperatureRating = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 0.25, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterInformation-MaximumRotationalSpeed: %w", err)
    } else {
        val.MaximumRotationalSpeed = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p ThrusterInformation) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Identifier, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.MotorType), 4, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 12)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.PowerRating, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.MaximumTemperatureRating, 16, 0.010000, 32, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.MaximumRotationalSpeed, 16, 0.25, 48, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ThrusterMotorStatus struct {
    Info MessageInfo
    Sid *uint8
    Identifier *uint8
    MotorEvents ThrusterMotorEventsConst
    Current *uint8
    Temperature *units.Temperature
    OperatingTime *float32
}
func DecodeThrusterMotorStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val ThrusterMotorStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Identifier: %w", err)
    } else {
        val.Identifier = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-MotorEvents: %w", err)
    } else {
        val.MotorEvents = ThrusterMotorEventsConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Current: %w", err)
    } else {
        val.Current = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Temperature: %w", err)
    } else {
        val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 60, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-OperatingTime: %w", err)
    } else {
        val.OperatingTime = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p ThrusterMotorStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Identifier, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.MotorEvents), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Current, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Temperature, 16, 0.010000, 32, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.OperatingTime, 16, 60, 48, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Speed struct {
    Info MessageInfo
    Sid *uint8
    SpeedWaterReferenced *units.Velocity
    SpeedGroundReferenced *units.Velocity
    SpeedWaterReferencedType WaterReferenceConst
    SpeedDirection *uint8
}
func DecodeSpeed(Info MessageInfo, stream *DataStream) (any, error) {
    var val Speed
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Speed-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Speed-SpeedWaterReferenced: %w", err)
    } else {
        val.SpeedWaterReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Speed-SpeedGroundReferenced: %w", err)
    } else {
        val.SpeedGroundReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for Speed-SpeedWaterReferencedType: %w", err)
    } else {
        val.SpeedWaterReferencedType = WaterReferenceConst(v)
    }
    if v, err := stream.readUInt8(4); err != nil {
        return nil, fmt.Errorf("parse failed for Speed-SpeedDirection: %w", err)
    } else {
        val.SpeedDirection = v
    }
    stream.skipBits(12)	
    return val, nil
}

// Encode implementation for complete variant
func (p Speed) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SpeedWaterReferenced, 16, 0.010000, 8, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SpeedGroundReferenced, 16, 0.010000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SpeedWaterReferencedType), 8, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SpeedDirection, 4, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(12, 52)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type WaterDepth struct {
    Info MessageInfo
    Sid *uint8
    Depth *units.Distance
    Offset *units.Distance
    Range *units.Distance
}
func DecodeWaterDepth(Info MessageInfo, stream *DataStream) (any, error) {
    var val WaterDepth
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for WaterDepth-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WaterDepth-Depth: %w", err)
    } else {
        val.Depth = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WaterDepth-Offset: %w", err)
    } else {
        val.Offset = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(8, 10, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WaterDepth-Range: %w", err)
    } else {
        val.Range = nullableUnit(units.Meter, v, units.NewDistance)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p WaterDepth) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Depth, 32, 0.010000, 8, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Offset, 16, 0.001000, 40, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Range, 8, 10.000000, 56, 0, false)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type DistanceLog struct {
    Info MessageInfo
    Date *uint16
    Time *float32
    Log *units.Distance
    TripLog *units.Distance
}
func DecodeDistanceLog(Info MessageInfo, stream *DataStream) (any, error) {
    var val DistanceLog
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for DistanceLog-Date: %w", err)
    } else {
        val.Date = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DistanceLog-Time: %w", err)
    } else {
        val.Time = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for DistanceLog-Log: %w", err)
    } else {
        val.Log = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for DistanceLog-TripLog: %w", err)
    } else {
        val.TripLog = nullableUnit(units.Meter, v, units.NewDistance)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p DistanceLog) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.Date, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Time, 32, 0.0001, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Log, 32, 1.000000, 48, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.TripLog, 32, 1.000000, 80, 0, false)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type WindlassControlStatus struct {
    Info MessageInfo
    Sid *uint8
    WindlassId *uint8
    WindlassDirectionControl WindlassDirectionConst
    AnchorDockingControl OffOnConst
    SpeedControlType SpeedTypeConst
    SpeedControl []uint8
    PowerEnable OffOnConst
    MechanicalLock OffOnConst
    DeckAndAnchorWash OffOnConst
    AnchorLight OffOnConst
    CommandTimeout *float32
    WindlassControlEvents WindlassControlConst
}
func DecodeWindlassControlStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val WindlassControlStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassId: %w", err)
    } else {
        val.WindlassId = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassDirectionControl: %w", err)
    } else {
        val.WindlassDirectionControl = WindlassDirectionConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-AnchorDockingControl: %w", err)
    } else {
        val.AnchorDockingControl = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-SpeedControlType: %w", err)
    } else {
        val.SpeedControlType = SpeedTypeConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readBinaryData(8); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-SpeedControl: %w", err)
    } else {
        val.SpeedControl = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-PowerEnable: %w", err)
    } else {
        val.PowerEnable = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-MechanicalLock: %w", err)
    } else {
        val.MechanicalLock = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-DeckAndAnchorWash: %w", err)
    } else {
        val.DeckAndAnchorWash = OffOnConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-AnchorLight: %w", err)
    } else {
        val.AnchorLight = OffOnConst(v)
    }
    if v, err := stream.readUnsignedResolution(8, 0.005, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-CommandTimeout: %w", err)
    } else {
        val.CommandTimeout = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassControlEvents: %w", err)
    } else {
        val.WindlassControlEvents = WindlassControlConst(v)
    }
    stream.skipBits(12)	
    return val, nil
}

// Encode implementation for complete variant
func (p WindlassControlStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.WindlassId, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.WindlassDirectionControl), 2, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AnchorDockingControl), 2, 18)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SpeedControlType), 2, 20)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 22)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.SpeedControl, 8, 24 )
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PowerEnable), 2, 32)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.MechanicalLock), 2, 34)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DeckAndAnchorWash), 2, 36)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AnchorLight), 2, 38)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.CommandTimeout, 8, 0.005, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.WindlassControlEvents), 4, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(12, 52)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AnchorWindlassOperatingStatus struct {
    Info MessageInfo
    Sid *uint8
    WindlassId *uint8
    WindlassDirectionControl WindlassDirectionConst
    WindlassMotionStatus WindlassMotionConst
    RodeTypeStatus RodeTypeConst
    RodeCounterValue *units.Distance
    WindlassLineSpeed *units.Velocity
    AnchorDockingStatus DockingStatusConst
    WindlassOperatingEvents WindlassOperationConst
}
func DecodeAnchorWindlassOperatingStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val AnchorWindlassOperatingStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassId: %w", err)
    } else {
        val.WindlassId = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassDirectionControl: %w", err)
    } else {
        val.WindlassDirectionControl = WindlassDirectionConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassMotionStatus: %w", err)
    } else {
        val.WindlassMotionStatus = WindlassMotionConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-RodeTypeStatus: %w", err)
    } else {
        val.RodeTypeStatus = RodeTypeConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-RodeCounterValue: %w", err)
    } else {
        val.RodeCounterValue = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassLineSpeed: %w", err)
    } else {
        val.WindlassLineSpeed = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-AnchorDockingStatus: %w", err)
    } else {
        val.AnchorDockingStatus = DockingStatusConst(v)
    }
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassOperatingEvents: %w", err)
    } else {
        val.WindlassOperatingEvents = WindlassOperationConst(v)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AnchorWindlassOperatingStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.WindlassId, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.WindlassDirectionControl), 2, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.WindlassMotionStatus), 2, 18)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RodeTypeStatus), 2, 20)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 22)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.RodeCounterValue, 16, 0.100000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.WindlassLineSpeed, 16, 0.010000, 40, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AnchorDockingStatus), 2, 56)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.WindlassOperatingEvents), 6, 58)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AnchorWindlassMonitoringStatus struct {
    Info MessageInfo
    Sid *uint8
    WindlassId *uint8
    WindlassMonitoringEvents WindlassMonitoringConst
    ControllerVoltage *float32
    MotorCurrent *uint8
    TotalMotorTime *float32
}
func DecodeAnchorWindlassMonitoringStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val AnchorWindlassMonitoringStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-WindlassId: %w", err)
    } else {
        val.WindlassId = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-WindlassMonitoringEvents: %w", err)
    } else {
        val.WindlassMonitoringEvents = WindlassMonitoringConst(v)
    }
    if v, err := stream.readUnsignedResolution(8, 0.2, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-ControllerVoltage: %w", err)
    } else {
        val.ControllerVoltage = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-MotorCurrent: %w", err)
    } else {
        val.MotorCurrent = v
    }
    if v, err := stream.readUnsignedResolution(16, 60, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-TotalMotorTime: %w", err)
    } else {
        val.TotalMotorTime = v
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p AnchorWindlassMonitoringStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.WindlassId, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.WindlassMonitoringEvents), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.ControllerVoltage, 8, 0.2, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.MotorCurrent, 8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TotalMotorTime, 16, 60, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type PositionRapidUpdate struct {
    Info MessageInfo
    Latitude *float64
    Longitude *float64
}
func DecodePositionRapidUpdate(Info MessageInfo, stream *DataStream) (any, error) {
    var val PositionRapidUpdate
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for PositionRapidUpdate-Latitude: %w", err)
    } else {
        val.Latitude = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for PositionRapidUpdate-Longitude: %w", err)
    } else {
        val.Longitude = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p PositionRapidUpdate) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 0, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 32, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type CogSogRapidUpdate struct {
    Info MessageInfo
    Sid *uint8
    CogReference DirectionReferenceConst
    Cog *float32
    Sog *units.Velocity
}
func DecodeCogSogRapidUpdate(Info MessageInfo, stream *DataStream) (any, error) {
    var val CogSogRapidUpdate
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-CogReference: %w", err)
    } else {
        val.CogReference = DirectionReferenceConst(v)
    }
    stream.skipBits(6)
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Cog: %w", err)
    } else {
        val.Cog = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Sog: %w", err)
    } else {
        val.Sog = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p CogSogRapidUpdate) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.CogReference), 2, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 10)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Cog, 16, 0.0001, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Sog, 16, 0.010000, 32, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
type GnssPositionDataRepeating1 struct {
    ReferenceStationType GnsConst
    ReferenceStationId *uint16
    AgeOfDgnssCorrections *float32
}

type GnssPositionData struct {
    Info MessageInfo
    Sid *uint8
    Date *uint16
    Time *float32
    Latitude *float64
    Longitude *float64
    Altitude *units.Distance
    GnssType GnsConst
    Method GnsMethodConst
    Integrity GnsIntegrityConst
    NumberOfSvs *uint8
    Hdop *float32
    Pdop *float32
    GeoidalSeparation *units.Distance
    ReferenceStations *uint8
    Repeating1 []GnssPositionDataRepeating1
}
func DecodeGnssPositionData(Info MessageInfo, stream *DataStream) (any, error) {
    var val GnssPositionData
    val.Info = Info
    var repeat1Count uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Date: %w", err)
    } else {
        val.Date = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Time: %w", err)
    } else {
        val.Time = v
    }
    if v, err := stream.readSignedResolution64Override(64, 1e-16); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Latitude: %w", err)
    } else {
        val.Latitude = v
    }
    if v, err := stream.readSignedResolution64Override(64, 1e-16); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Longitude: %w", err)
    } else {
        val.Longitude = v
    }
    if v, err := stream.readSignedResolution(64, 1e-06, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Altitude: %w", err)
    } else {
        val.Altitude = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-GnssType: %w", err)
    } else {
        val.GnssType = GnsConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Method: %w", err)
    } else {
        val.Method = GnsMethodConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Integrity: %w", err)
    } else {
        val.Integrity = GnsIntegrityConst(v)
    }
    stream.skipBits(6)
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-NumberOfSvs: %w", err)
    } else {
        val.NumberOfSvs = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Hdop: %w", err)
    } else {
        val.Hdop = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-Pdop: %w", err)
    } else {
        val.Pdop = v
    }
    if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-GeoidalSeparation: %w", err)
    } else {
        val.GeoidalSeparation = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStations: %w", err)
    } else {
        val.ReferenceStations = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    val.Repeating1 = make([]GnssPositionDataRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep GnssPositionDataRepeating1
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStationType: %w", err)
		} else {
			rep.ReferenceStationType = GnsConst(v)
		}
		if v, err := stream.readUInt16(12); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStationId: %w", err)
		} else {
			rep.ReferenceStationId = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-AgeOfDgnssCorrections: %w", err)
		} else {
			rep.AgeOfDgnssCorrections = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GnssPositionData) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.Date, 16, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Time, 32, 0.0001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Latitude, 64, 1e-16, 56, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Longitude, 64, 1e-16, 120, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Altitude, 64, 0.000001, 184, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.GnssType), 4, 248)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Method), 4, 252)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Integrity), 2, 256)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 258)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.NumberOfSvs, 8, 264)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Hdop, 16, 0.01, 272, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Pdop, 16, 0.01, 288, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.GeoidalSeparation, 32, 0.010000, 304, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.ReferenceStations, 8, 336)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p GnssPositionData) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.putNumberRaw(uint64(p.Repeating1[index].ReferenceStationType), 4, 0)
        if err != nil {
            return err
        }
        err = stream.writeUint16(p.Repeating1[index].ReferenceStationId, 12, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].AgeOfDgnssCorrections, 16, 0.01, 0, 0)
        if err != nil {
            return err
        }
    }
    return nil
}

type TimeDate struct {
    Info MessageInfo
    Date *uint16
    Time *float32
    LocalOffset *float32
}
func DecodeTimeDate(Info MessageInfo, stream *DataStream) (any, error) {
    var val TimeDate
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for TimeDate-Date: %w", err)
    } else {
        val.Date = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TimeDate-Time: %w", err)
    } else {
        val.Time = v
    }
    if v, err := stream.readSignedResolution(16, 60, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TimeDate-LocalOffset: %w", err)
    } else {
        val.LocalOffset = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p TimeDate) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.Date, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Time, 32, 0.0001, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.LocalOffset, 16, 60, 48, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisClassAPositionReport struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    UserId *uint32
    Longitude *float64
    Latitude *float64
    PositionAccuracy PositionAccuracyConst
    Raim RaimFlagConst
    TimeStamp TimeStampConst
    Cog *float32
    Sog *units.Velocity
    CommunicationState []uint8
    AisTransceiverInformation AisTransceiverConst
    Heading *float32
    RateOfTurn *float32
    NavStatus NavStatusConst
    SpecialManeuverIndicator AisSpecialManeuverConst
    SequenceId *uint8
}
func DecodeAisClassAPositionReport(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisClassAPositionReport
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-UserId: %w", err)
    } else {
        val.UserId = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Longitude: %w", err)
    } else {
        val.Longitude = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Latitude: %w", err)
    } else {
        val.Latitude = v
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-PositionAccuracy: %w", err)
    } else {
        val.PositionAccuracy = PositionAccuracyConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Raim: %w", err)
    } else {
        val.Raim = RaimFlagConst(v)
    }
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-TimeStamp: %w", err)
    } else {
        val.TimeStamp = TimeStampConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Cog: %w", err)
    } else {
        val.Cog = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Sog: %w", err)
    } else {
        val.Sog = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readBinaryData(19); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-CommunicationState: %w", err)
    } else {
        val.CommunicationState = v
    }
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Heading: %w", err)
    } else {
        val.Heading = v
    }
    if v, err := stream.readSignedResolution(16, 3.125e-05, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-RateOfTurn: %w", err)
    } else {
        val.RateOfTurn = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-NavStatus: %w", err)
    } else {
        val.NavStatus = NavStatusConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-SpecialManeuverIndicator: %w", err)
    } else {
        val.SpecialManeuverIndicator = AisSpecialManeuverConst(v)
    }
    stream.skipBits(2)
    stream.skipBits(3)
    stream.skipBits(5)
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAPositionReport-SequenceId: %w", err)
    } else {
        val.SequenceId = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AisClassAPositionReport) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.UserId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 72, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PositionAccuracy), 1, 104)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Raim), 1, 105)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TimeStamp), 6, 106)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Cog, 16, 0.0001, 112, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Sog, 16, 0.010000, 128, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.CommunicationState, 19, 144 )
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 163)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Heading, 16, 0.0001, 168, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.RateOfTurn, 16, 3.125e-05, 184, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.NavStatus), 4, 200)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SpecialManeuverIndicator), 2, 204)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 206)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(3, 208)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(5, 211)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SequenceId, 8, 216)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisClassBPositionReport struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    UserId *uint32
    Longitude *float64
    Latitude *float64
    PositionAccuracy PositionAccuracyConst
    Raim RaimFlagConst
    TimeStamp TimeStampConst
    Cog *float32
    Sog *units.Velocity
    CommunicationState []uint8
    AisTransceiverInformation AisTransceiverConst
    Heading *float32
    UnitType AisTypeConst
    IntegratedDisplay YesNoConst
    Dsc YesNoConst
    Band AisBandConst
    CanHandleMsg22 YesNoConst
    AisMode AisModeConst
    AisCommunicationState AisCommunicationStateConst
}
func DecodeAisClassBPositionReport(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisClassBPositionReport
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-UserId: %w", err)
    } else {
        val.UserId = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Longitude: %w", err)
    } else {
        val.Longitude = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Latitude: %w", err)
    } else {
        val.Latitude = v
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-PositionAccuracy: %w", err)
    } else {
        val.PositionAccuracy = PositionAccuracyConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Raim: %w", err)
    } else {
        val.Raim = RaimFlagConst(v)
    }
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-TimeStamp: %w", err)
    } else {
        val.TimeStamp = TimeStampConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Cog: %w", err)
    } else {
        val.Cog = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Sog: %w", err)
    } else {
        val.Sog = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readBinaryData(19); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-CommunicationState: %w", err)
    } else {
        val.CommunicationState = v
    }
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Heading: %w", err)
    } else {
        val.Heading = v
    }
    stream.skipBits(8)
    stream.skipBits(2)
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-UnitType: %w", err)
    } else {
        val.UnitType = AisTypeConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-IntegratedDisplay: %w", err)
    } else {
        val.IntegratedDisplay = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Dsc: %w", err)
    } else {
        val.Dsc = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Band: %w", err)
    } else {
        val.Band = AisBandConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-CanHandleMsg22: %w", err)
    } else {
        val.CanHandleMsg22 = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisMode: %w", err)
    } else {
        val.AisMode = AisModeConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisCommunicationState: %w", err)
    } else {
        val.AisCommunicationState = AisCommunicationStateConst(v)
    }
    stream.skipBits(15)	
    return val, nil
}

// Encode implementation for complete variant
func (p AisClassBPositionReport) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.UserId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 72, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PositionAccuracy), 1, 104)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Raim), 1, 105)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TimeStamp), 6, 106)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Cog, 16, 0.0001, 112, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Sog, 16, 0.010000, 128, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.CommunicationState, 19, 144 )
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 163)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Heading, 16, 0.0001, 168, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(8, 184)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(2, 192)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.UnitType), 1, 194)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IntegratedDisplay), 1, 195)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Dsc), 1, 196)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Band), 1, 197)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.CanHandleMsg22), 1, 198)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisMode), 1, 199)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisCommunicationState), 1, 200)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(15, 201)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisAidsToNavigationAtonReport struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    UserId *uint32
    Longitude *float64
    Latitude *float64
    PositionAccuracy PositionAccuracyConst
    Raim RaimFlagConst
    TimeStamp TimeStampConst
    LengthDiameter *units.Distance
    BeamDiameter *units.Distance
    PositionReferenceFromStarboardEdge *units.Distance
    PositionReferenceFromTrueNorthFacingEdge *units.Distance
    AtonType AtonTypeConst
    OffPositionIndicator YesNoConst
    VirtualAtonFlag YesNoConst
    AssignedModeFlag AisAssignedModeConst
    PositionFixingDeviceType PositionFixDeviceConst
    AtonStatus []uint8
    AisTransceiverInformation AisTransceiverConst
    AtonName string
}
func DecodeAisAidsToNavigationAtonReport(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisAidsToNavigationAtonReport
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-UserId: %w", err)
    } else {
        val.UserId = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Longitude: %w", err)
    } else {
        val.Longitude = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Latitude: %w", err)
    } else {
        val.Latitude = v
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionAccuracy: %w", err)
    } else {
        val.PositionAccuracy = PositionAccuracyConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Raim: %w", err)
    } else {
        val.Raim = RaimFlagConst(v)
    }
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-TimeStamp: %w", err)
    } else {
        val.TimeStamp = TimeStampConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-LengthDiameter: %w", err)
    } else {
        val.LengthDiameter = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-BeamDiameter: %w", err)
    } else {
        val.BeamDiameter = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionReferenceFromStarboardEdge: %w", err)
    } else {
        val.PositionReferenceFromStarboardEdge = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionReferenceFromTrueNorthFacingEdge: %w", err)
    } else {
        val.PositionReferenceFromTrueNorthFacingEdge = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonType: %w", err)
    } else {
        val.AtonType = AtonTypeConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-OffPositionIndicator: %w", err)
    } else {
        val.OffPositionIndicator = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-VirtualAtonFlag: %w", err)
    } else {
        val.VirtualAtonFlag = YesNoConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AssignedModeFlag: %w", err)
    } else {
        val.AssignedModeFlag = AisAssignedModeConst(v)
    }
    stream.skipBits(1)
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionFixingDeviceType: %w", err)
    } else {
        val.PositionFixingDeviceType = PositionFixDeviceConst(v)
    }
    stream.skipBits(3)
    if v, err := stream.readBinaryData(8); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonStatus: %w", err)
    } else {
        val.AtonStatus = v
    }
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    stream.skipBits(3)
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonName: %w", err)
    } else {
        val.AtonName = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AisAidsToNavigationAtonReport) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.UserId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 72, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PositionAccuracy), 1, 104)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Raim), 1, 105)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TimeStamp), 6, 106)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.LengthDiameter, 16, 0.100000, 112, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.BeamDiameter, 16, 0.100000, 128, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.PositionReferenceFromStarboardEdge, 16, 0.100000, 144, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.PositionReferenceFromTrueNorthFacingEdge, 16, 0.100000, 160, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AtonType), 5, 176)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.OffPositionIndicator), 1, 181)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.VirtualAtonFlag), 1, 182)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AssignedModeFlag), 1, 183)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(1, 184)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PositionFixingDeviceType), 4, 185)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(3, 189)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.AtonStatus, 8, 192 )
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 200)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(3, 205)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringLau(p.AtonName, 0 )
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Datum struct {
    Info MessageInfo
    LocalDatum string
    DeltaLatitude *float64
    DeltaLongitude *float64
    DeltaAltitude *units.Distance
    ReferenceDatum string
}
func DecodeDatum(Info MessageInfo, stream *DataStream) (any, error) {
    var val Datum
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readFixedString(32); err != nil {
        return nil, fmt.Errorf("parse failed for Datum-LocalDatum: %w", err)
    } else {
        val.LocalDatum = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for Datum-DeltaLatitude: %w", err)
    } else {
        val.DeltaLatitude = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for Datum-DeltaLongitude: %w", err)
    } else {
        val.DeltaLongitude = v
    }
    if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Datum-DeltaAltitude: %w", err)
    } else {
        val.DeltaAltitude = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readFixedString(32); err != nil {
        return nil, fmt.Errorf("parse failed for Datum-ReferenceDatum: %w", err)
    } else {
        val.ReferenceDatum = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p Datum) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeStringFix([]uint8(p.LocalDatum), 32, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.DeltaLatitude, 32, 1e-07, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.DeltaLongitude, 32, 1e-07, 64, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.DeltaAltitude, 32, 0.010000, 96, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.ReferenceDatum), 32, 128 )
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type UserDatum struct {
    Info MessageInfo
    DeltaX *units.Distance
    DeltaY *units.Distance
    DeltaZ *units.Distance
    RotationInX *float32
    RotationInY *float32
    RotationInZ *float32
    Scale *float32
    EllipsoidSemiMajorAxis *units.Distance
    EllipsoidFlatteningInverse *float32
    DatumName string
}
func DecodeUserDatum(Info MessageInfo, stream *DataStream) (any, error) {
    var val UserDatum
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-DeltaX: %w", err)
    } else {
        val.DeltaX = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-DeltaY: %w", err)
    } else {
        val.DeltaY = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-DeltaZ: %w", err)
    } else {
        val.DeltaZ = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readFloat32(); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-RotationInX: %w", err)
    } else {
        val.RotationInX = v
    }
    if v, err := stream.readFloat32(); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-RotationInY: %w", err)
    } else {
        val.RotationInY = v
    }
    if v, err := stream.readFloat32(); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-RotationInZ: %w", err)
    } else {
        val.RotationInZ = v
    }
    if v, err := stream.readFloat32(); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-Scale: %w", err)
    } else {
        val.Scale = v
    }
    if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-EllipsoidSemiMajorAxis: %w", err)
    } else {
        val.EllipsoidSemiMajorAxis = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readFloat32(); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-EllipsoidFlatteningInverse: %w", err)
    } else {
        val.EllipsoidFlatteningInverse = v
    }
    if v, err := stream.readFixedString(32); err != nil {
        return nil, fmt.Errorf("parse failed for UserDatum-DatumName: %w", err)
    } else {
        val.DatumName = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p UserDatum) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUnit(p.DeltaX, 32, 0.010000, 0, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.DeltaY, 32, 0.010000, 32, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.DeltaZ, 32, 0.010000, 64, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeFloat32(p.RotationInX, 32, 96)
    if err != nil {
        return nil, err
    }
    err = stream.writeFloat32(p.RotationInY, 32, 128)
    if err != nil {
        return nil, err
    }
    err = stream.writeFloat32(p.RotationInZ, 32, 160)
    if err != nil {
        return nil, err
    }
    err = stream.writeFloat32(p.Scale, 32, 192)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.EllipsoidSemiMajorAxis, 32, 0.010000, 224, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeFloat32(p.EllipsoidFlatteningInverse, 32, 256)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.DatumName), 32, 288 )
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type CrossTrackError struct {
    Info MessageInfo
    Sid *uint8
    XteMode ResidualModeConst
    NavigationTerminated YesNoConst
    Xte *units.Distance
}
func DecodeCrossTrackError(Info MessageInfo, stream *DataStream) (any, error) {
    var val CrossTrackError
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for CrossTrackError-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for CrossTrackError-XteMode: %w", err)
    } else {
        val.XteMode = ResidualModeConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for CrossTrackError-NavigationTerminated: %w", err)
    } else {
        val.NavigationTerminated = YesNoConst(v)
    }
    if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for CrossTrackError-Xte: %w", err)
    } else {
        val.Xte = nullableUnit(units.Meter, v, units.NewDistance)
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p CrossTrackError) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.XteMode), 4, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 12)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.NavigationTerminated), 2, 14)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Xte, 32, 0.010000, 16, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type NavigationData struct {
    Info MessageInfo
    Sid *uint8
    DistanceToWaypoint *units.Distance
    CourseBearingReference DirectionReferenceConst
    PerpendicularCrossed YesNoConst
    ArrivalCircleEntered YesNoConst
    CalculationType BearingModeConst
    EtaTime *float32
    EtaDate *uint16
    BearingOriginToDestinationWaypoint *float32
    BearingPositionToDestinationWaypoint *float32
    OriginWaypointNumber *uint32
    DestinationWaypointNumber *uint32
    DestinationLatitude *float64
    DestinationLongitude *float64
    WaypointClosingVelocity *units.Velocity
}
func DecodeNavigationData(Info MessageInfo, stream *DataStream) (any, error) {
    var val NavigationData
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-DistanceToWaypoint: %w", err)
    } else {
        val.DistanceToWaypoint = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-CourseBearingReference: %w", err)
    } else {
        val.CourseBearingReference = DirectionReferenceConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-PerpendicularCrossed: %w", err)
    } else {
        val.PerpendicularCrossed = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-ArrivalCircleEntered: %w", err)
    } else {
        val.ArrivalCircleEntered = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-CalculationType: %w", err)
    } else {
        val.CalculationType = BearingModeConst(v)
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-EtaTime: %w", err)
    } else {
        val.EtaTime = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-EtaDate: %w", err)
    } else {
        val.EtaDate = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-BearingOriginToDestinationWaypoint: %w", err)
    } else {
        val.BearingOriginToDestinationWaypoint = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-BearingPositionToDestinationWaypoint: %w", err)
    } else {
        val.BearingPositionToDestinationWaypoint = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-OriginWaypointNumber: %w", err)
    } else {
        val.OriginWaypointNumber = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-DestinationWaypointNumber: %w", err)
    } else {
        val.DestinationWaypointNumber = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-DestinationLatitude: %w", err)
    } else {
        val.DestinationLatitude = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-DestinationLongitude: %w", err)
    } else {
        val.DestinationLongitude = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationData-WaypointClosingVelocity: %w", err)
    } else {
        val.WaypointClosingVelocity = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p NavigationData) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.DistanceToWaypoint, 32, 0.010000, 8, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.CourseBearingReference), 2, 40)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.PerpendicularCrossed), 2, 42)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ArrivalCircleEntered), 2, 44)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.CalculationType), 2, 46)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.EtaTime, 32, 0.0001, 48, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.EtaDate, 16, 80)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.BearingOriginToDestinationWaypoint, 16, 0.0001, 96, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.BearingPositionToDestinationWaypoint, 16, 0.0001, 112, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.OriginWaypointNumber, 32, 128)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.DestinationWaypointNumber, 32, 160)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.DestinationLatitude, 32, 1e-07, 192, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.DestinationLongitude, 32, 1e-07, 224, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.WaypointClosingVelocity, 16, 0.010000, 256, 0, true)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
type NavigationRouteWpInformationRepeating1 struct {
    WpId *uint16
    WpName string
    WpLatitude *float64
    WpLongitude *float64
}

type NavigationRouteWpInformation struct {
    Info MessageInfo
    StartRps *uint16
    Nitems *uint16
    DatabaseId *uint16
    RouteId *uint16
    NavigationDirectionInRoute DirectionConst
    SupplementaryRouteWpDataAvailable OffOnConst
    RouteName string
    Repeating1 []NavigationRouteWpInformationRepeating1
}
func DecodeNavigationRouteWpInformation(Info MessageInfo, stream *DataStream) (any, error) {
    var val NavigationRouteWpInformation
    val.Info = Info
    var repeat1Count uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-StartRps: %w", err)
    } else {
        val.StartRps = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-Nitems: %w", err)
    } else {
        val.Nitems = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-DatabaseId: %w", err)
    } else {
        val.DatabaseId = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-RouteId: %w", err)
    } else {
        val.RouteId = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-NavigationDirectionInRoute: %w", err)
    } else {
        val.NavigationDirectionInRoute = DirectionConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-SupplementaryRouteWpDataAvailable: %w", err)
    } else {
        val.SupplementaryRouteWpDataAvailable = OffOnConst(v)
    }
    stream.skipBits(3)
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-RouteName: %w", err)
    } else {
        val.RouteName = v
    }
    stream.skipBits(8)
    val.Repeating1 = make([]NavigationRouteWpInformationRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep NavigationRouteWpInformationRepeating1
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpId: %w", err)
		} else {
			rep.WpId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpName: %w", err)
		} else {
			rep.WpName = v
		}
		if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpLatitude: %w", err)
		} else {
			rep.WpLatitude = v
		}
		if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpLongitude: %w", err)
		} else {
			rep.WpLongitude = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p NavigationRouteWpInformation) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint16(p.StartRps, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.Nitems, 16, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.DatabaseId, 16, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.RouteId, 16, 48)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.NavigationDirectionInRoute), 3, 64)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SupplementaryRouteWpDataAvailable), 2, 67)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(3, 69)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringLau(p.RouteName, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 0)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p NavigationRouteWpInformation) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint16(p.Repeating1[index].WpId, 16, 0)
        if err != nil {
            return err
        }
        err = stream.writeStringLau(p.Repeating1[index].WpName, 0 )
        if err != nil {
            return err
        }
        err = stream.writeSignedResolution64(p.Repeating1[index].WpLatitude, 32, 1e-07, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeSignedResolution64(p.Repeating1[index].WpLongitude, 32, 1e-07, 0, 0)
        if err != nil {
            return err
        }
    }
    return nil
}

type GnssDops struct {
    Info MessageInfo
    Sid *uint8
    DesiredMode GnssModeConst
    ActualMode GnssModeConst
    Hdop *float32
    Vdop *float32
    Tdop *float32
}
func DecodeGnssDops(Info MessageInfo, stream *DataStream) (any, error) {
    var val GnssDops
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDops-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDops-DesiredMode: %w", err)
    } else {
        val.DesiredMode = GnssModeConst(v)
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDops-ActualMode: %w", err)
    } else {
        val.ActualMode = GnssModeConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDops-Hdop: %w", err)
    } else {
        val.Hdop = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDops-Vdop: %w", err)
    } else {
        val.Vdop = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDops-Tdop: %w", err)
    } else {
        val.Tdop = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GnssDops) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DesiredMode), 3, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ActualMode), 3, 11)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 14)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Hdop, 16, 0.01, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Vdop, 16, 0.01, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Tdop, 16, 0.01, 48, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
type GnssSatsInViewRepeating1 struct {
    Prn *uint8
    Elevation *float32
    Azimuth *float32
    Snr *float32
    RangeResiduals *int32
    Status SatelliteStatusConst
}

type GnssSatsInView struct {
    Info MessageInfo
    Sid *uint8
    RangeResidualMode RangeResidualModeConst
    SatsInView *uint8
    Repeating1 []GnssSatsInViewRepeating1
}
func DecodeGnssSatsInView(Info MessageInfo, stream *DataStream) (any, error) {
    var val GnssSatsInView
    val.Info = Info
    var repeat1Count uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssSatsInView-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for GnssSatsInView-RangeResidualMode: %w", err)
    } else {
        val.RangeResidualMode = RangeResidualModeConst(v)
    }
    stream.skipBits(6)
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssSatsInView-SatsInView: %w", err)
    } else {
        val.SatsInView = v
        if v != nil {
            repeat1Count = uint16(*v)
        }
    }
    val.Repeating1 = make([]GnssSatsInViewRepeating1, 0)
    if repeat1Count == 0 {
        return val, nil
    }

    i := 0 
	for {
		var rep GnssSatsInViewRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Prn: %w", err)
		} else {
			rep.Prn = v
		}
		if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Elevation: %w", err)
		} else {
			rep.Elevation = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Azimuth: %w", err)
		} else {
			rep.Azimuth = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Snr: %w", err)
		} else {
			rep.Snr = v
		}
		if v, err := stream.readInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-RangeResiduals: %w", err)
		} else {
			rep.RangeResiduals = v
		}
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Status: %w", err)
		} else {
			rep.Status = SatelliteStatusConst(v)
		}
		stream.skipBits(4)
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GnssSatsInView) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RangeResidualMode), 2, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 10)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SatsInView, 8, 16)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p GnssSatsInView) encodeRepeating1(stream *DataStream) error {
     var err error
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.writeUint8(p.Repeating1[index].Prn, 8, 0)
        if err != nil {
            return err
        }
        err = stream.writeSignedResolution32(p.Repeating1[index].Elevation, 16, 0.0001, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].Azimuth, 16, 0.0001, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeUnsignedResolution32(p.Repeating1[index].Snr, 16, 0.01, 0, 0)
        if err != nil {
            return err
        }
        err = stream.writeInt32(p.Repeating1[index].RangeResiduals, 32, 0)
        if err != nil {
            return err
        }
        err = stream.putNumberRaw(uint64(p.Repeating1[index].Status), 4, 0)
        if err != nil {
            return err
        }
        err = stream.writeReserved(4, 0)
        if err != nil {
            return err
        }
    }
    return nil
}

type GnssRaimSettings struct {
    Info MessageInfo
    RadialPositionErrorMaximumThreshold *units.Distance
    ProbabilityOfFalseAlarm *int8
    ProbabilityOfMissedDetection *int8
    PseudorangeResidualFilteringTimeConstant *uint16
}
func DecodeGnssRaimSettings(Info MessageInfo, stream *DataStream) (any, error) {
    var val GnssRaimSettings
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssRaimSettings-RadialPositionErrorMaximumThreshold: %w", err)
    } else {
        val.RadialPositionErrorMaximumThreshold = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssRaimSettings-ProbabilityOfFalseAlarm: %w", err)
    } else {
        val.ProbabilityOfFalseAlarm = v
    }
    if v, err := stream.readInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssRaimSettings-ProbabilityOfMissedDetection: %w", err)
    } else {
        val.ProbabilityOfMissedDetection = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GnssRaimSettings-PseudorangeResidualFilteringTimeConstant: %w", err)
    } else {
        val.PseudorangeResidualFilteringTimeConstant = v
    }
    stream.skipBits(16)	
    return val, nil
}

// Encode implementation for complete variant
func (p GnssRaimSettings) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUnit(p.RadialPositionErrorMaximumThreshold, 16, 0.010000, 0, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeInt8(p.ProbabilityOfFalseAlarm, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeInt8(p.ProbabilityOfMissedDetection, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.PseudorangeResidualFilteringTimeConstant, 16, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(16, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GnssPseudorangeErrorStatistics struct {
    Info MessageInfo
    Sid *uint8
    RmsStdDevOfRangeInputs *units.Distance
    StdDevOfMajorErrorEllipse *units.Distance
    StdDevOfMinorErrorEllipse *units.Distance
    OrientationOfErrorEllipse *float32
    StdDevLatError *units.Distance
    StdDevLonError *units.Distance
    StdDevAltError *units.Distance
}
func DecodeGnssPseudorangeErrorStatistics(Info MessageInfo, stream *DataStream) (any, error) {
    var val GnssPseudorangeErrorStatistics
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-RmsStdDevOfRangeInputs: %w", err)
    } else {
        val.RmsStdDevOfRangeInputs = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevOfMajorErrorEllipse: %w", err)
    } else {
        val.StdDevOfMajorErrorEllipse = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevOfMinorErrorEllipse: %w", err)
    } else {
        val.StdDevOfMinorErrorEllipse = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-OrientationOfErrorEllipse: %w", err)
    } else {
        val.OrientationOfErrorEllipse = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevLatError: %w", err)
    } else {
        val.StdDevLatError = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevLonError: %w", err)
    } else {
        val.StdDevLonError = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssPseudorangeErrorStatistics-StdDevAltError: %w", err)
    } else {
        val.StdDevAltError = nullableUnit(units.Meter, v, units.NewDistance)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GnssPseudorangeErrorStatistics) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.RmsStdDevOfRangeInputs, 16, 0.010000, 8, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.StdDevOfMajorErrorEllipse, 16, 0.010000, 24, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.StdDevOfMinorErrorEllipse, 16, 0.010000, 40, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.OrientationOfErrorEllipse, 16, 0.0001, 56, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.StdDevLatError, 16, 0.010000, 72, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.StdDevLonError, 16, 0.010000, 88, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.StdDevAltError, 16, 0.010000, 104, 0, true)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type DgnssCorrections struct {
    Info MessageInfo
    Sid *uint8
    ReferenceStationId *uint16
    ReferenceStationType GnsConst
    TimeOfCorrections *float32
    StationHealth StationHealthConst
    SatelliteId *uint8
    Prc *units.Distance
    Rrc *units.Velocity
    Udre *units.Distance
    Iod *uint8
}
func DecodeDgnssCorrections(Info MessageInfo, stream *DataStream) (any, error) {
    var val DgnssCorrections
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt16(12); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-ReferenceStationId: %w", err)
    } else {
        val.ReferenceStationId = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-ReferenceStationType: %w", err)
    } else {
        val.ReferenceStationType = GnsConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-TimeOfCorrections: %w", err)
    } else {
        val.TimeOfCorrections = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-StationHealth: %w", err)
    } else {
        val.StationHealth = StationHealthConst(v)
    }
    stream.skipBits(4)
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-SatelliteId: %w", err)
    } else {
        val.SatelliteId = v
    }
    if v, err := stream.readSignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-Prc: %w", err)
    } else {
        val.Prc = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-Rrc: %w", err)
    } else {
        val.Rrc = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-Udre: %w", err)
    } else {
        val.Udre = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for DgnssCorrections-Iod: %w", err)
    } else {
        val.Iod = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p DgnssCorrections) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.ReferenceStationId, 12, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ReferenceStationType), 4, 20)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TimeOfCorrections, 16, 0.001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.StationHealth), 4, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(4, 44)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SatelliteId, 8, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Prc, 32, 0.000100, 56, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Rrc, 16, 0.000100, 88, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Udre, 16, 0.010000, 104, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Iod, 8, 120)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GnssDifferentialCorrectionReceiverInterface struct {
    Info MessageInfo
    Channel *uint8
    Frequency *float32
    SerialInterfaceBitRate SerialBitRateConst
    SerialInterfaceDetectionMode SerialDetectionModeConst
    DifferentialSource DifferentialSourceConst
    DifferentialOperationMode DifferentialModeConst
}
func DecodeGnssDifferentialCorrectionReceiverInterface(Info MessageInfo, stream *DataStream) (any, error) {
    var val GnssDifferentialCorrectionReceiverInterface
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-Channel: %w", err)
    } else {
        val.Channel = v
    }
    if v, err := stream.readUnsignedResolution(32, 10, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-Frequency: %w", err)
    } else {
        val.Frequency = v
    }
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-SerialInterfaceBitRate: %w", err)
    } else {
        val.SerialInterfaceBitRate = SerialBitRateConst(v)
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-SerialInterfaceDetectionMode: %w", err)
    } else {
        val.SerialInterfaceDetectionMode = SerialDetectionModeConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-DifferentialSource: %w", err)
    } else {
        val.DifferentialSource = DifferentialSourceConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverInterface-DifferentialOperationMode: %w", err)
    } else {
        val.DifferentialOperationMode = DifferentialModeConst(v)
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p GnssDifferentialCorrectionReceiverInterface) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Channel, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Frequency, 32, 10, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SerialInterfaceBitRate), 5, 40)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SerialInterfaceDetectionMode), 3, 45)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DifferentialSource), 4, 48)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DifferentialOperationMode), 4, 52)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GnssDifferentialCorrectionReceiverSignal struct {
    Info MessageInfo
    Sid *uint8
    Channel *uint8
    SignalStrength *float32
    SignalSnr *float32
    Frequency *float32
    StationType GnsConst
    ReferenceStationId *uint16
    DifferentialSignalBitRate SerialBitRateConst
    DifferentialSignalDetectionMode SerialDetectionModeConst
    UsedAsCorrectionSource YesNoConst
    DifferentialSource DifferentialSourceConst
    TimeSinceLastSatDifferentialSync *float32
    SatelliteServiceIdNo *uint16
}
func DecodeGnssDifferentialCorrectionReceiverSignal(Info MessageInfo, stream *DataStream) (any, error) {
    var val GnssDifferentialCorrectionReceiverSignal
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-Channel: %w", err)
    } else {
        val.Channel = v
    }
    if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-SignalStrength: %w", err)
    } else {
        val.SignalStrength = v
    }
    if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-SignalSnr: %w", err)
    } else {
        val.SignalSnr = v
    }
    if v, err := stream.readUnsignedResolution(32, 10, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-Frequency: %w", err)
    } else {
        val.Frequency = v
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-StationType: %w", err)
    } else {
        val.StationType = GnsConst(v)
    }
    if v, err := stream.readUInt16(12); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-ReferenceStationId: %w", err)
    } else {
        val.ReferenceStationId = v
    }
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-DifferentialSignalBitRate: %w", err)
    } else {
        val.DifferentialSignalBitRate = SerialBitRateConst(v)
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-DifferentialSignalDetectionMode: %w", err)
    } else {
        val.DifferentialSignalDetectionMode = SerialDetectionModeConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-UsedAsCorrectionSource: %w", err)
    } else {
        val.UsedAsCorrectionSource = YesNoConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-DifferentialSource: %w", err)
    } else {
        val.DifferentialSource = DifferentialSourceConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-TimeSinceLastSatDifferentialSync: %w", err)
    } else {
        val.TimeSinceLastSatDifferentialSync = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GnssDifferentialCorrectionReceiverSignal-SatelliteServiceIdNo: %w", err)
    } else {
        val.SatelliteServiceIdNo = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GnssDifferentialCorrectionReceiverSignal) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Channel, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.SignalStrength, 32, 0.01, 16, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.SignalSnr, 16, 0.01, 48, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.Frequency, 32, 10, 64, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.StationType), 4, 96)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.ReferenceStationId, 12, 100)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DifferentialSignalBitRate), 5, 112)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DifferentialSignalDetectionMode), 3, 117)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.UsedAsCorrectionSource), 2, 120)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 122)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.DifferentialSource), 4, 124)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.TimeSinceLastSatDifferentialSync, 16, 0.01, 128, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.SatelliteServiceIdNo, 16, 144)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type GlonassAlmanacData struct {
    Info MessageInfo
    Prn *uint8
    Na *uint16
    Cna *uint8
    Hna *uint8
    EpsilonNa *uint16
    DeltatnaDot *uint8
    OmegaNa *uint16
    DeltaTna *uint32
    Tna *uint32
    LambdaNa *uint32
    DeltaIna *uint32
    TauCa *uint32
    TauNa *uint16
}
func DecodeGlonassAlmanacData(Info MessageInfo, stream *DataStream) (any, error) {
    var val GlonassAlmanacData
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Prn: %w", err)
    } else {
        val.Prn = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Na: %w", err)
    } else {
        val.Na = v
    }
    stream.skipBits(2)
    if v, err := stream.readUInt8(1); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Cna: %w", err)
    } else {
        val.Cna = v
    }
    if v, err := stream.readUInt8(5); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Hna: %w", err)
    } else {
        val.Hna = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-EpsilonNa: %w", err)
    } else {
        val.EpsilonNa = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-DeltatnaDot: %w", err)
    } else {
        val.DeltatnaDot = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-OmegaNa: %w", err)
    } else {
        val.OmegaNa = v
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-DeltaTna: %w", err)
    } else {
        val.DeltaTna = v
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-Tna: %w", err)
    } else {
        val.Tna = v
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-LambdaNa: %w", err)
    } else {
        val.LambdaNa = v
    }
    if v, err := stream.readUInt32(24); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-DeltaIna: %w", err)
    } else {
        val.DeltaIna = v
    }
    if v, err := stream.readUInt32(28); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-TauCa: %w", err)
    } else {
        val.TauCa = v
    }
    if v, err := stream.readUInt16(12); err != nil {
        return nil, fmt.Errorf("parse failed for GlonassAlmanacData-TauNa: %w", err)
    } else {
        val.TauNa = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p GlonassAlmanacData) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Prn, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.Na, 16, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Cna, 1, 26)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Hna, 5, 27)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.EpsilonNa, 16, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.DeltatnaDot, 8, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.OmegaNa, 16, 56)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.DeltaTna, 24, 72)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.Tna, 24, 96)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.LambdaNa, 24, 120)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.DeltaIna, 24, 144)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.TauCa, 28, 168)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.TauNa, 12, 196)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisClassAStaticAndVoyageRelatedData struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    UserId *uint32
    ImoNumber *uint32
    Callsign string
    Name string
    TypeOfShip ShipTypeConst
    Length *units.Distance
    Beam *units.Distance
    PositionReferenceFromStarboard *units.Distance
    PositionReferenceFromBow *units.Distance
    EtaDate *uint16
    EtaTime *float32
    Draft *units.Distance
    Destination string
    AisVersionIndicator AisVersionConst
    GnssType PositionFixDeviceConst
    Dte AvailableConst
    AisTransceiverInformation AisTransceiverConst
}
func DecodeAisClassAStaticAndVoyageRelatedData(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisClassAStaticAndVoyageRelatedData
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-UserId: %w", err)
    } else {
        val.UserId = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-ImoNumber: %w", err)
    } else {
        val.ImoNumber = v
    }
    if v, err := stream.readFixedString(56); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Callsign: %w", err)
    } else {
        val.Callsign = v
    }
    if v, err := stream.readFixedString(160); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Name: %w", err)
    } else {
        val.Name = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-TypeOfShip: %w", err)
    } else {
        val.TypeOfShip = ShipTypeConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Length: %w", err)
    } else {
        val.Length = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Beam: %w", err)
    } else {
        val.Beam = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-PositionReferenceFromStarboard: %w", err)
    } else {
        val.PositionReferenceFromStarboard = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-PositionReferenceFromBow: %w", err)
    } else {
        val.PositionReferenceFromBow = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-EtaDate: %w", err)
    } else {
        val.EtaDate = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-EtaTime: %w", err)
    } else {
        val.EtaTime = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Draft: %w", err)
    } else {
        val.Draft = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readFixedString(160); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Destination: %w", err)
    } else {
        val.Destination = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-AisVersionIndicator: %w", err)
    } else {
        val.AisVersionIndicator = AisVersionConst(v)
    }
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-GnssType: %w", err)
    } else {
        val.GnssType = PositionFixDeviceConst(v)
    }
    if v, err := stream.readLookupField(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Dte: %w", err)
    } else {
        val.Dte = AvailableConst(v)
    }
    stream.skipBits(1)
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    stream.skipBits(3)	
    return val, nil
}

// Encode implementation for complete variant
func (p AisClassAStaticAndVoyageRelatedData) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.UserId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.ImoNumber, 32, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.Callsign), 56, 72 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.Name), 160, 128 )
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TypeOfShip), 8, 288)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Length, 16, 0.100000, 296, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Beam, 16, 0.100000, 312, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.PositionReferenceFromStarboard, 16, 0.100000, 328, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.PositionReferenceFromBow, 16, 0.100000, 344, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.EtaDate, 16, 360)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.EtaTime, 32, 0.0001, 376, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Draft, 16, 0.010000, 408, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.Destination), 160, 424 )
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisVersionIndicator), 2, 584)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.GnssType), 4, 586)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Dte), 1, 590)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(1, 591)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 592)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(3, 597)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisAddressedBinaryMessage struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    SourceId *uint32
    AisTransceiverInformation AisTransceiverConst
    SequenceNumber *uint8
    DestinationId *uint32
    RetransmitFlag *uint8
    NumberOfBitsInBinaryDataField *uint16
    BinaryData []uint8
}
func DecodeAisAddressedBinaryMessage(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisAddressedBinaryMessage
    val.Info = Info
		var binaryLength uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-SourceId: %w", err)
    } else {
        val.SourceId = v
    }
    stream.skipBits(1)
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    if v, err := stream.readUInt8(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-SequenceNumber: %w", err)
    } else {
        val.SequenceNumber = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-DestinationId: %w", err)
    } else {
        val.DestinationId = v
    }
    stream.skipBits(6)
    if v, err := stream.readUInt8(1); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-RetransmitFlag: %w", err)
    } else {
        val.RetransmitFlag = v
    }
    stream.skipBits(1)
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-NumberOfBitsInBinaryDataField: %w", err)
    } else {
        val.NumberOfBitsInBinaryDataField = v
		if v != nil {
			binaryLength = uint16(*v)
		}
    }
    if v, err := stream.readBinaryData(binaryLength); err != nil {
        return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-BinaryData: %w", err)
    } else {
        val.BinaryData = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AisAddressedBinaryMessage) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
		var binaryLength uint16
		if p.NumberOfBitsInBinaryDataField != nil {
			binaryLength = *p.NumberOfBitsInBinaryDataField
		}
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.SourceId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(1, 40)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 41)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SequenceNumber, 2, 46)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.DestinationId, 32, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 80)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.RetransmitFlag, 1, 86)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(1, 87)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.NumberOfBitsInBinaryDataField, 16, 88)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.BinaryData,binaryLength, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisAcknowledge struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    SourceId *uint32
    AisTransceiverInformation AisTransceiverConst
    DestinationId1 *uint32
    SequenceNumberForId1 []uint8
    SequenceNumberForIdN []uint8
}
func DecodeAisAcknowledge(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisAcknowledge
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisAcknowledge-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisAcknowledge-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisAcknowledge-SourceId: %w", err)
    } else {
        val.SourceId = v
    }
    stream.skipBits(1)
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisAcknowledge-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisAcknowledge-DestinationId1: %w", err)
    } else {
        val.DestinationId1 = v
    }
    if v, err := stream.readBinaryData(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisAcknowledge-SequenceNumberForId1: %w", err)
    } else {
        val.SequenceNumberForId1 = v
    }
    stream.skipBits(6)
    if v, err := stream.readBinaryData(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisAcknowledge-SequenceNumberForIdN: %w", err)
    } else {
        val.SequenceNumberForIdN = v
    }
    stream.skipBits(6)	
    return val, nil
}

// Encode implementation for complete variant
func (p AisAcknowledge) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.SourceId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(1, 40)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 41)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 46)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.DestinationId1, 32, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.SequenceNumberForId1, 2, 80 )
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 82)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.SequenceNumberForIdN, 2, 88 )
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 90)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisBinaryBroadcastMessage struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    SourceId *uint32
    AisTransceiverInformation AisTransceiverConst
    NumberOfBitsInBinaryDataField *uint16
    BinaryData []uint8
}
func DecodeAisBinaryBroadcastMessage(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisBinaryBroadcastMessage
    val.Info = Info
		var binaryLength uint16 = 0

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-SourceId: %w", err)
    } else {
        val.SourceId = v
    }
    stream.skipBits(1)
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-NumberOfBitsInBinaryDataField: %w", err)
    } else {
        val.NumberOfBitsInBinaryDataField = v
		if v != nil {
			binaryLength = uint16(*v)
		}
    }
    if v, err := stream.readBinaryData(binaryLength); err != nil {
        return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-BinaryData: %w", err)
    } else {
        val.BinaryData = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AisBinaryBroadcastMessage) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
		var binaryLength uint16
		if p.NumberOfBitsInBinaryDataField != nil {
			binaryLength = *p.NumberOfBitsInBinaryDataField
		}
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.SourceId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(1, 40)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 41)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 46)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.NumberOfBitsInBinaryDataField, 16, 48)
    if err != nil {
        return nil, err
    }
    err = stream.writeBinary(p.BinaryData,binaryLength, 0)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisClassBStaticDataMsg24PartA struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    UserId *uint32
    Name string
    AisTransceiverInformation AisTransceiverConst
    SequenceId *uint8
}
func DecodeAisClassBStaticDataMsg24PartA(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisClassBStaticDataMsg24PartA
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-UserId: %w", err)
    } else {
        val.UserId = v
    }
    if v, err := stream.readFixedString(160); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-Name: %w", err)
    } else {
        val.Name = v
    }
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    stream.skipBits(3)
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-SequenceId: %w", err)
    } else {
        val.SequenceId = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AisClassBStaticDataMsg24PartA) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.UserId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.Name), 160, 40 )
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 200)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(3, 205)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SequenceId, 8, 208)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type AisClassBStaticDataMsg24PartB struct {
    Info MessageInfo
    MessageId AisMessageIdConst
    RepeatIndicator RepeatIndicatorConst
    UserId *uint32
    TypeOfShip ShipTypeConst
    VendorId string
    Callsign string
    Length *units.Distance
    Beam *units.Distance
    PositionReferenceFromStarboard *units.Distance
    PositionReferenceFromBow *units.Distance
    MothershipUserId *uint32
    GnssType PositionFixDeviceConst
    AisTransceiverInformation AisTransceiverConst
    SequenceId *uint8
}
func DecodeAisClassBStaticDataMsg24PartB(Info MessageInfo, stream *DataStream) (any, error) {
    var val AisClassBStaticDataMsg24PartB
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-MessageId: %w", err)
    } else {
        val.MessageId = AisMessageIdConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-RepeatIndicator: %w", err)
    } else {
        val.RepeatIndicator = RepeatIndicatorConst(v)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-UserId: %w", err)
    } else {
        val.UserId = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-TypeOfShip: %w", err)
    } else {
        val.TypeOfShip = ShipTypeConst(v)
    }
    if v, err := stream.readFixedString(56); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-VendorId: %w", err)
    } else {
        val.VendorId = v
    }
    if v, err := stream.readFixedString(56); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Callsign: %w", err)
    } else {
        val.Callsign = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Length: %w", err)
    } else {
        val.Length = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Beam: %w", err)
    } else {
        val.Beam = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-PositionReferenceFromStarboard: %w", err)
    } else {
        val.PositionReferenceFromStarboard = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-PositionReferenceFromBow: %w", err)
    } else {
        val.PositionReferenceFromBow = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-MothershipUserId: %w", err)
    } else {
        val.MothershipUserId = v
    }
    stream.skipBits(2)
    stream.skipBits(2)
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-GnssType: %w", err)
    } else {
        val.GnssType = PositionFixDeviceConst(v)
    }
    if v, err := stream.readLookupField(5); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-AisTransceiverInformation: %w", err)
    } else {
        val.AisTransceiverInformation = AisTransceiverConst(v)
    }
    stream.skipBits(3)
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-SequenceId: %w", err)
    } else {
        val.SequenceId = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p AisClassBStaticDataMsg24PartB) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.UserId, 32, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TypeOfShip), 8, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.VendorId), 56, 48 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringFix([]uint8(p.Callsign), 56, 104 )
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Length, 16, 0.100000, 160, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Beam, 16, 0.100000, 176, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.PositionReferenceFromStarboard, 16, 0.100000, 192, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.PositionReferenceFromBow, 16, 0.100000, 208, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.MothershipUserId, 32, 224)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 256)
    if err != nil {
        return nil, err
    }
    err = stream.writeSpare(2, 258)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.GnssType), 4, 260)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 264)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(3, 269)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.SequenceId, 8, 272)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type WindData struct {
    Info MessageInfo
    Sid *uint8
    WindSpeed *units.Velocity
    WindAngle *float32
    Reference WindReferenceConst
}
func DecodeWindData(Info MessageInfo, stream *DataStream) (any, error) {
    var val WindData
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for WindData-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WindData-WindSpeed: %w", err)
    } else {
        val.WindSpeed = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WindData-WindAngle: %w", err)
    } else {
        val.WindAngle = v
    }
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for WindData-Reference: %w", err)
    } else {
        val.Reference = WindReferenceConst(v)
    }
    stream.skipBits(21)	
    return val, nil
}

// Encode implementation for complete variant
func (p WindData) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.WindSpeed, 16, 0.010000, 8, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.WindAngle, 16, 0.0001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Reference), 3, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(21, 43)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type EnvironmentalParametersObsolete struct {
    Info MessageInfo
    Sid *uint8
    WaterTemperature *units.Temperature
    OutsideAmbientAirTemperature *units.Temperature
    AtmosphericPressure *units.Pressure
}
func DecodeEnvironmentalParametersObsolete(Info MessageInfo, stream *DataStream) (any, error) {
    var val EnvironmentalParametersObsolete
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-WaterTemperature: %w", err)
    } else {
        val.WaterTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-OutsideAmbientAirTemperature: %w", err)
    } else {
        val.OutsideAmbientAirTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-AtmosphericPressure: %w", err)
    } else {
        val.AtmosphericPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p EnvironmentalParametersObsolete) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.WaterTemperature, 16, 0.010000, 8, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.OutsideAmbientAirTemperature, 16, 0.010000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.AtmosphericPressure, 16, 100.000000, 40, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type EnvironmentalParameters struct {
    Info MessageInfo
    Sid *uint8
    TemperatureSource TemperatureSourceConst
    HumiditySource HumiditySourceConst
    Temperature *units.Temperature
    Humidity *float32
    AtmosphericPressure *units.Pressure
}
func DecodeEnvironmentalParameters(Info MessageInfo, stream *DataStream) (any, error) {
    var val EnvironmentalParameters
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParameters-TemperatureSource: %w", err)
    } else {
        val.TemperatureSource = TemperatureSourceConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParameters-HumiditySource: %w", err)
    } else {
        val.HumiditySource = HumiditySourceConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Temperature: %w", err)
    } else {
        val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readSignedResolution(16, 0.004, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Humidity: %w", err)
    } else {
        val.Humidity = v
    }
    if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
        return nil, fmt.Errorf("parse failed for EnvironmentalParameters-AtmosphericPressure: %w", err)
    } else {
        val.AtmosphericPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p EnvironmentalParameters) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TemperatureSource), 6, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.HumiditySource), 2, 14)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Temperature, 16, 0.010000, 16, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.Humidity, 16, 0.004, 32, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.AtmosphericPressure, 16, 100.000000, 48, 0, false)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Temperature struct {
    Info MessageInfo
    Sid *uint8
    Instance *uint8
    Source TemperatureSourceConst
    ActualTemperature *units.Temperature
    SetTemperature *units.Temperature
}
func DecodeTemperature(Info MessageInfo, stream *DataStream) (any, error) {
    var val Temperature
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Temperature-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Temperature-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for Temperature-Source: %w", err)
    } else {
        val.Source = TemperatureSourceConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Temperature-ActualTemperature: %w", err)
    } else {
        val.ActualTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Temperature-SetTemperature: %w", err)
    } else {
        val.SetTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p Temperature) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Source), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.ActualTemperature, 16, 0.010000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SetTemperature, 16, 0.010000, 40, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type Humidity struct {
    Info MessageInfo
    Sid *uint8
    Instance *uint8
    Source HumiditySourceConst
    ActualHumidity *float32
    SetHumidity *float32
}
func DecodeHumidity(Info MessageInfo, stream *DataStream) (any, error) {
    var val Humidity
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Humidity-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for Humidity-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for Humidity-Source: %w", err)
    } else {
        val.Source = HumiditySourceConst(v)
    }
    if v, err := stream.readSignedResolution(16, 0.004, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Humidity-ActualHumidity: %w", err)
    } else {
        val.ActualHumidity = v
    }
    if v, err := stream.readSignedResolution(16, 0.004, 0); err != nil {
        return nil, fmt.Errorf("parse failed for Humidity-SetHumidity: %w", err)
    } else {
        val.SetHumidity = v
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p Humidity) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Source), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.ActualHumidity, 16, 0.004, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution32(p.SetHumidity, 16, 0.004, 40, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type ActualPressure struct {
    Info MessageInfo
    Sid *uint8
    Instance *uint8
    Source PressureSourceConst
    Pressure *units.Pressure
}
func DecodeActualPressure(Info MessageInfo, stream *DataStream) (any, error) {
    var val ActualPressure
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ActualPressure-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for ActualPressure-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for ActualPressure-Source: %w", err)
    } else {
        val.Source = PressureSourceConst(v)
    }
    if v, err := stream.readSignedResolution(32, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for ActualPressure-Pressure: %w", err)
    } else {
        val.Pressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p ActualPressure) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Source), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Pressure, 32, 0.100000, 24, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SetPressure struct {
    Info MessageInfo
    Sid *uint8
    Instance *uint8
    Source PressureSourceConst
    Pressure *units.Pressure
}
func DecodeSetPressure(Info MessageInfo, stream *DataStream) (any, error) {
    var val SetPressure
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for SetPressure-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for SetPressure-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SetPressure-Source: %w", err)
    } else {
        val.Source = PressureSourceConst(v)
    }
    if v, err := stream.readUnsignedResolution(32, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for SetPressure-Pressure: %w", err)
    } else {
        val.Pressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    stream.skipBits(8)	
    return val, nil
}

// Encode implementation for complete variant
func (p SetPressure) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Source), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Pressure, 32, 0.100000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 56)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type TemperatureExtendedRange struct {
    Info MessageInfo
    Sid *uint8
    Instance *uint8
    Source TemperatureSourceConst
    Temperature *units.Temperature
    SetTemperature *units.Temperature
}
func DecodeTemperatureExtendedRange(Info MessageInfo, stream *DataStream) (any, error) {
    var val TemperatureExtendedRange
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Source: %w", err)
    } else {
        val.Source = TemperatureSourceConst(v)
    }
    if v, err := stream.readUnsignedResolution(24, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Temperature: %w", err)
    } else {
        val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-SetTemperature: %w", err)
    } else {
        val.SetTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p TemperatureExtendedRange) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUint8(p.Sid, 8, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Source), 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.Temperature, 24, 0.001000, 24, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SetTemperature, 16, 0.100000, 48, 0, false)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type TideStationData struct {
    Info MessageInfo
    Mode ResidualModeConst
    TideTendency TideConst
    MeasurementDate *uint16
    MeasurementTime *float32
    StationLatitude *float64
    StationLongitude *float64
    TideLevel *units.Distance
    TideLevelStandardDeviation *units.Distance
    StationId string
    StationName string
}
func DecodeTideStationData(Info MessageInfo, stream *DataStream) (any, error) {
    var val TideStationData
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(4); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-Mode: %w", err)
    } else {
        val.Mode = ResidualModeConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-TideTendency: %w", err)
    } else {
        val.TideTendency = TideConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-MeasurementDate: %w", err)
    } else {
        val.MeasurementDate = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-MeasurementTime: %w", err)
    } else {
        val.MeasurementTime = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-StationLatitude: %w", err)
    } else {
        val.StationLatitude = v
    }
    if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-StationLongitude: %w", err)
    } else {
        val.StationLongitude = v
    }
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-TideLevel: %w", err)
    } else {
        val.TideLevel = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-TideLevelStandardDeviation: %w", err)
    } else {
        val.TideLevelStandardDeviation = nullableUnit(units.Meter, v, units.NewDistance)
    }
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-StationId: %w", err)
    } else {
        val.StationId = v
    }
    if v, err := stream.readStringWithLengthAndControl(); err != nil {
        return nil, fmt.Errorf("parse failed for TideStationData-StationName: %w", err)
    } else {
        val.StationName = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p TideStationData) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.Mode), 4, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.TideTendency), 2, 4)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.MeasurementDate, 16, 8)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.MeasurementTime, 32, 0.0001, 24, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.StationLatitude, 32, 1e-07, 56, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeSignedResolution64(p.StationLongitude, 32, 1e-07, 88, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.TideLevel, 16, 0.001000, 120, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.TideLevelStandardDeviation, 16, 0.010000, 136, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeStringLau(p.StationId, 0 )
    if err != nil {
        return nil, err
    }
    err = stream.writeStringLau(p.StationName, 0 )
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type WatermakerInputSettingAndStatus struct {
    Info MessageInfo
    WatermakerOperatingState WatermakerStateConst
    ProductionStartStop YesNoConst
    RinseStartStop YesNoConst
    LowPressurePumpStatus YesNoConst
    HighPressurePumpStatus YesNoConst
    EmergencyStop YesNoConst
    ProductSolenoidValveStatus OkWarningConst
    FlushModeStatus YesNoConst
    SalinityStatus OkWarningConst
    SensorStatus OkWarningConst
    OilChangeIndicatorStatus OkWarningConst
    FilterStatus OkWarningConst
    SystemStatus OkWarningConst
    Salinity *uint16
    ProductWaterTemperature *units.Temperature
    PreFilterPressure *units.Pressure
    PostFilterPressure *units.Pressure
    FeedPressure *units.Pressure
    SystemHighPressure *units.Pressure
    ProductWaterFlow *units.Flow
    BrineWaterFlow *units.Flow
    RunTime *uint32
}
func DecodeWatermakerInputSettingAndStatus(Info MessageInfo, stream *DataStream) (any, error) {
    var val WatermakerInputSettingAndStatus
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(6); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-WatermakerOperatingState: %w", err)
    } else {
        val.WatermakerOperatingState = WatermakerStateConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductionStartStop: %w", err)
    } else {
        val.ProductionStartStop = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-RinseStartStop: %w", err)
    } else {
        val.RinseStartStop = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-LowPressurePumpStatus: %w", err)
    } else {
        val.LowPressurePumpStatus = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-HighPressurePumpStatus: %w", err)
    } else {
        val.HighPressurePumpStatus = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-EmergencyStop: %w", err)
    } else {
        val.EmergencyStop = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductSolenoidValveStatus: %w", err)
    } else {
        val.ProductSolenoidValveStatus = OkWarningConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FlushModeStatus: %w", err)
    } else {
        val.FlushModeStatus = YesNoConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SalinityStatus: %w", err)
    } else {
        val.SalinityStatus = OkWarningConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SensorStatus: %w", err)
    } else {
        val.SensorStatus = OkWarningConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-OilChangeIndicatorStatus: %w", err)
    } else {
        val.OilChangeIndicatorStatus = OkWarningConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FilterStatus: %w", err)
    } else {
        val.FilterStatus = OkWarningConst(v)
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SystemStatus: %w", err)
    } else {
        val.SystemStatus = OkWarningConst(v)
    }
    stream.skipBits(2)
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-Salinity: %w", err)
    } else {
        val.Salinity = v
    }
    if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductWaterTemperature: %w", err)
    } else {
        val.ProductWaterTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-PreFilterPressure: %w", err)
    } else {
        val.PreFilterPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-PostFilterPressure: %w", err)
    } else {
        val.PostFilterPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    if v, err := stream.readSignedResolution(16, 1000, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FeedPressure: %w", err)
    } else {
        val.FeedPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    if v, err := stream.readUnsignedResolution(16, 1000, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SystemHighPressure: %w", err)
    } else {
        val.SystemHighPressure = nullableUnit(units.Pa, v, units.NewPressure)
    }
    if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductWaterFlow: %w", err)
    } else {
        val.ProductWaterFlow = nullableUnit(units.LitersPerHour, v, units.NewFlow)
    }
    if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-BrineWaterFlow: %w", err)
    } else {
        val.BrineWaterFlow = nullableUnit(units.LitersPerHour, v, units.NewFlow)
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-RunTime: %w", err)
    } else {
        val.RunTime = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p WatermakerInputSettingAndStatus) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.WatermakerOperatingState), 6, 0)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProductionStartStop), 2, 6)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.RinseStartStop), 2, 8)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.LowPressurePumpStatus), 2, 10)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.HighPressurePumpStatus), 2, 12)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.EmergencyStop), 2, 14)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProductSolenoidValveStatus), 2, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.FlushModeStatus), 2, 18)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SalinityStatus), 2, 20)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SensorStatus), 2, 22)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.OilChangeIndicatorStatus), 2, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.FilterStatus), 2, 26)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SystemStatus), 2, 28)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 30)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.Salinity, 16, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.ProductWaterTemperature, 16, 0.010000, 48, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.PreFilterPressure, 16, 100.000000, 64, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.PostFilterPressure, 16, 100.000000, 80, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.FeedPressure, 16, 1000.000000, 96, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SystemHighPressure, 16, 1000.000000, 112, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.ProductWaterFlow, 16, 0.100000, 128, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.BrineWaterFlow, 16, 0.100000, 144, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.RunTime, 32, 160)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type VesselSpeedComponents struct {
    Info MessageInfo
    LongitudinalSpeedWaterReferenced *units.Velocity
    TransverseSpeedWaterReferenced *units.Velocity
    LongitudinalSpeedGroundReferenced *units.Velocity
    TransverseSpeedGroundReferenced *units.Velocity
    SternSpeedWaterReferenced *units.Velocity
    SternSpeedGroundReferenced *units.Velocity
}
func DecodeVesselSpeedComponents(Info MessageInfo, stream *DataStream) (any, error) {
    var val VesselSpeedComponents
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselSpeedComponents-LongitudinalSpeedWaterReferenced: %w", err)
    } else {
        val.LongitudinalSpeedWaterReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselSpeedComponents-TransverseSpeedWaterReferenced: %w", err)
    } else {
        val.TransverseSpeedWaterReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselSpeedComponents-LongitudinalSpeedGroundReferenced: %w", err)
    } else {
        val.LongitudinalSpeedGroundReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselSpeedComponents-TransverseSpeedGroundReferenced: %w", err)
    } else {
        val.TransverseSpeedGroundReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselSpeedComponents-SternSpeedWaterReferenced: %w", err)
    } else {
        val.SternSpeedWaterReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }
    if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for VesselSpeedComponents-SternSpeedGroundReferenced: %w", err)
    } else {
        val.SternSpeedGroundReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p VesselSpeedComponents) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.writeUnit(p.LongitudinalSpeedWaterReferenced, 16, 0.001000, 0, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.TransverseSpeedWaterReferenced, 16, 0.001000, 16, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.LongitudinalSpeedGroundReferenced, 16, 0.001000, 32, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.TransverseSpeedGroundReferenced, 16, 0.001000, 48, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SternSpeedWaterReferenced, 16, 0.001000, 64, 0, true)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SternSpeedGroundReferenced, 16, 0.001000, 80, 0, true)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type SonichubVolume struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    ProprietaryId SonichubCommandConst
    Control SonichubControlConst
    Zone *uint8
    Level *uint8
}
func DecodeSonichubVolume(Info MessageInfo, stream *DataStream) (any, error) {
    var val SonichubVolume
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for SonichubVolume-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 275 {
            return nil, fmt.Errorf("match failed for SonichubVolume-ManufacturerCode: Expected %d != %d", 275, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for SonichubVolume-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for SonichubVolume-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    stream.skipBits(8)
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SonichubVolume-ProprietaryId: %w", err)
    } else {
        val.ProprietaryId = SonichubCommandConst(v)
        if v != 24 {
            return nil, fmt.Errorf("match failed for SonichubVolume-ProprietaryId: Expected %d != %d", 24, v)
        }
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for SonichubVolume-Control: %w", err)
    } else {
        val.Control = SonichubControlConst(v)
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for SonichubVolume-Zone: %w", err)
    } else {
        val.Zone = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for SonichubVolume-Level: %w", err)
    } else {
        val.Level = v
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p SonichubVolume) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Control), 8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Zone, 8, 40)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Level, 8, 48)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type MaretronProprietaryTemperatureHighRange struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Sid *uint8
    Instance *uint8
    Source TemperatureSourceConst
    ActualTemperature *units.Temperature
    SetTemperature *units.Temperature
}
func DecodeMaretronProprietaryTemperatureHighRange(Info MessageInfo, stream *DataStream) (any, error) {
    var val MaretronProprietaryTemperatureHighRange
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 137 {
            return nil, fmt.Errorf("match failed for MaretronProprietaryTemperatureHighRange-ManufacturerCode: Expected %d != %d", 137, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for MaretronProprietaryTemperatureHighRange-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Sid: %w", err)
    } else {
        val.Sid = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readLookupField(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Source: %w", err)
    } else {
        val.Source = TemperatureSourceConst(v)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-ActualTemperature: %w", err)
    } else {
        val.ActualTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }
    if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-SetTemperature: %w", err)
    } else {
        val.SetTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p MaretronProprietaryTemperatureHighRange) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Sid, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.Source), 8, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.ActualTemperature, 16, 0.100000, 40, 0, false)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnit(p.SetTemperature, 16, 0.100000, 56, 0, false)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
type BGKeyValueDataRepeating1 struct {
    Key BandgKeyValueConst
    Length *uint8
    Value []uint8
}

type BGKeyValueData struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Repeating1 []BGKeyValueDataRepeating1
}
func DecodeBGKeyValueData(Info MessageInfo, stream *DataStream) (any, error) {
    var val BGKeyValueData
    val.Info = Info
    var repeat1Count uint16 = 0
		var valueLength uint16
	

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for BGKeyValueData-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 381 {
            return nil, fmt.Errorf("match failed for BGKeyValueData-ManufacturerCode: Expected %d != %d", 381, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for BGKeyValueData-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for BGKeyValueData-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    val.Repeating1 = make([]BGKeyValueDataRepeating1, 0)
    if stream.isEOF() {
        return val, nil
    }

    i := 0 
	for {
		var rep BGKeyValueDataRepeating1
		if v, err := stream.readLookupField(12); err != nil {
			return nil, fmt.Errorf("parse failed for BGKeyValueData-Key: %w", err)
		} else {
			rep.Key = BandgKeyValueConst(v)
		}
		if v, err := stream.readUInt8(4); err != nil {
			return nil, fmt.Errorf("parse failed for BGKeyValueData-Length: %w", err)
		} else {
			rep.Length = v
			if v != nil {
				valueLength = uint16(*v) * 8
			}
		
		}
		if v, err := stream.readBinaryData(valueLength); err != nil {
			return nil, fmt.Errorf("parse failed for BGKeyValueData-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }	
    return val, nil
}

// Encode implementation for complete variant
func (p BGKeyValueData) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}
func (p BGKeyValueData) encodeRepeating1(stream *DataStream) error {
     var err error
		var valueLength uint16
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        err = stream.putNumberRaw(uint64(p.Repeating1[index].Key), 12, 0)
        if err != nil {
            return err
        }
		if p.Repeating1[index].Length != nil {
			valueLength = uint16(*p.Repeating1[index].Length) * 8
		}
        err = stream.writeUint8(p.Repeating1[index].Length, 4, 0)
        if err != nil {
            return err
        }
        err = stream.writeBinary(p.Repeating1[index].Value, valueLength, 0)
        if err != nil {
            return err
        }
    }
    return nil
}

type MaretronSwitchStatusCounter struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Instance *uint8
    IndicatorNumber *uint8
    StartDate *uint16
    StartTime *float32
    OffCounter *uint32
    OnCounter *uint32
    ErrorCounter *uint32
    SwitchStatus OffOnConst
}
func DecodeMaretronSwitchStatusCounter(Info MessageInfo, stream *DataStream) (any, error) {
    var val MaretronSwitchStatusCounter
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 137 {
            return nil, fmt.Errorf("match failed for MaretronSwitchStatusCounter-ManufacturerCode: Expected %d != %d", 137, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for MaretronSwitchStatusCounter-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-IndicatorNumber: %w", err)
    } else {
        val.IndicatorNumber = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-StartDate: %w", err)
    } else {
        val.StartDate = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-StartTime: %w", err)
    } else {
        val.StartTime = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-OffCounter: %w", err)
    } else {
        val.OffCounter = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-OnCounter: %w", err)
    } else {
        val.OnCounter = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-ErrorCounter: %w", err)
    } else {
        val.ErrorCounter = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-SwitchStatus: %w", err)
    } else {
        val.SwitchStatus = OffOnConst(v)
    }
    stream.skipBits(6)	
    return val, nil
}

// Encode implementation for complete variant
func (p MaretronSwitchStatusCounter) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.IndicatorNumber, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.StartDate, 16, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.StartTime, 32, 0.0001, 48, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.OffCounter, 32, 80)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.OnCounter, 32, 112)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.ErrorCounter, 32, 144)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SwitchStatus), 2, 176)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 178)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}

type MaretronSwitchStatusTimer struct {
    Info MessageInfo
    ManufacturerCode ManufacturerCodeConst
    IndustryCode IndustryCodeConst
    Instance *uint8
    IndicatorNumber *uint8
    StartDate *uint16
    StartTime *float32
    AccumulatedOffPeriod *uint32
    AccumulatedOnPeriod *uint32
    AccumulatedErrorPeriod *uint32
    SwitchStatus OffOnConst
}
func DecodeMaretronSwitchStatusTimer(Info MessageInfo, stream *DataStream) (any, error) {
    var val MaretronSwitchStatusTimer
    val.Info = Info

    // Decode all non-repeating fields
    if v, err := stream.readLookupField(11); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-ManufacturerCode: %w", err)
    } else {
        val.ManufacturerCode = ManufacturerCodeConst(v)
        if v != 137 {
            return nil, fmt.Errorf("match failed for MaretronSwitchStatusTimer-ManufacturerCode: Expected %d != %d", 137, v)
        }
    }
    stream.skipBits(2)
    if v, err := stream.readLookupField(3); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-IndustryCode: %w", err)
    } else {
        val.IndustryCode = IndustryCodeConst(v)
        if v != 4 {
            return nil, fmt.Errorf("match failed for MaretronSwitchStatusTimer-IndustryCode: Expected %d != %d", 4, v)
        }
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-Instance: %w", err)
    } else {
        val.Instance = v
    }
    if v, err := stream.readUInt8(8); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-IndicatorNumber: %w", err)
    } else {
        val.IndicatorNumber = v
    }
    if v, err := stream.readUInt16(16); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-StartDate: %w", err)
    } else {
        val.StartDate = v
    }
    if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-StartTime: %w", err)
    } else {
        val.StartTime = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedOffPeriod: %w", err)
    } else {
        val.AccumulatedOffPeriod = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedOnPeriod: %w", err)
    } else {
        val.AccumulatedOnPeriod = v
    }
    if v, err := stream.readUInt32(32); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedErrorPeriod: %w", err)
    } else {
        val.AccumulatedErrorPeriod = v
    }
    if v, err := stream.readLookupField(2); err != nil {
        return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-SwitchStatus: %w", err)
    } else {
        val.SwitchStatus = OffOnConst(v)
    }
    stream.skipBits(6)	
    return val, nil
}

// Encode implementation for complete variant
func (p MaretronSwitchStatusTimer) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
    err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(2, 11)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.Instance, 8, 16)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint8(p.IndicatorNumber, 8, 24)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint16(p.StartDate, 16, 32)
    if err != nil {
        return nil, err
    }
    err = stream.writeUnsignedResolution32(p.StartTime, 32, 0.0001, 48, 0)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.AccumulatedOffPeriod, 32, 80)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.AccumulatedOnPeriod, 32, 112)
    if err != nil {
        return nil, err
    }
    err = stream.writeUint32(p.AccumulatedErrorPeriod, 32, 144)
    if err != nil {
        return nil, err
    }
    err = stream.putNumberRaw(uint64(p.SwitchStatus), 2, 176)
    if err != nil {
        return nil, err
    }
    err = stream.writeReserved(6, 178)
    if err != nil {
        return nil, err
    }
    return &p.Info, err
}


