// Code generated by "cmd/pgngen"; DO NOT EDIT.
package pgn


import (
	"fmt"
	"encoding/json"
	
	"github.com/boatkit-io/tugboat/pkg/units"
)

func nullableUnit[T any, U any, V float32|uint16|int16|uint32](u U, v *V, newer func(u U, v float32) T) *T {
	if v == nil {
		return nil
	}
	ov := newer(u, float32(*v))
	return &ov
}

// PgnInfo instances describe known NMEA 2000 messages.
type PgnInfo struct {
	// Id needed to distinguish pgns with KeyValue fields
	Id string
	// PGN (Parameter Group Number) identifies the Message
	PGN uint32
	// Description of the message.
	Description string
	// Fast if not single.
	Fast bool
	// ManId identifies the Manufacturer for Proprietary PGNs
	ManId ManufacturerCodeConst
	// Decoder is a function that generates golang data from the messsage data.
	Decoder func(MessageInfo, *DataStream) (any, error)
	// Instance is a zero instance of the struct used for testing
	// Fields is a map of field descriptions needed at runtime to deal with variable pgn fields
	Fields map[int]*FieldDescriptor
}

// FieldDescriptor instances describe a PGN field.
type FieldDescriptor struct {
	Name              string
	BitLength         uint16
	BitOffset         uint16
	BitLengthVariable bool
	CanboatType       string
	Resolution        float32
	Unit              string
	BitLookupName     string

	
}

// Spit out global consts

type LightingCommandConst uint8
const (
	Idle	LightingCommandConst = 0
	DetectDevices	LightingCommandConst = 1
	Reboot	LightingCommandConst = 2
	FactoryReset	LightingCommandConst = 3
	PoweringUp	LightingCommandConst = 4
)

func (e LightingCommandConst) GoString() string {return e.String() }
func (e LightingCommandConst) String() string {
	switch e {
		case 0:
			return "Idle"
		case 1:
			return "Detect Devices"
		case 2:
			return "Reboot"
		case 3:
			return "Factory Reset"
		case 4:
			return "Powering Up"
	default:
		return fmt.Sprintf("%s(%d)", "LightingCommandConst", int(e))
	}
}

type IndustryCodeConst uint8
const (
	Global	IndustryCodeConst = 0
	Highway	IndustryCodeConst = 1
	Agriculture	IndustryCodeConst = 2
	Construction	IndustryCodeConst = 3
	Marine	IndustryCodeConst = 4
	Industrial	IndustryCodeConst = 5
)

func (e IndustryCodeConst) GoString() string {return e.String() }
func (e IndustryCodeConst) String() string {
	switch e {
		case 0:
			return "Global"
		case 1:
			return "Highway"
		case 2:
			return "Agriculture"
		case 3:
			return "Construction"
		case 4:
			return "Marine"
		case 5:
			return "Industrial"
	default:
		return fmt.Sprintf("%s(%d)", "IndustryCodeConst", int(e))
	}
}

type ManufacturerCodeConst uint16
const (
	ARKSEnterprisesInc	ManufacturerCodeConst = 69
	FWMurphyEnovationControls	ManufacturerCodeConst = 78
	TwinDisc	ManufacturerCodeConst = 80
	KohlerPowerSystems	ManufacturerCodeConst = 85
	HemisphereGPSInc	ManufacturerCodeConst = 88
	BEPMarine	ManufacturerCodeConst = 116
	Airmar	ManufacturerCodeConst = 135
	Maretron	ManufacturerCodeConst = 137
	Lowrance	ManufacturerCodeConst = 140
	MercuryMarine	ManufacturerCodeConst = 144
	NautibusElectronicGmbH	ManufacturerCodeConst = 147
	BlueWaterData	ManufacturerCodeConst = 148
	Westerbeke	ManufacturerCodeConst = 154
	OffshoreSystemsUKLtd	ManufacturerCodeConst = 161
	EvinrudeBRP	ManufacturerCodeConst = 163
	CPACSystemsAB	ManufacturerCodeConst = 165
	XantrexTechnologyInc	ManufacturerCodeConst = 168
	YanmarMarine	ManufacturerCodeConst = 172
	VolvoPenta	ManufacturerCodeConst = 174
	HondaMarine	ManufacturerCodeConst = 175
	CarlingTechnologiesIncMoritzAerospace	ManufacturerCodeConst = 176
	BeedeInstruments	ManufacturerCodeConst = 185
	FloscanInstrumentCoInc	ManufacturerCodeConst = 192
	Nobletec	ManufacturerCodeConst = 193
	MysticValleyCommunications	ManufacturerCodeConst = 198
	Actia	ManufacturerCodeConst = 199
	HondaMarine_2	ManufacturerCodeConst = 200
	DisenosYTechnologia	ManufacturerCodeConst = 201
	DigitalSwitchingSystems	ManufacturerCodeConst = 211
	XintexAtena	ManufacturerCodeConst = 215
	EMMINETWORKSL	ManufacturerCodeConst = 224
	HondaMarine_3	ManufacturerCodeConst = 225
	ZF	ManufacturerCodeConst = 228
	Garmin	ManufacturerCodeConst = 229
	YachtMonitoringSolutions	ManufacturerCodeConst = 233
	SailormadeMarineTelemetryTetraTechnologyLTD	ManufacturerCodeConst = 235
	Eride	ManufacturerCodeConst = 243
	HondaMarine_4	ManufacturerCodeConst = 250
	HondaMotorCompanyLTD	ManufacturerCodeConst = 257
	Groco	ManufacturerCodeConst = 272
	Actisense	ManufacturerCodeConst = 273
	AmphenolLTWTechnology	ManufacturerCodeConst = 274
	Navico	ManufacturerCodeConst = 275
	HamiltonJet	ManufacturerCodeConst = 283
	SeaRecovery	ManufacturerCodeConst = 285
	CoelmoSRLItaly	ManufacturerCodeConst = 286
	BEPMarine_2	ManufacturerCodeConst = 295
	EmpirBus	ManufacturerCodeConst = 304
	NovAtel	ManufacturerCodeConst = 305
	SleipnerMotorAS	ManufacturerCodeConst = 306
	MBWTechnologies	ManufacturerCodeConst = 307
	FischerPanda	ManufacturerCodeConst = 311
	ICOM	ManufacturerCodeConst = 315
	Qwerty	ManufacturerCodeConst = 328
	Dief	ManufacturerCodeConst = 329
	BoeningAutomationstechnologieGmbHAndCoKG	ManufacturerCodeConst = 341
	KoreanMaritimeUniversity	ManufacturerCodeConst = 345
	ThraneAndThrane	ManufacturerCodeConst = 351
	Mastervolt	ManufacturerCodeConst = 355
	FischerPandaGenerators	ManufacturerCodeConst = 356
	VictronEnergy	ManufacturerCodeConst = 358
	RollsRoyceMarine	ManufacturerCodeConst = 370
	ElectronicDesign	ManufacturerCodeConst = 373
	NorthernLights	ManufacturerCodeConst = 374
	Glendinning	ManufacturerCodeConst = 378
	BAndG	ManufacturerCodeConst = 381
	RosePointNavigationSystems	ManufacturerCodeConst = 384
	JohnsonOutdoorsMarineElectronicsIncGeonav	ManufacturerCodeConst = 385
	Capi2	ManufacturerCodeConst = 394
	BeyondMeasure	ManufacturerCodeConst = 396
	LivorsiMarine	ManufacturerCodeConst = 400
	ComNav	ManufacturerCodeConst = 404
	Chetco	ManufacturerCodeConst = 409
	FusionElectronics	ManufacturerCodeConst = 419
	StandardHorizon	ManufacturerCodeConst = 421
	TrueHeadingAB	ManufacturerCodeConst = 422
	EgersundMarineElectronicsAS	ManufacturerCodeConst = 426
	EmTrakMarineElectronics	ManufacturerCodeConst = 427
	TohatsuCoJP	ManufacturerCodeConst = 431
	DigitalYacht	ManufacturerCodeConst = 437
	ComarSystemsLimited	ManufacturerCodeConst = 438
	Cummins	ManufacturerCodeConst = 440
	VDOAkaContinentalCorporation	ManufacturerCodeConst = 443
	ParkerHannifinAkaVillageMarineTech	ManufacturerCodeConst = 451
	AlltekMarineElectronicsCorp	ManufacturerCodeConst = 459
	SANGIORGIOSEIN	ManufacturerCodeConst = 460
	VeethreeElectronicsAndMarine	ManufacturerCodeConst = 466
	HumminbirdMarineElectronics	ManufacturerCodeConst = 467
	SITEXMarineElectronics	ManufacturerCodeConst = 470
	SeaCrossMarineAB	ManufacturerCodeConst = 471
	GMEAkaStandardCommunicationsPtyLTD	ManufacturerCodeConst = 475
	HumminbirdMarineElectronics_2	ManufacturerCodeConst = 476
	OceanSatBV	ManufacturerCodeConst = 478
	ChetcoDigitialInstruments	ManufacturerCodeConst = 481
	Watcheye	ManufacturerCodeConst = 493
	LcjCapteurs	ManufacturerCodeConst = 499
	AttwoodMarine	ManufacturerCodeConst = 502
	NaviopSRL	ManufacturerCodeConst = 503
	VesperMarineLtd	ManufacturerCodeConst = 504
	MarinesoftCoLTD	ManufacturerCodeConst = 510
	NoLandEngineering	ManufacturerCodeConst = 517
	TransasUSA	ManufacturerCodeConst = 518
	NationalInstrumentsKorea	ManufacturerCodeConst = 529
	OnwaMarine	ManufacturerCodeConst = 532
	MarinecraftSouthKorea	ManufacturerCodeConst = 571
	McMurdoGroupAkaOroliaLTD	ManufacturerCodeConst = 573
	Advansea	ManufacturerCodeConst = 578
	KVH	ManufacturerCodeConst = 579
	SanJoseTechnology	ManufacturerCodeConst = 580
	YachtControl	ManufacturerCodeConst = 583
	SuzukiMotorCorporation	ManufacturerCodeConst = 586
	USCoastGuard	ManufacturerCodeConst = 591
	ShipModuleAkaCustomware	ManufacturerCodeConst = 595
	AquaticAV	ManufacturerCodeConst = 600
	AventicsGmbH	ManufacturerCodeConst = 605
	Intellian	ManufacturerCodeConst = 606
	SamwonIT	ManufacturerCodeConst = 612
	ArltTecnologies	ManufacturerCodeConst = 614
	BavariaYacts	ManufacturerCodeConst = 637
	DiverseYachtServices	ManufacturerCodeConst = 641
	WemaUSADbaKUS	ManufacturerCodeConst = 644
	Garmin_2	ManufacturerCodeConst = 645
	ShenzhenJiuzhouHimunication	ManufacturerCodeConst = 658
	RockfordCorp	ManufacturerCodeConst = 688
	JLAudio	ManufacturerCodeConst = 704
	Autonnic	ManufacturerCodeConst = 715
	YachtDevices	ManufacturerCodeConst = 717
	REAPSystems	ManufacturerCodeConst = 734
	AuElectronicsGroup	ManufacturerCodeConst = 735
	LxNav	ManufacturerCodeConst = 739
	DaeMyung	ManufacturerCodeConst = 743
	Woosung	ManufacturerCodeConst = 744
	ClarionUS	ManufacturerCodeConst = 773
	HMISystems	ManufacturerCodeConst = 776
	OceanSignal	ManufacturerCodeConst = 777
	Seekeeper	ManufacturerCodeConst = 778
	PolyPlanar	ManufacturerCodeConst = 781
	FischerPandaDE	ManufacturerCodeConst = 785
	BroydaIndustries	ManufacturerCodeConst = 795
	CanadianAutomotive	ManufacturerCodeConst = 796
	TidesMarine	ManufacturerCodeConst = 797
	Lumishore	ManufacturerCodeConst = 798
	StillWaterDesignsAndAudio	ManufacturerCodeConst = 799
	BJTechnologiesBeneteau	ManufacturerCodeConst = 802
	GillSensors	ManufacturerCodeConst = 803
	BlueWaterDesalination	ManufacturerCodeConst = 811
	FLIR	ManufacturerCodeConst = 815
	UndheimSystems	ManufacturerCodeConst = 824
	TeamSurv	ManufacturerCodeConst = 838
	FellMarine	ManufacturerCodeConst = 844
	Oceanvolt	ManufacturerCodeConst = 847
	Prospec	ManufacturerCodeConst = 862
	DataPanelCorp	ManufacturerCodeConst = 868
	L3Technologies	ManufacturerCodeConst = 890
	RhodanMarineSystems	ManufacturerCodeConst = 894
	NexfourSolutions	ManufacturerCodeConst = 896
	ASAElectronics	ManufacturerCodeConst = 905
	MarinesCoSouthKorea	ManufacturerCodeConst = 909
	NauticOn	ManufacturerCodeConst = 911
	Ecotronix	ManufacturerCodeConst = 930
	TimbolierIndustries	ManufacturerCodeConst = 962
	TJCMicro	ManufacturerCodeConst = 963
	CoxPowertrain	ManufacturerCodeConst = 968
	BlueSeas	ManufacturerCodeConst = 969
	TeleflexMarineSeaStarSolutions	ManufacturerCodeConst = 1850
	Raymarine	ManufacturerCodeConst = 1851
	Navionics	ManufacturerCodeConst = 1852
	JapanRadioCo	ManufacturerCodeConst = 1853
	NorthstarTechnologies	ManufacturerCodeConst = 1854
	Furuno	ManufacturerCodeConst = 1855
	Trimble	ManufacturerCodeConst = 1856
	Simrad	ManufacturerCodeConst = 1857
	Litton	ManufacturerCodeConst = 1858
	KvasarAB	ManufacturerCodeConst = 1859
	MMP	ManufacturerCodeConst = 1860
	VectorCantech	ManufacturerCodeConst = 1861
	YamahaMarine	ManufacturerCodeConst = 1862
	FariaInstruments	ManufacturerCodeConst = 1863
)

func (e ManufacturerCodeConst) GoString() string {return e.String() }
func (e ManufacturerCodeConst) String() string {
	switch e {
		case 69:
			return "ARKS Enterprises, Inc."
		case 78:
			return "FW Murphy/Enovation Controls"
		case 80:
			return "Twin Disc"
		case 85:
			return "Kohler Power Systems"
		case 88:
			return "Hemisphere GPS Inc"
		case 116:
			return "BEP Marine"
		case 135:
			return "Airmar"
		case 137:
			return "Maretron"
		case 140:
			return "Lowrance"
		case 144:
			return "Mercury Marine"
		case 147:
			return "Nautibus Electronic GmbH"
		case 148:
			return "Blue Water Data"
		case 154:
			return "Westerbeke"
		case 161:
			return "Offshore Systems (UK) Ltd."
		case 163:
			return "Evinrude/BRP"
		case 165:
			return "CPAC Systems AB"
		case 168:
			return "Xantrex Technology Inc."
		case 172:
			return "Yanmar Marine"
		case 174:
			return "Volvo Penta"
		case 175:
			return "Honda Marine"
		case 176:
			return "Carling Technologies Inc. (Moritz Aerospace)"
		case 185:
			return "Beede Instruments"
		case 192:
			return "Floscan Instrument Co. Inc."
		case 193:
			return "Nobletec"
		case 198:
			return "Mystic Valley Communications"
		case 199:
			return "Actia"
		case 200:
			return "Honda Marine"
		case 201:
			return "Disenos Y Technologia"
		case 211:
			return "Digital Switching Systems"
		case 215:
			return "Xintex/Atena"
		case 224:
			return "EMMI NETWORK S.L."
		case 225:
			return "Honda Marine"
		case 228:
			return "ZF"
		case 229:
			return "Garmin"
		case 233:
			return "Yacht Monitoring Solutions"
		case 235:
			return "Sailormade Marine Telemetry/Tetra Technology LTD"
		case 243:
			return "Eride"
		case 250:
			return "Honda Marine"
		case 257:
			return "Honda Motor Company LTD"
		case 272:
			return "Groco"
		case 273:
			return "Actisense"
		case 274:
			return "Amphenol LTW Technology"
		case 275:
			return "Navico"
		case 283:
			return "Hamilton Jet"
		case 285:
			return "Sea Recovery"
		case 286:
			return "Coelmo SRL Italy"
		case 295:
			return "BEP Marine"
		case 304:
			return "Empir Bus"
		case 305:
			return "NovAtel"
		case 306:
			return "Sleipner Motor AS"
		case 307:
			return "MBW Technologies"
		case 311:
			return "Fischer Panda"
		case 315:
			return "ICOM"
		case 328:
			return "Qwerty"
		case 329:
			return "Dief"
		case 341:
			return "Boening Automationstechnologie GmbH & Co. KG"
		case 345:
			return "Korean Maritime University"
		case 351:
			return "Thrane and Thrane"
		case 355:
			return "Mastervolt"
		case 356:
			return "Fischer Panda Generators"
		case 358:
			return "Victron Energy"
		case 370:
			return "Rolls Royce Marine"
		case 373:
			return "Electronic Design"
		case 374:
			return "Northern Lights"
		case 378:
			return "Glendinning"
		case 381:
			return "B & G"
		case 384:
			return "Rose Point Navigation Systems"
		case 385:
			return "Johnson Outdoors Marine Electronics Inc Geonav"
		case 394:
			return "Capi 2"
		case 396:
			return "Beyond Measure"
		case 400:
			return "Livorsi Marine"
		case 404:
			return "ComNav"
		case 409:
			return "Chetco"
		case 419:
			return "Fusion Electronics"
		case 421:
			return "Standard Horizon"
		case 422:
			return "True Heading AB"
		case 426:
			return "Egersund Marine Electronics AS"
		case 427:
			return "em-trak Marine Electronics"
		case 431:
			return "Tohatsu Co, JP"
		case 437:
			return "Digital Yacht"
		case 438:
			return "Comar Systems Limited"
		case 440:
			return "Cummins"
		case 443:
			return "VDO (aka Continental-Corporation)"
		case 451:
			return "Parker Hannifin aka Village Marine Tech"
		case 459:
			return "Alltek Marine Electronics Corp"
		case 460:
			return "SAN GIORGIO S.E.I.N"
		case 466:
			return "Veethree Electronics & Marine"
		case 467:
			return "Humminbird Marine Electronics"
		case 470:
			return "SI-TEX Marine Electronics"
		case 471:
			return "Sea Cross Marine AB"
		case 475:
			return "GME aka Standard Communications Pty LTD"
		case 476:
			return "Humminbird Marine Electronics"
		case 478:
			return "Ocean Sat BV"
		case 481:
			return "Chetco Digitial Instruments"
		case 493:
			return "Watcheye"
		case 499:
			return "Lcj Capteurs"
		case 502:
			return "Attwood Marine"
		case 503:
			return "Naviop S.R.L."
		case 504:
			return "Vesper Marine Ltd"
		case 510:
			return "Marinesoft Co. LTD"
		case 517:
			return "NoLand Engineering"
		case 518:
			return "Transas USA"
		case 529:
			return "National Instruments Korea"
		case 532:
			return "Onwa Marine"
		case 571:
			return "Marinecraft (South Korea)"
		case 573:
			return "McMurdo Group aka Orolia LTD"
		case 578:
			return "Advansea"
		case 579:
			return "KVH"
		case 580:
			return "San Jose Technology"
		case 583:
			return "Yacht Control"
		case 586:
			return "Suzuki Motor Corporation"
		case 591:
			return "US Coast Guard"
		case 595:
			return "Ship Module aka Customware"
		case 600:
			return "Aquatic AV"
		case 605:
			return "Aventics GmbH"
		case 606:
			return "Intellian"
		case 612:
			return "SamwonIT"
		case 614:
			return "Arlt Tecnologies"
		case 637:
			return "Bavaria Yacts"
		case 641:
			return "Diverse Yacht Services"
		case 644:
			return "Wema U.S.A dba KUS"
		case 645:
			return "Garmin"
		case 658:
			return "Shenzhen Jiuzhou Himunication"
		case 688:
			return "Rockford Corp"
		case 704:
			return "JL Audio"
		case 715:
			return "Autonnic"
		case 717:
			return "Yacht Devices"
		case 734:
			return "REAP Systems"
		case 735:
			return "Au Electronics Group"
		case 739:
			return "LxNav"
		case 743:
			return "DaeMyung"
		case 744:
			return "Woosung"
		case 773:
			return "Clarion US"
		case 776:
			return "HMI Systems"
		case 777:
			return "Ocean Signal"
		case 778:
			return "Seekeeper"
		case 781:
			return "Poly Planar"
		case 785:
			return "Fischer Panda DE"
		case 795:
			return "Broyda Industries"
		case 796:
			return "Canadian Automotive"
		case 797:
			return "Tides Marine"
		case 798:
			return "Lumishore"
		case 799:
			return "Still Water Designs and Audio"
		case 802:
			return "BJ Technologies (Beneteau)"
		case 803:
			return "Gill Sensors"
		case 811:
			return "Blue Water Desalination"
		case 815:
			return "FLIR"
		case 824:
			return "Undheim Systems"
		case 838:
			return "TeamSurv"
		case 844:
			return "Fell Marine"
		case 847:
			return "Oceanvolt"
		case 862:
			return "Prospec"
		case 868:
			return "Data Panel Corp"
		case 890:
			return "L3 Technologies"
		case 894:
			return "Rhodan Marine Systems"
		case 896:
			return "Nexfour Solutions"
		case 905:
			return "ASA Electronics"
		case 909:
			return "Marines Co (South Korea)"
		case 911:
			return "Nautic-on"
		case 930:
			return "Ecotronix"
		case 962:
			return "Timbolier Industries"
		case 963:
			return "TJC Micro"
		case 968:
			return "Cox Powertrain"
		case 969:
			return "Blue Seas"
		case 1850:
			return "Teleflex Marine (SeaStar Solutions)"
		case 1851:
			return "Raymarine"
		case 1852:
			return "Navionics"
		case 1853:
			return "Japan Radio Co"
		case 1854:
			return "Northstar Technologies"
		case 1855:
			return "Furuno"
		case 1856:
			return "Trimble"
		case 1857:
			return "Simrad"
		case 1858:
			return "Litton"
		case 1859:
			return "Kvasar AB"
		case 1860:
			return "MMP"
		case 1861:
			return "Vector Cantech"
		case 1862:
			return "Yamaha Marine"
		case 1863:
			return "Faria Instruments"
	default:
		return fmt.Sprintf("%s(%d)", "ManufacturerCodeConst", int(e))
	}
}

type AisMessageIdConst uint8
const (
	ScheduledClassAPositionReport	AisMessageIdConst = 1
	AssignedScheduledClassAPositionReport	AisMessageIdConst = 2
	InterrogatedClassAPositionReport	AisMessageIdConst = 3
	BaseStationReport	AisMessageIdConst = 4
	StaticAndVoyageRelatedData	AisMessageIdConst = 5
	BinaryAddressedMessage	AisMessageIdConst = 6
	BinaryAcknowledgement	AisMessageIdConst = 7
	BinaryBroadcastMessage	AisMessageIdConst = 8
	StandardSARAircraftPositionReport	AisMessageIdConst = 9
	UTCDateInquiry	AisMessageIdConst = 10
	UTCDateResponse	AisMessageIdConst = 11
	SafetyRelatedAddressedMessage	AisMessageIdConst = 12
	SafetyRelatedAcknowledgement	AisMessageIdConst = 13
	SatetyRelatedBroadcastMessage	AisMessageIdConst = 14
	Interrogation	AisMessageIdConst = 15
	AssignmentModeCommand	AisMessageIdConst = 16
	DGNSSBroadcastBinaryMessage	AisMessageIdConst = 17
	StandardClassBPositionReport	AisMessageIdConst = 18
	ExtendedClassBPositionReport	AisMessageIdConst = 19
	DataLinkManagementMessage	AisMessageIdConst = 20
	ATONReport	AisMessageIdConst = 21
	ChannelManagement	AisMessageIdConst = 22
	GroupAssignmentCommand	AisMessageIdConst = 23
	StaticDataReport	AisMessageIdConst = 24
	SingleSlotBinaryMessage	AisMessageIdConst = 25
	MultipleSlotBinaryMessage	AisMessageIdConst = 26
	PositionReportForLongRangeApplications	AisMessageIdConst = 27
)

func (e AisMessageIdConst) GoString() string {return e.String() }
func (e AisMessageIdConst) String() string {
	switch e {
		case 1:
			return "Scheduled Class A position report"
		case 2:
			return "Assigned scheduled Class A position report"
		case 3:
			return "Interrogated Class A position report"
		case 4:
			return "Base station report"
		case 5:
			return "Static and voyage related data"
		case 6:
			return "Binary addressed message"
		case 7:
			return "Binary acknowledgement"
		case 8:
			return "Binary broadcast message"
		case 9:
			return "Standard SAR aircraft position report"
		case 10:
			return "UTC/date inquiry"
		case 11:
			return "UTC/date response"
		case 12:
			return "Safety related addressed message"
		case 13:
			return "Safety related acknowledgement"
		case 14:
			return "Satety related broadcast message"
		case 15:
			return "Interrogation"
		case 16:
			return "Assignment mode command"
		case 17:
			return "DGNSS broadcast binary message"
		case 18:
			return "Standard Class B position report"
		case 19:
			return "Extended Class B position report"
		case 20:
			return "Data link management message"
		case 21:
			return "ATON report"
		case 22:
			return "Channel management"
		case 23:
			return "Group assignment command"
		case 24:
			return "Static data report"
		case 25:
			return "Single slot binary message"
		case 26:
			return "Multiple slot binary message"
		case 27:
			return "Position report for long range applications"
	default:
		return fmt.Sprintf("%s(%d)", "AisMessageIdConst", int(e))
	}
}

type ShipTypeConst uint8
const (
	Unavailable	ShipTypeConst = 0
	WingInGround	ShipTypeConst = 20
	WingInGroundHazardCatX	ShipTypeConst = 21
	WingInGroundHazardCatY	ShipTypeConst = 22
	WingInGroundHazardCatZ	ShipTypeConst = 23
	WingInGroundHazardCatOS	ShipTypeConst = 24
	WingInGroundNoAdditionalInformation	ShipTypeConst = 29
	Fishing	ShipTypeConst = 30
	Towing	ShipTypeConst = 31
	TowingExceeds200mOrWiderThan25m	ShipTypeConst = 32
	EngagedInDredgingOrUnderwaterOperations	ShipTypeConst = 33
	EngagedInDivingOperations	ShipTypeConst = 34
	EngagedInMilitaryOperations	ShipTypeConst = 35
	Sailing	ShipTypeConst = 36
	Pleasure	ShipTypeConst = 37
	HighSpeedCraft	ShipTypeConst = 40
	HighSpeedCraftHazardCatX	ShipTypeConst = 41
	HighSpeedCraftHazardCatY	ShipTypeConst = 42
	HighSpeedCraftHazardCatZ	ShipTypeConst = 43
	HighSpeedCraftHazardCatOS	ShipTypeConst = 44
	HighSpeedCraftNoAdditionalInformation	ShipTypeConst = 49
	PilotVessel	ShipTypeConst = 50
	SAR	ShipTypeConst = 51
	Tug	ShipTypeConst = 52
	PortTender	ShipTypeConst = 53
	AntiPollution	ShipTypeConst = 54
	LawEnforcement	ShipTypeConst = 55
	Spare	ShipTypeConst = 56
	Spare2	ShipTypeConst = 57
	Medical	ShipTypeConst = 58
	ShipsAndAircraftOfStatesNotPartiesToAnArmedConflict	ShipTypeConst = 59
	PassengerShip	ShipTypeConst = 60
	PassengerShipHazardCatX	ShipTypeConst = 61
	PassengerShipHazardCatY	ShipTypeConst = 62
	PassengerShipHazardCatZ	ShipTypeConst = 63
	PassengerShipHazardCatOS	ShipTypeConst = 64
	PassengerShipNoAdditionalInformation	ShipTypeConst = 69
	CargoShip	ShipTypeConst = 70
	CargoShipHazardCatX	ShipTypeConst = 71
	CargoShipHazardCatY	ShipTypeConst = 72
	CargoShipHazardCatZ	ShipTypeConst = 73
	CargoShipHazardCatOS	ShipTypeConst = 74
	CargoShipNoAdditionalInformation	ShipTypeConst = 79
	Tanker	ShipTypeConst = 80
	TankerHazardCatX	ShipTypeConst = 81
	TankerHazardCatY	ShipTypeConst = 82
	TankerHazardCatZ	ShipTypeConst = 83
	TankerHazardCatOS	ShipTypeConst = 84
	TankerNoAdditionalInformation	ShipTypeConst = 89
	Other	ShipTypeConst = 90
	OtherHazardCatX	ShipTypeConst = 91
	OtherHazardCatY	ShipTypeConst = 92
	OtherHazardCatZ	ShipTypeConst = 93
	OtherHazardCatOS	ShipTypeConst = 94
	OtherNoAdditionalInformation	ShipTypeConst = 99
)

func (e ShipTypeConst) GoString() string {return e.String() }
func (e ShipTypeConst) String() string {
	switch e {
		case 0:
			return "Unavailable"
		case 20:
			return "Wing In Ground"
		case 21:
			return "Wing In Ground (hazard cat X)"
		case 22:
			return "Wing In Ground (hazard cat Y)"
		case 23:
			return "Wing In Ground (hazard cat Z)"
		case 24:
			return "Wing In Ground (hazard cat OS)"
		case 29:
			return "Wing In Ground (no additional information)"
		case 30:
			return "Fishing"
		case 31:
			return "Towing"
		case 32:
			return "Towing exceeds 200m or wider than 25m"
		case 33:
			return "Engaged in dredging or underwater operations"
		case 34:
			return "Engaged in diving operations"
		case 35:
			return "Engaged in military operations"
		case 36:
			return "Sailing"
		case 37:
			return "Pleasure"
		case 40:
			return "High speed craft"
		case 41:
			return "High speed craft (hazard cat X)"
		case 42:
			return "High speed craft (hazard cat Y)"
		case 43:
			return "High speed craft (hazard cat Z)"
		case 44:
			return "High speed craft (hazard cat OS)"
		case 49:
			return "High speed craft (no additional information)"
		case 50:
			return "Pilot vessel"
		case 51:
			return "SAR"
		case 52:
			return "Tug"
		case 53:
			return "Port tender"
		case 54:
			return "Anti-pollution"
		case 55:
			return "Law enforcement"
		case 56:
			return "Spare"
		case 57:
			return "Spare #2"
		case 58:
			return "Medical"
		case 59:
			return "Ships and aircraft of States not parties to an armed conflict"
		case 60:
			return "Passenger ship"
		case 61:
			return "Passenger ship (hazard cat X)"
		case 62:
			return "Passenger ship (hazard cat Y)"
		case 63:
			return "Passenger ship (hazard cat Z)"
		case 64:
			return "Passenger ship (hazard cat OS)"
		case 69:
			return "Passenger ship (no additional information)"
		case 70:
			return "Cargo ship"
		case 71:
			return "Cargo ship (hazard cat X)"
		case 72:
			return "Cargo ship (hazard cat Y)"
		case 73:
			return "Cargo ship (hazard cat Z)"
		case 74:
			return "Cargo ship (hazard cat OS)"
		case 79:
			return "Cargo ship (no additional information)"
		case 80:
			return "Tanker"
		case 81:
			return "Tanker (hazard cat X)"
		case 82:
			return "Tanker (hazard cat Y)"
		case 83:
			return "Tanker (hazard cat Z)"
		case 84:
			return "Tanker (hazard cat OS)"
		case 89:
			return "Tanker (no additional information)"
		case 90:
			return "Other"
		case 91:
			return "Other (hazard cat X)"
		case 92:
			return "Other (hazard cat Y)"
		case 93:
			return "Other (hazard cat Z)"
		case 94:
			return "Other (hazard cat OS)"
		case 99:
			return "Other (no additional information)"
	default:
		return fmt.Sprintf("%s(%d)", "ShipTypeConst", int(e))
	}
}

type DeviceClassConst uint8
const (
	ReservedFor2000Use	DeviceClassConst = 0
	SystemTools	DeviceClassConst = 10
	SafetySystems	DeviceClassConst = 20
	InternetworkDevice	DeviceClassConst = 25
	ElectricalDistribution	DeviceClassConst = 30
	ElectricalGeneration	DeviceClassConst = 35
	SteeringAndControlSurfaces	DeviceClassConst = 40
	Propulsion	DeviceClassConst = 50
	Navigation	DeviceClassConst = 60
	Communication	DeviceClassConst = 70
	SensorCommunicationInterface	DeviceClassConst = 75
	InstrumentationGeneralSystems	DeviceClassConst = 80
	ExternalEnvironment	DeviceClassConst = 85
	InternalEnvironment	DeviceClassConst = 90
	DeckCargoFishingEquipmentSystems	DeviceClassConst = 100
	HumanInterface	DeviceClassConst = 110
	Display	DeviceClassConst = 120
	Entertainment	DeviceClassConst = 125
)

func (e DeviceClassConst) GoString() string {return e.String() }
func (e DeviceClassConst) String() string {
	switch e {
		case 0:
			return "Reserved for 2000 Use"
		case 10:
			return "System tools"
		case 20:
			return "Safety systems"
		case 25:
			return "Internetwork device"
		case 30:
			return "Electrical Distribution"
		case 35:
			return "Electrical Generation"
		case 40:
			return "Steering and Control surfaces"
		case 50:
			return "Propulsion"
		case 60:
			return "Navigation"
		case 70:
			return "Communication"
		case 75:
			return "Sensor Communication Interface"
		case 80:
			return "Instrumentation/general systems"
		case 85:
			return "External Environment"
		case 90:
			return "Internal Environment"
		case 100:
			return "Deck + cargo + fishing equipment systems"
		case 110:
			return "Human Interface"
		case 120:
			return "Display"
		case 125:
			return "Entertainment"
	default:
		return fmt.Sprintf("%s(%d)", "DeviceClassConst", int(e))
	}
}

type RepeatIndicatorConst uint8
const (
	Initial	RepeatIndicatorConst = 0
	FirstRetransmission	RepeatIndicatorConst = 1
	SecondRetransmission	RepeatIndicatorConst = 2
	FinalRetransmission	RepeatIndicatorConst = 3
)

func (e RepeatIndicatorConst) GoString() string {return e.String() }
func (e RepeatIndicatorConst) String() string {
	switch e {
		case 0:
			return "Initial"
		case 1:
			return "First retransmission"
		case 2:
			return "Second retransmission"
		case 3:
			return "Final retransmission"
	default:
		return fmt.Sprintf("%s(%d)", "RepeatIndicatorConst", int(e))
	}
}

type TxRxModeConst uint8
const (
	TxATxBRxARxB	TxRxModeConst = 0
	TxARxARxB	TxRxModeConst = 1
	TxBRxARxB	TxRxModeConst = 2
)

func (e TxRxModeConst) GoString() string {return e.String() }
func (e TxRxModeConst) String() string {
	switch e {
		case 0:
			return "Tx A/Tx B, Rx A/Rx B"
		case 1:
			return "Tx A, Rx A/Rx B"
		case 2:
			return "Tx B, Rx A/Rx B"
	default:
		return fmt.Sprintf("%s(%d)", "TxRxModeConst", int(e))
	}
}

type StationTypeConst uint8
const (
	AllTypesOfMobileStation	StationTypeConst = 0
	AllTypesOfClassBMobileStation	StationTypeConst = 2
	SARAirborneMobileStation	StationTypeConst = 3
	AtoNStation	StationTypeConst = 4
	ClassBCSShipborneMobileStation	StationTypeConst = 5
	InlandWaterways	StationTypeConst = 6
	RegionalUse7	StationTypeConst = 7
	RegionalUse8	StationTypeConst = 8
	RegionalUse9	StationTypeConst = 9
)

func (e StationTypeConst) GoString() string {return e.String() }
func (e StationTypeConst) String() string {
	switch e {
		case 0:
			return "All types of mobile station"
		case 2:
			return "All types of Class B mobile station"
		case 3:
			return "SAR airborne mobile station"
		case 4:
			return "AtoN station"
		case 5:
			return "Class B CS shipborne mobile station"
		case 6:
			return "Inland waterways"
		case 7:
			return "Regional use 7"
		case 8:
			return "Regional use 8"
		case 9:
			return "Regional use 9"
	default:
		return fmt.Sprintf("%s(%d)", "StationTypeConst", int(e))
	}
}

type ReportingIntervalConst uint8
const (
	AsGivenByTheAutonomousMode	ReportingIntervalConst = 0
	A10Min	ReportingIntervalConst = 1
	A6Min	ReportingIntervalConst = 2
	A3Min	ReportingIntervalConst = 3
	A1Min	ReportingIntervalConst = 4
	A30Sec	ReportingIntervalConst = 5
	A15Sec	ReportingIntervalConst = 6
	A10Sec	ReportingIntervalConst = 7
	A5Sec	ReportingIntervalConst = 8
	A2SecNotApplicableToClassBCS	ReportingIntervalConst = 9
	NextShorterReportingInterval	ReportingIntervalConst = 10
	NextLongerReportingInterval	ReportingIntervalConst = 11
)

func (e ReportingIntervalConst) GoString() string {return e.String() }
func (e ReportingIntervalConst) String() string {
	switch e {
		case 0:
			return "As given by the autonomous mode"
		case 1:
			return "A10 min"
		case 2:
			return "A6 min"
		case 3:
			return "A3 min"
		case 4:
			return "A1 min"
		case 5:
			return "A30 sec"
		case 6:
			return "A15 sec"
		case 7:
			return "A10 sec"
		case 8:
			return "A5 sec"
		case 9:
			return "A2 sec (not applicable to Class B CS)"
		case 10:
			return "Next shorter reporting interval"
		case 11:
			return "Next longer reporting interval"
	default:
		return fmt.Sprintf("%s(%d)", "ReportingIntervalConst", int(e))
	}
}

type AisTransceiverConst uint8
const (
	ChannelAVDLReception	AisTransceiverConst = 0
	ChannelBVDLReception	AisTransceiverConst = 1
	ChannelAVDLTransmission	AisTransceiverConst = 2
	ChannelBVDLTransmission	AisTransceiverConst = 3
	OwnInformationNotBroadcast	AisTransceiverConst = 4
	Reserved	AisTransceiverConst = 5
)

func (e AisTransceiverConst) GoString() string {return e.String() }
func (e AisTransceiverConst) String() string {
	switch e {
		case 0:
			return "Channel A VDL reception"
		case 1:
			return "Channel B VDL reception"
		case 2:
			return "Channel A VDL transmission"
		case 3:
			return "Channel B VDL transmission"
		case 4:
			return "Own information not broadcast"
		case 5:
			return "Reserved"
	default:
		return fmt.Sprintf("%s(%d)", "AisTransceiverConst", int(e))
	}
}

type AisAssignedModeConst uint8
const (
	AutonomousAndContinuous	AisAssignedModeConst = 0
	AssignedMode	AisAssignedModeConst = 1
)

func (e AisAssignedModeConst) GoString() string {return e.String() }
func (e AisAssignedModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous and continuous"
		case 1:
			return "Assigned mode"
	default:
		return fmt.Sprintf("%s(%d)", "AisAssignedModeConst", int(e))
	}
}

type AtonTypeConst uint8
const (
	DefaultTypeOfAtoNNotSpecified	AtonTypeConst = 0
	ReferencePoint	AtonTypeConst = 1
	RACON	AtonTypeConst = 2
	FixedStructureOffShore	AtonTypeConst = 3
	ReservedForFutureUse	AtonTypeConst = 4
	FixedLightWithoutSectors	AtonTypeConst = 5
	FixedLightWithSectors	AtonTypeConst = 6
	FixedLeadingLightFront	AtonTypeConst = 7
	FixedLeadingLightRear	AtonTypeConst = 8
	FixedBeaconCardinalN	AtonTypeConst = 9
	FixedBeaconCardinalE	AtonTypeConst = 10
	FixedBeaconCardinalS	AtonTypeConst = 11
	FixedBeaconCardinalW	AtonTypeConst = 12
	FixedBeaconPortHand	AtonTypeConst = 13
	FixedBeaconStarboardHand	AtonTypeConst = 14
	FixedBeaconPreferredChannelPortHand	AtonTypeConst = 15
	FixedBeaconPreferredChannelStarboardHand	AtonTypeConst = 16
	FixedBeaconIsolatedDanger	AtonTypeConst = 17
	FixedBeaconSafeWater	AtonTypeConst = 18
	FixedBeaconSpecialMark	AtonTypeConst = 19
	FloatingAtoNCardinalN	AtonTypeConst = 20
	FloatingAtoNCardinalE	AtonTypeConst = 21
	FloatingAtoNCardinalS	AtonTypeConst = 22
	FloatingAtoNCardinalW	AtonTypeConst = 23
	FloatingAtoNPortHandMark	AtonTypeConst = 24
	FloatingAtoNStarboardHandMark	AtonTypeConst = 25
	FloatingAtoNPreferredChannelPortHand	AtonTypeConst = 26
	FloatingAtoNPreferredChannelStarboardHand	AtonTypeConst = 27
	FloatingAtoNIsolatedDanger	AtonTypeConst = 28
	FloatingAtoNSafeWater	AtonTypeConst = 29
	FloatingAtoNSpecialMark	AtonTypeConst = 30
	FloatingAtoNLightVesselLANBYRigs	AtonTypeConst = 31
)

func (e AtonTypeConst) GoString() string {return e.String() }
func (e AtonTypeConst) String() string {
	switch e {
		case 0:
			return "Default: Type of AtoN not specified"
		case 1:
			return "Reference point"
		case 2:
			return "RACON"
		case 3:
			return "Fixed structure off-shore"
		case 4:
			return "Reserved for future use"
		case 5:
			return "Fixed light: without sectors"
		case 6:
			return "Fixed light: with sectors"
		case 7:
			return "Fixed leading light front"
		case 8:
			return "Fixed leading light rear"
		case 9:
			return "Fixed beacon: cardinal N"
		case 10:
			return "Fixed beacon: cardinal E"
		case 11:
			return "Fixed beacon: cardinal S"
		case 12:
			return "Fixed beacon: cardinal W"
		case 13:
			return "Fixed beacon: port hand"
		case 14:
			return "Fixed beacon: starboard hand"
		case 15:
			return "Fixed beacon: preferred channel port hand"
		case 16:
			return "Fixed beacon: preferred channel starboard hand"
		case 17:
			return "Fixed beacon: isolated danger"
		case 18:
			return "Fixed beacon: safe water"
		case 19:
			return "Fixed beacon: special mark"
		case 20:
			return "Floating AtoN: cardinal N"
		case 21:
			return "Floating AtoN: cardinal E"
		case 22:
			return "Floating AtoN: cardinal S"
		case 23:
			return "Floating AtoN: cardinal W"
		case 24:
			return "Floating AtoN: port hand mark"
		case 25:
			return "Floating AtoN: starboard hand mark"
		case 26:
			return "Floating AtoN: preferred channel port hand"
		case 27:
			return "Floating AtoN: preferred channel starboard hand"
		case 28:
			return "Floating AtoN: isolated danger"
		case 29:
			return "Floating AtoN: safe water"
		case 30:
			return "Floating AtoN: special mark"
		case 31:
			return "Floating AtoN: light vessel/LANBY/rigs"
	default:
		return fmt.Sprintf("%s(%d)", "AtonTypeConst", int(e))
	}
}

type AisSpecialManeuverConst uint8
const (
	NotAvailable	AisSpecialManeuverConst = 0
	NotEngagedInSpecialManeuver	AisSpecialManeuverConst = 1
	EngagedInSpecialManeuver	AisSpecialManeuverConst = 2
	Reserved_2	AisSpecialManeuverConst = 3
)

func (e AisSpecialManeuverConst) GoString() string {return e.String() }
func (e AisSpecialManeuverConst) String() string {
	switch e {
		case 0:
			return "Not available"
		case 1:
			return "Not engaged in special maneuver"
		case 2:
			return "Engaged in special maneuver"
		case 3:
			return "Reserved"
	default:
		return fmt.Sprintf("%s(%d)", "AisSpecialManeuverConst", int(e))
	}
}

type PositionFixDeviceConst uint8
const (
	DefaultUndefined	PositionFixDeviceConst = 0
	GPS	PositionFixDeviceConst = 1
	GLONASS	PositionFixDeviceConst = 2
	CombinedGPSGLONASS	PositionFixDeviceConst = 3
	LoranC	PositionFixDeviceConst = 4
	Chayka	PositionFixDeviceConst = 5
	IntegratedNavigationSystem	PositionFixDeviceConst = 6
	Surveyed	PositionFixDeviceConst = 7
	Galileo	PositionFixDeviceConst = 8
	InternalGNSS	PositionFixDeviceConst = 15
)

func (e PositionFixDeviceConst) GoString() string {return e.String() }
func (e PositionFixDeviceConst) String() string {
	switch e {
		case 0:
			return "Default: undefined"
		case 1:
			return "GPS"
		case 2:
			return "GLONASS"
		case 3:
			return "Combined GPS/GLONASS"
		case 4:
			return "Loran-C"
		case 5:
			return "Chayka"
		case 6:
			return "Integrated navigation system"
		case 7:
			return "Surveyed"
		case 8:
			return "Galileo"
		case 15:
			return "Internal GNSS"
	default:
		return fmt.Sprintf("%s(%d)", "PositionFixDeviceConst", int(e))
	}
}

type GnsConst uint8
const (
	GPS_2	GnsConst = 0
	GLONASS_2	GnsConst = 1
	GPSGLONASS	GnsConst = 2
	GPSSBASWAAS	GnsConst = 3
	GPSSBASWAASGLONASS	GnsConst = 4
	Chayka_2	GnsConst = 5
	Integrated	GnsConst = 6
	Surveyed_2	GnsConst = 7
	Galileo_2	GnsConst = 8
)

func (e GnsConst) GoString() string {return e.String() }
func (e GnsConst) String() string {
	switch e {
		case 0:
			return "GPS"
		case 1:
			return "GLONASS"
		case 2:
			return "GPS+GLONASS"
		case 3:
			return "GPS+SBAS/WAAS"
		case 4:
			return "GPS+SBAS/WAAS+GLONASS"
		case 5:
			return "Chayka"
		case 6:
			return "integrated"
		case 7:
			return "surveyed"
		case 8:
			return "Galileo"
	default:
		return fmt.Sprintf("%s(%d)", "GnsConst", int(e))
	}
}

type EngineInstanceConst uint8
const (
	SingleEngineOrDualEnginePort	EngineInstanceConst = 0
	DualEngineStarboard	EngineInstanceConst = 1
)

func (e EngineInstanceConst) GoString() string {return e.String() }
func (e EngineInstanceConst) String() string {
	switch e {
		case 0:
			return "Single Engine or Dual Engine Port"
		case 1:
			return "Dual Engine Starboard"
	default:
		return fmt.Sprintf("%s(%d)", "EngineInstanceConst", int(e))
	}
}

type GearStatusConst uint8
const (
	Forward	GearStatusConst = 0
	Neutral	GearStatusConst = 1
	Reverse	GearStatusConst = 2
)

func (e GearStatusConst) GoString() string {return e.String() }
func (e GearStatusConst) String() string {
	switch e {
		case 0:
			return "Forward"
		case 1:
			return "Neutral"
		case 2:
			return "Reverse"
	default:
		return fmt.Sprintf("%s(%d)", "GearStatusConst", int(e))
	}
}

type DirectionConst uint8
const (
	Forward_2	DirectionConst = 0
	Reverse_2	DirectionConst = 1
)

func (e DirectionConst) GoString() string {return e.String() }
func (e DirectionConst) String() string {
	switch e {
		case 0:
			return "Forward"
		case 1:
			return "Reverse"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionConst", int(e))
	}
}

type PositionAccuracyConst uint8
const (
	Low	PositionAccuracyConst = 0
	High	PositionAccuracyConst = 1
)

func (e PositionAccuracyConst) GoString() string {return e.String() }
func (e PositionAccuracyConst) String() string {
	switch e {
		case 0:
			return "Low"
		case 1:
			return "High"
	default:
		return fmt.Sprintf("%s(%d)", "PositionAccuracyConst", int(e))
	}
}

type RaimFlagConst uint8
const (
	NotInUse	RaimFlagConst = 0
	InUse	RaimFlagConst = 1
)

func (e RaimFlagConst) GoString() string {return e.String() }
func (e RaimFlagConst) String() string {
	switch e {
		case 0:
			return "not in use"
		case 1:
			return "in use"
	default:
		return fmt.Sprintf("%s(%d)", "RaimFlagConst", int(e))
	}
}

type TimeStampConst uint8
const (
	NotAvailable_2	TimeStampConst = 60
	ManualInputMode	TimeStampConst = 61
	DeadReckoningMode	TimeStampConst = 62
	PositioningSystemIsInoperative	TimeStampConst = 63
)

func (e TimeStampConst) GoString() string {return e.String() }
func (e TimeStampConst) String() string {
	switch e {
		case 60:
			return "Not available"
		case 61:
			return "Manual input mode"
		case 62:
			return "Dead reckoning mode"
		case 63:
			return "Positioning system is inoperative"
	default:
		return fmt.Sprintf("%s(%d)", "TimeStampConst", int(e))
	}
}

type GnsMethodConst uint8
const (
	NoGNSS	GnsMethodConst = 0
	GNSSFix	GnsMethodConst = 1
	DGNSSFix	GnsMethodConst = 2
	PreciseGNSS	GnsMethodConst = 3
	RTKFixedInteger	GnsMethodConst = 4
	RTKFloat	GnsMethodConst = 5
	EstimatedDRMode	GnsMethodConst = 6
	ManualInput	GnsMethodConst = 7
	SimulateMode	GnsMethodConst = 8
)

func (e GnsMethodConst) GoString() string {return e.String() }
func (e GnsMethodConst) String() string {
	switch e {
		case 0:
			return "no GNSS"
		case 1:
			return "GNSS fix"
		case 2:
			return "DGNSS fix"
		case 3:
			return "Precise GNSS"
		case 4:
			return "RTK Fixed Integer"
		case 5:
			return "RTK float"
		case 6:
			return "Estimated (DR) mode"
		case 7:
			return "Manual Input"
		case 8:
			return "Simulate mode"
	default:
		return fmt.Sprintf("%s(%d)", "GnsMethodConst", int(e))
	}
}

type GnsIntegrityConst uint8
const (
	NoIntegrityChecking	GnsIntegrityConst = 0
	Safe	GnsIntegrityConst = 1
	Caution	GnsIntegrityConst = 2
)

func (e GnsIntegrityConst) GoString() string {return e.String() }
func (e GnsIntegrityConst) String() string {
	switch e {
		case 0:
			return "No integrity checking"
		case 1:
			return "Safe"
		case 2:
			return "Caution"
	default:
		return fmt.Sprintf("%s(%d)", "GnsIntegrityConst", int(e))
	}
}

type SystemTimeConst uint8
const (
	GPS_3	SystemTimeConst = 0
	GLONASS_3	SystemTimeConst = 1
	RadioStation	SystemTimeConst = 2
	LocalCesiumClock	SystemTimeConst = 3
	LocalRubidiumClock	SystemTimeConst = 4
	LocalCrystalClock	SystemTimeConst = 5
)

func (e SystemTimeConst) GoString() string {return e.String() }
func (e SystemTimeConst) String() string {
	switch e {
		case 0:
			return "GPS"
		case 1:
			return "GLONASS"
		case 2:
			return "Radio Station"
		case 3:
			return "Local Cesium clock"
		case 4:
			return "Local Rubidium clock"
		case 5:
			return "Local Crystal clock"
	default:
		return fmt.Sprintf("%s(%d)", "SystemTimeConst", int(e))
	}
}

type MagneticVariationConst uint8
const (
	Manual	MagneticVariationConst = 0
	AutomaticChart	MagneticVariationConst = 1
	AutomaticTable	MagneticVariationConst = 2
	AutomaticCalculation	MagneticVariationConst = 3
	WMM2000	MagneticVariationConst = 4
	WMM2005	MagneticVariationConst = 5
	WMM2010	MagneticVariationConst = 6
	WMM2015	MagneticVariationConst = 7
	WMM2020	MagneticVariationConst = 8
)

func (e MagneticVariationConst) GoString() string {return e.String() }
func (e MagneticVariationConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Automatic Chart"
		case 2:
			return "Automatic Table"
		case 3:
			return "Automatic Calculation"
		case 4:
			return "WMM 2000"
		case 5:
			return "WMM 2005"
		case 6:
			return "WMM 2010"
		case 7:
			return "WMM 2015"
		case 8:
			return "WMM 2020"
	default:
		return fmt.Sprintf("%s(%d)", "MagneticVariationConst", int(e))
	}
}

type ResidualModeConst uint8
const (
	Autonomous	ResidualModeConst = 0
	DifferentialEnhanced	ResidualModeConst = 1
	Estimated	ResidualModeConst = 2
	Simulator	ResidualModeConst = 3
	Manual_2	ResidualModeConst = 4
)

func (e ResidualModeConst) GoString() string {return e.String() }
func (e ResidualModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous"
		case 1:
			return "Differential enhanced"
		case 2:
			return "Estimated"
		case 3:
			return "Simulator"
		case 4:
			return "Manual"
	default:
		return fmt.Sprintf("%s(%d)", "ResidualModeConst", int(e))
	}
}

type WindReferenceConst uint8
const (
	TrueGroundReferencedToNorth	WindReferenceConst = 0
	MagneticGroundReferencedToMagneticNorth	WindReferenceConst = 1
	Apparent	WindReferenceConst = 2
	TrueBoatReferenced	WindReferenceConst = 3
	TrueWaterReferenced	WindReferenceConst = 4
)

func (e WindReferenceConst) GoString() string {return e.String() }
func (e WindReferenceConst) String() string {
	switch e {
		case 0:
			return "True (ground referenced to North)"
		case 1:
			return "Magnetic (ground referenced to Magnetic North)"
		case 2:
			return "Apparent"
		case 3:
			return "True (boat referenced)"
		case 4:
			return "True (water referenced)"
	default:
		return fmt.Sprintf("%s(%d)", "WindReferenceConst", int(e))
	}
}

type WaterReferenceConst uint8
const (
	PaddleWheel	WaterReferenceConst = 0
	PitotTube	WaterReferenceConst = 1
	Doppler	WaterReferenceConst = 2
	CorrelationUltraSound	WaterReferenceConst = 3
	ElectroMagnetic	WaterReferenceConst = 4
)

func (e WaterReferenceConst) GoString() string {return e.String() }
func (e WaterReferenceConst) String() string {
	switch e {
		case 0:
			return "Paddle wheel"
		case 1:
			return "Pitot tube"
		case 2:
			return "Doppler"
		case 3:
			return "Correlation (ultra sound)"
		case 4:
			return "Electro Magnetic"
	default:
		return fmt.Sprintf("%s(%d)", "WaterReferenceConst", int(e))
	}
}

type YesNoConst uint8
const (
	No	YesNoConst = 0
	Yes	YesNoConst = 1
)

func (e YesNoConst) GoString() string {return e.String() }
func (e YesNoConst) String() string {
	switch e {
		case 0:
			return "No"
		case 1:
			return "Yes"
	default:
		return fmt.Sprintf("%s(%d)", "YesNoConst", int(e))
	}
}

type OkWarningConst uint8
const (
	OK	OkWarningConst = 0
	Warning	OkWarningConst = 1
)

func (e OkWarningConst) GoString() string {return e.String() }
func (e OkWarningConst) String() string {
	switch e {
		case 0:
			return "OK"
		case 1:
			return "Warning"
	default:
		return fmt.Sprintf("%s(%d)", "OkWarningConst", int(e))
	}
}

type OffOnConst uint8
const (
	Off	OffOnConst = 0
	On	OffOnConst = 1
)

func (e OffOnConst) GoString() string {return e.String() }
func (e OffOnConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "On"
	default:
		return fmt.Sprintf("%s(%d)", "OffOnConst", int(e))
	}
}

type DirectionReferenceConst uint8
const (
	True	DirectionReferenceConst = 0
	Magnetic	DirectionReferenceConst = 1
	Error	DirectionReferenceConst = 2
)

func (e DirectionReferenceConst) GoString() string {return e.String() }
func (e DirectionReferenceConst) String() string {
	switch e {
		case 0:
			return "True"
		case 1:
			return "Magnetic"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionReferenceConst", int(e))
	}
}

type DirectionRudderConst uint8
const (
	NoOrder	DirectionRudderConst = 0
	MoveToStarboard	DirectionRudderConst = 1
	MoveToPort	DirectionRudderConst = 2
)

func (e DirectionRudderConst) GoString() string {return e.String() }
func (e DirectionRudderConst) String() string {
	switch e {
		case 0:
			return "No Order"
		case 1:
			return "Move to starboard"
		case 2:
			return "Move to port"
	default:
		return fmt.Sprintf("%s(%d)", "DirectionRudderConst", int(e))
	}
}

type NavStatusConst uint8
const (
	UnderWayUsingEngine	NavStatusConst = 0
	AtAnchor	NavStatusConst = 1
	NotUnderCommand	NavStatusConst = 2
	RestrictedManeuverability	NavStatusConst = 3
	ConstrainedByHerDraught	NavStatusConst = 4
	Moored	NavStatusConst = 5
	Aground	NavStatusConst = 6
	EngagedInFishing	NavStatusConst = 7
	UnderWaySailing	NavStatusConst = 8
	HazardousMaterialHighSpeed	NavStatusConst = 9
	HazardousMaterialWingInGround	NavStatusConst = 10
	PowerDrivenVesslTowingAstern	NavStatusConst = 11
	PowerDrivenVesslPushingAheadOrTowingAlongside	NavStatusConst = 12
	AISSART	NavStatusConst = 14
)

func (e NavStatusConst) GoString() string {return e.String() }
func (e NavStatusConst) String() string {
	switch e {
		case 0:
			return "Under way using engine"
		case 1:
			return "At anchor"
		case 2:
			return "Not under command"
		case 3:
			return "Restricted maneuverability"
		case 4:
			return "Constrained by her draught"
		case 5:
			return "Moored"
		case 6:
			return "Aground"
		case 7:
			return "Engaged in Fishing"
		case 8:
			return "Under way sailing"
		case 9:
			return "Hazardous material - High Speed"
		case 10:
			return "Hazardous material - Wing in Ground"
		case 11:
			return "Power-driven vessl towing astern"
		case 12:
			return "Power-driven vessl pushing ahead or towing alongside"
		case 14:
			return "AIS-SART"
	default:
		return fmt.Sprintf("%s(%d)", "NavStatusConst", int(e))
	}
}

type PowerFactorConst uint8
const (
	Leading	PowerFactorConst = 0
	Lagging	PowerFactorConst = 1
	Error_2	PowerFactorConst = 2
)

func (e PowerFactorConst) GoString() string {return e.String() }
func (e PowerFactorConst) String() string {
	switch e {
		case 0:
			return "Leading"
		case 1:
			return "Lagging"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "PowerFactorConst", int(e))
	}
}

type TemperatureSourceConst uint8
const (
	SeaTemperature	TemperatureSourceConst = 0
	OutsideTemperature	TemperatureSourceConst = 1
	InsideTemperature	TemperatureSourceConst = 2
	EngineRoomTemperature	TemperatureSourceConst = 3
	MainCabinTemperature	TemperatureSourceConst = 4
	LiveWellTemperature	TemperatureSourceConst = 5
	BaitWellTemperature	TemperatureSourceConst = 6
	RefrigerationTemperature	TemperatureSourceConst = 7
	HeatingSystemTemperature	TemperatureSourceConst = 8
	DewPointTemperature	TemperatureSourceConst = 9
	ApparentWindChillTemperature	TemperatureSourceConst = 10
	TheoreticalWindChillTemperature	TemperatureSourceConst = 11
	HeatIndexTemperature	TemperatureSourceConst = 12
	FreezerTemperature	TemperatureSourceConst = 13
	ExhaustGasTemperature	TemperatureSourceConst = 14
	ShaftSealTemperature	TemperatureSourceConst = 15
)

func (e TemperatureSourceConst) GoString() string {return e.String() }
func (e TemperatureSourceConst) String() string {
	switch e {
		case 0:
			return "Sea Temperature"
		case 1:
			return "Outside Temperature"
		case 2:
			return "Inside Temperature"
		case 3:
			return "Engine Room Temperature"
		case 4:
			return "Main Cabin Temperature"
		case 5:
			return "Live Well Temperature"
		case 6:
			return "Bait Well Temperature"
		case 7:
			return "Refrigeration Temperature"
		case 8:
			return "Heating System Temperature"
		case 9:
			return "Dew Point Temperature"
		case 10:
			return "Apparent Wind Chill Temperature"
		case 11:
			return "Theoretical Wind Chill Temperature"
		case 12:
			return "Heat Index Temperature"
		case 13:
			return "Freezer Temperature"
		case 14:
			return "Exhaust Gas Temperature"
		case 15:
			return "Shaft Seal Temperature"
	default:
		return fmt.Sprintf("%s(%d)", "TemperatureSourceConst", int(e))
	}
}

type HumiditySourceConst uint8
const (
	Inside	HumiditySourceConst = 0
	Outside	HumiditySourceConst = 1
)

func (e HumiditySourceConst) GoString() string {return e.String() }
func (e HumiditySourceConst) String() string {
	switch e {
		case 0:
			return "Inside"
		case 1:
			return "Outside"
	default:
		return fmt.Sprintf("%s(%d)", "HumiditySourceConst", int(e))
	}
}

type PressureSourceConst uint8
const (
	Atmospheric	PressureSourceConst = 0
	Water	PressureSourceConst = 1
	Steam	PressureSourceConst = 2
	CompressedAir	PressureSourceConst = 3
	Hydraulic	PressureSourceConst = 4
	Filter	PressureSourceConst = 5
	AltimeterSetting	PressureSourceConst = 6
	Oil	PressureSourceConst = 7
	Fuel	PressureSourceConst = 8
)

func (e PressureSourceConst) GoString() string {return e.String() }
func (e PressureSourceConst) String() string {
	switch e {
		case 0:
			return "Atmospheric"
		case 1:
			return "Water"
		case 2:
			return "Steam"
		case 3:
			return "Compressed Air"
		case 4:
			return "Hydraulic"
		case 5:
			return "Filter"
		case 6:
			return "AltimeterSetting"
		case 7:
			return "Oil"
		case 8:
			return "Fuel"
	default:
		return fmt.Sprintf("%s(%d)", "PressureSourceConst", int(e))
	}
}

type DscFormatConst uint8
const (
	GeographicalArea	DscFormatConst = 102
	Distress	DscFormatConst = 112
	CommonInterest	DscFormatConst = 114
	AllShips	DscFormatConst = 116
	IndividualStations	DscFormatConst = 120
	NonCallingPurpose	DscFormatConst = 121
	IndividualStationAutomatic	DscFormatConst = 123
)

func (e DscFormatConst) GoString() string {return e.String() }
func (e DscFormatConst) String() string {
	switch e {
		case 102:
			return "Geographical area"
		case 112:
			return "Distress"
		case 114:
			return "Common interest"
		case 116:
			return "All ships"
		case 120:
			return "Individual stations"
		case 121:
			return "Non-calling purpose"
		case 123:
			return "Individual station automatic"
	default:
		return fmt.Sprintf("%s(%d)", "DscFormatConst", int(e))
	}
}

type DscCategoryConst uint8
const (
	Routine	DscCategoryConst = 100
	Safety	DscCategoryConst = 108
	Urgency	DscCategoryConst = 110
	Distress_2	DscCategoryConst = 112
)

func (e DscCategoryConst) GoString() string {return e.String() }
func (e DscCategoryConst) String() string {
	switch e {
		case 100:
			return "Routine"
		case 108:
			return "Safety"
		case 110:
			return "Urgency"
		case 112:
			return "Distress"
	default:
		return fmt.Sprintf("%s(%d)", "DscCategoryConst", int(e))
	}
}

type DscNatureConst uint8
const (
	Fire	DscNatureConst = 100
	Flooding	DscNatureConst = 101
	Collision	DscNatureConst = 102
	Grounding	DscNatureConst = 103
	Listing	DscNatureConst = 104
	Sinking	DscNatureConst = 105
	DisabledAndAdrift	DscNatureConst = 106
	Undesignated	DscNatureConst = 107
	AbandoningShip	DscNatureConst = 108
	Piracy	DscNatureConst = 109
	ManOverboard	DscNatureConst = 110
	EPIRBEmission	DscNatureConst = 112
)

func (e DscNatureConst) GoString() string {return e.String() }
func (e DscNatureConst) String() string {
	switch e {
		case 100:
			return "Fire"
		case 101:
			return "Flooding"
		case 102:
			return "Collision"
		case 103:
			return "Grounding"
		case 104:
			return "Listing"
		case 105:
			return "Sinking"
		case 106:
			return "Disabled and adrift"
		case 107:
			return "Undesignated"
		case 108:
			return "Abandoning ship"
		case 109:
			return "Piracy"
		case 110:
			return "Man overboard"
		case 112:
			return "EPIRB emission"
	default:
		return fmt.Sprintf("%s(%d)", "DscNatureConst", int(e))
	}
}

type DscFirstTelecommandConst uint8
const (
	F3EG3EAllModesTP	DscFirstTelecommandConst = 100
	F3EG3EDuplexTP	DscFirstTelecommandConst = 101
	Polling	DscFirstTelecommandConst = 103
	UnableToComply	DscFirstTelecommandConst = 104
	EndOfCall	DscFirstTelecommandConst = 105
	Data	DscFirstTelecommandConst = 106
	J3ETP	DscFirstTelecommandConst = 109
	DistressAcknowledgement	DscFirstTelecommandConst = 110
	DistressRelay	DscFirstTelecommandConst = 112
	F1BJ2BTTYFEC	DscFirstTelecommandConst = 113
	F1BJ2BTTYARQ	DscFirstTelecommandConst = 115
	Test	DscFirstTelecommandConst = 118
	ShipPositionOrLocationRegistrationUpdating	DscFirstTelecommandConst = 121
	NoInformation	DscFirstTelecommandConst = 126
)

func (e DscFirstTelecommandConst) GoString() string {return e.String() }
func (e DscFirstTelecommandConst) String() string {
	switch e {
		case 100:
			return "F3E/G3E All modes TP"
		case 101:
			return "F3E/G3E duplex TP"
		case 103:
			return "Polling"
		case 104:
			return "Unable to comply"
		case 105:
			return "End of call"
		case 106:
			return "Data"
		case 109:
			return "J3E TP"
		case 110:
			return "Distress acknowledgement"
		case 112:
			return "Distress relay"
		case 113:
			return "F1B/J2B TTY-FEC"
		case 115:
			return "F1B/J2B TTY-ARQ"
		case 118:
			return "Test"
		case 121:
			return "Ship position or location registration updating"
		case 126:
			return "No information"
	default:
		return fmt.Sprintf("%s(%d)", "DscFirstTelecommandConst", int(e))
	}
}

type DscSecondTelecommandConst uint8
const (
	NoReasonGiven	DscSecondTelecommandConst = 100
	CongestionAtMSC	DscSecondTelecommandConst = 101
	Busy	DscSecondTelecommandConst = 102
	QueueIndication	DscSecondTelecommandConst = 103
	StationBarred	DscSecondTelecommandConst = 104
	NoOperatorAvailable	DscSecondTelecommandConst = 105
	OperatorTemporarilyUnavailable	DscSecondTelecommandConst = 106
	EquipmentDisabled	DscSecondTelecommandConst = 107
	UnableToUseProposedChannel	DscSecondTelecommandConst = 108
	UnableToUseProposedMode	DscSecondTelecommandConst = 109
	ShipsAndAircraftOfStatesNotPartiesToAnArmedConflict_2	DscSecondTelecommandConst = 110
	MedicalTransports	DscSecondTelecommandConst = 111
	PayPhonePublicCallOffice	DscSecondTelecommandConst = 112
	FaxData	DscSecondTelecommandConst = 113
	NoInformation_2	DscSecondTelecommandConst = 126
)

func (e DscSecondTelecommandConst) GoString() string {return e.String() }
func (e DscSecondTelecommandConst) String() string {
	switch e {
		case 100:
			return "No reason given"
		case 101:
			return "Congestion at MSC"
		case 102:
			return "Busy"
		case 103:
			return "Queue indication"
		case 104:
			return "Station barred"
		case 105:
			return "No operator available"
		case 106:
			return "Operator temporarily unavailable"
		case 107:
			return "Equipment disabled"
		case 108:
			return "Unable to use proposed channel"
		case 109:
			return "Unable to use proposed mode"
		case 110:
			return "Ships and aircraft of States not parties to an armed conflict"
		case 111:
			return "Medical transports"
		case 112:
			return "Pay phone/public call office"
		case 113:
			return "Fax/data"
		case 126:
			return "No information"
	default:
		return fmt.Sprintf("%s(%d)", "DscSecondTelecommandConst", int(e))
	}
}

type DscExpansionDataConst uint8
const (
	EnhancedPosition	DscExpansionDataConst = 100
	SourceAndDatumOfPosition	DscExpansionDataConst = 101
	SOG	DscExpansionDataConst = 102
	COG	DscExpansionDataConst = 103
	AdditionalStationIdentification	DscExpansionDataConst = 104
	EnhancedGeographicArea	DscExpansionDataConst = 105
	NumberOfPersonsOnBoard	DscExpansionDataConst = 106
)

func (e DscExpansionDataConst) GoString() string {return e.String() }
func (e DscExpansionDataConst) String() string {
	switch e {
		case 100:
			return "Enhanced position"
		case 101:
			return "Source and datum of position"
		case 102:
			return "SOG"
		case 103:
			return "COG"
		case 104:
			return "Additional station identification"
		case 105:
			return "Enhanced geographic area"
		case 106:
			return "Number of persons on board"
	default:
		return fmt.Sprintf("%s(%d)", "DscExpansionDataConst", int(e))
	}
}

type SeatalkAlarmStatusConst uint8
const (
	AlarmConditionNotMet	SeatalkAlarmStatusConst = 0
	AlarmConditionMetAndNotSilenced	SeatalkAlarmStatusConst = 1
	AlarmConditionMetAndSilenced	SeatalkAlarmStatusConst = 2
)

func (e SeatalkAlarmStatusConst) GoString() string {return e.String() }
func (e SeatalkAlarmStatusConst) String() string {
	switch e {
		case 0:
			return "Alarm condition not met"
		case 1:
			return "Alarm condition met and not silenced"
		case 2:
			return "Alarm condition met and silenced"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmStatusConst", int(e))
	}
}

type SeatalkAlarmIdConst uint8
const (
	NoAlarm	SeatalkAlarmIdConst = 0
	ShallowDepth	SeatalkAlarmIdConst = 1
	DeepDepth	SeatalkAlarmIdConst = 2
	ShallowAnchor	SeatalkAlarmIdConst = 3
	DeepAnchor	SeatalkAlarmIdConst = 4
	OffCourse	SeatalkAlarmIdConst = 5
	AWAHigh	SeatalkAlarmIdConst = 6
	AWALow	SeatalkAlarmIdConst = 7
	AWSHigh	SeatalkAlarmIdConst = 8
	AWSLow	SeatalkAlarmIdConst = 9
	TWAHigh	SeatalkAlarmIdConst = 10
	TWALow	SeatalkAlarmIdConst = 11
	TWSHigh	SeatalkAlarmIdConst = 12
	TWSLow	SeatalkAlarmIdConst = 13
	WPArrival	SeatalkAlarmIdConst = 14
	BoatSpeedHigh	SeatalkAlarmIdConst = 15
	BoatSpeedLow	SeatalkAlarmIdConst = 16
	SeaTemperatureHigh	SeatalkAlarmIdConst = 17
	SeaTemperatureLow	SeatalkAlarmIdConst = 18
	PilotWatch	SeatalkAlarmIdConst = 19
	PilotOffCourse	SeatalkAlarmIdConst = 20
	PilotWindShift	SeatalkAlarmIdConst = 21
	PilotLowBattery	SeatalkAlarmIdConst = 22
	PilotLastMinuteOfWatch	SeatalkAlarmIdConst = 23
	PilotNoNMEAData	SeatalkAlarmIdConst = 24
	PilotLargeXTE	SeatalkAlarmIdConst = 25
	PilotNMEADataError	SeatalkAlarmIdConst = 26
	PilotCUDisconnected	SeatalkAlarmIdConst = 27
	PilotAutoRelease	SeatalkAlarmIdConst = 28
	PilotWayPointAdvance	SeatalkAlarmIdConst = 29
	PilotDriveStopped	SeatalkAlarmIdConst = 30
	PilotTypeUnspecified	SeatalkAlarmIdConst = 31
	PilotCalibrationRequired	SeatalkAlarmIdConst = 32
	PilotLastHeading	SeatalkAlarmIdConst = 33
	PilotNoPilot	SeatalkAlarmIdConst = 34
	PilotRouteComplete	SeatalkAlarmIdConst = 35
	PilotVariableText	SeatalkAlarmIdConst = 36
	GPSFailure	SeatalkAlarmIdConst = 37
	MOB	SeatalkAlarmIdConst = 38
	Seatalk1Anchor	SeatalkAlarmIdConst = 39
	PilotSwappedMotorPower	SeatalkAlarmIdConst = 40
	PilotStandbyTooFastToFish	SeatalkAlarmIdConst = 41
	PilotNoGPSFix	SeatalkAlarmIdConst = 42
	PilotNoGPSCOG	SeatalkAlarmIdConst = 43
	PilotStartUp	SeatalkAlarmIdConst = 44
	PilotTooSlow	SeatalkAlarmIdConst = 45
	PilotNoCompass	SeatalkAlarmIdConst = 46
	PilotRateGyroFault	SeatalkAlarmIdConst = 47
	PilotCurrentLimit	SeatalkAlarmIdConst = 48
	PilotWayPointAdvancePort	SeatalkAlarmIdConst = 49
	PilotWayPointAdvanceStbd	SeatalkAlarmIdConst = 50
	PilotNoWindData	SeatalkAlarmIdConst = 51
	PilotNoSpeedData	SeatalkAlarmIdConst = 52
	PilotSeatalkFail1	SeatalkAlarmIdConst = 53
	PilotSeatalkFail2	SeatalkAlarmIdConst = 54
	PilotWarningTooFastToFish	SeatalkAlarmIdConst = 55
	PilotAutoDocksideFail	SeatalkAlarmIdConst = 56
	PilotTurnTooFast	SeatalkAlarmIdConst = 57
	PilotNoNavData	SeatalkAlarmIdConst = 58
	PilotLostWaypointData	SeatalkAlarmIdConst = 59
	PilotEEPROMCorrupt	SeatalkAlarmIdConst = 60
	PilotRudderFeedbackFail	SeatalkAlarmIdConst = 61
	PilotAutolearnFail1	SeatalkAlarmIdConst = 62
	PilotAutolearnFail2	SeatalkAlarmIdConst = 63
	PilotAutolearnFail3	SeatalkAlarmIdConst = 64
	PilotAutolearnFail4	SeatalkAlarmIdConst = 65
	PilotAutolearnFail5	SeatalkAlarmIdConst = 66
	PilotAutolearnFail6	SeatalkAlarmIdConst = 67
	PilotWarningCalRequired	SeatalkAlarmIdConst = 68
	PilotWarningOffCourse	SeatalkAlarmIdConst = 69
	PilotWarningXTE	SeatalkAlarmIdConst = 70
	PilotWarningWindShift	SeatalkAlarmIdConst = 71
	PilotWarningDriveShort	SeatalkAlarmIdConst = 72
	PilotWarningClutchShort	SeatalkAlarmIdConst = 73
	PilotWarningSolenoidShort	SeatalkAlarmIdConst = 74
	PilotJoystickFault	SeatalkAlarmIdConst = 75
	PilotNoJoystickData	SeatalkAlarmIdConst = 76
	PilotInvalidCommand	SeatalkAlarmIdConst = 80
	AISTXMalfunction	SeatalkAlarmIdConst = 81
	AISAntennaVSWRFault	SeatalkAlarmIdConst = 82
	AISRxChannel1Malfunction	SeatalkAlarmIdConst = 83
	AISRxChannel2Malfunction	SeatalkAlarmIdConst = 84
	AISNoSensorPositionInUse	SeatalkAlarmIdConst = 85
	AISNoValidSOGInformation	SeatalkAlarmIdConst = 86
	AISNoValidCOGInformation	SeatalkAlarmIdConst = 87
	AIS12VAlarm	SeatalkAlarmIdConst = 88
	AIS6VAlarm	SeatalkAlarmIdConst = 89
	AISNoiseThresholdExceededChannelA	SeatalkAlarmIdConst = 90
	AISNoiseThresholdExceededChannelB	SeatalkAlarmIdConst = 91
	AISTransmitterPAFault	SeatalkAlarmIdConst = 92
	AIS3V3Alarm	SeatalkAlarmIdConst = 93
	AISRxChannel70Malfunction	SeatalkAlarmIdConst = 94
	AISHeadingLostInvalid	SeatalkAlarmIdConst = 95
	AISInternalGPSLost	SeatalkAlarmIdConst = 96
	AISNoSensorPosition	SeatalkAlarmIdConst = 97
	AISLockFailure	SeatalkAlarmIdConst = 98
	AISInternalGGATimeout	SeatalkAlarmIdConst = 99
	AISProtocolStackRestart	SeatalkAlarmIdConst = 100
	PilotNoIPSCommunications	SeatalkAlarmIdConst = 101
	PilotPowerOnOrSleepSwitchResetWhileEngaged	SeatalkAlarmIdConst = 102
	PilotUnexpectedResetWhileEngaged	SeatalkAlarmIdConst = 103
	AISDangerousTarget	SeatalkAlarmIdConst = 104
	AISLostTarget	SeatalkAlarmIdConst = 105
	AISSafetyRelatedMessageUsedToSilence	SeatalkAlarmIdConst = 106
	AISConnectionLost	SeatalkAlarmIdConst = 107
	NoFix	SeatalkAlarmIdConst = 108
)

func (e SeatalkAlarmIdConst) GoString() string {return e.String() }
func (e SeatalkAlarmIdConst) String() string {
	switch e {
		case 0:
			return "No Alarm"
		case 1:
			return "Shallow Depth"
		case 2:
			return "Deep Depth"
		case 3:
			return "Shallow Anchor"
		case 4:
			return "Deep Anchor"
		case 5:
			return "Off Course"
		case 6:
			return "AWA High"
		case 7:
			return "AWA Low"
		case 8:
			return "AWS High"
		case 9:
			return "AWS Low"
		case 10:
			return "TWA High"
		case 11:
			return "TWA Low"
		case 12:
			return "TWS High"
		case 13:
			return "TWS Low"
		case 14:
			return "WP Arrival"
		case 15:
			return "Boat Speed High"
		case 16:
			return "Boat Speed Low"
		case 17:
			return "Sea Temperature High"
		case 18:
			return "Sea Temperature Low"
		case 19:
			return "Pilot Watch"
		case 20:
			return "Pilot Off Course"
		case 21:
			return "Pilot Wind Shift"
		case 22:
			return "Pilot Low Battery"
		case 23:
			return "Pilot Last Minute Of Watch"
		case 24:
			return "Pilot No NMEA Data"
		case 25:
			return "Pilot Large XTE"
		case 26:
			return "Pilot NMEA DataError"
		case 27:
			return "Pilot CU Disconnected"
		case 28:
			return "Pilot Auto Release"
		case 29:
			return "Pilot Way Point Advance"
		case 30:
			return "Pilot Drive Stopped"
		case 31:
			return "Pilot Type Unspecified"
		case 32:
			return "Pilot Calibration Required"
		case 33:
			return "Pilot Last Heading"
		case 34:
			return "Pilot No Pilot"
		case 35:
			return "Pilot Route Complete"
		case 36:
			return "Pilot Variable Text"
		case 37:
			return "GPS Failure"
		case 38:
			return "MOB"
		case 39:
			return "Seatalk1 Anchor"
		case 40:
			return "Pilot Swapped Motor Power"
		case 41:
			return "Pilot Standby Too Fast To Fish"
		case 42:
			return "Pilot No GPS Fix"
		case 43:
			return "Pilot No GPS COG"
		case 44:
			return "Pilot Start Up"
		case 45:
			return "Pilot Too Slow"
		case 46:
			return "Pilot No Compass"
		case 47:
			return "Pilot Rate Gyro Fault"
		case 48:
			return "Pilot Current Limit"
		case 49:
			return "Pilot Way Point Advance Port"
		case 50:
			return "Pilot Way Point Advance Stbd"
		case 51:
			return "Pilot No Wind Data"
		case 52:
			return "Pilot No Speed Data"
		case 53:
			return "Pilot Seatalk Fail1"
		case 54:
			return "Pilot Seatalk Fail2"
		case 55:
			return "Pilot Warning Too Fast To Fish"
		case 56:
			return "Pilot Auto Dockside Fail"
		case 57:
			return "Pilot Turn Too Fast"
		case 58:
			return "Pilot No Nav Data"
		case 59:
			return "Pilot Lost Waypoint Data"
		case 60:
			return "Pilot EEPROM Corrupt"
		case 61:
			return "Pilot Rudder Feedback Fail"
		case 62:
			return "Pilot Autolearn Fail1"
		case 63:
			return "Pilot Autolearn Fail2"
		case 64:
			return "Pilot Autolearn Fail3"
		case 65:
			return "Pilot Autolearn Fail4"
		case 66:
			return "Pilot Autolearn Fail5"
		case 67:
			return "Pilot Autolearn Fail6"
		case 68:
			return "Pilot Warning Cal Required"
		case 69:
			return "Pilot Warning OffCourse"
		case 70:
			return "Pilot Warning XTE"
		case 71:
			return "Pilot Warning Wind Shift"
		case 72:
			return "Pilot Warning Drive Short"
		case 73:
			return "Pilot Warning Clutch Short"
		case 74:
			return "Pilot Warning Solenoid Short"
		case 75:
			return "Pilot Joystick Fault"
		case 76:
			return "Pilot No Joystick Data"
		case 80:
			return "Pilot Invalid Command"
		case 81:
			return "AIS TX Malfunction"
		case 82:
			return "AIS Antenna VSWR fault"
		case 83:
			return "AIS Rx channel 1 malfunction"
		case 84:
			return "AIS Rx channel 2 malfunction"
		case 85:
			return "AIS No sensor position in use"
		case 86:
			return "AIS No valid SOG information"
		case 87:
			return "AIS No valid COG information"
		case 88:
			return "AIS 12V alarm"
		case 89:
			return "AIS 6V alarm"
		case 90:
			return "AIS Noise threshold exceeded channel A"
		case 91:
			return "AIS Noise threshold exceeded channel B"
		case 92:
			return "AIS Transmitter PA fault"
		case 93:
			return "AIS 3V3 alarm"
		case 94:
			return "AIS Rx channel 70 malfunction"
		case 95:
			return "AIS Heading lost/invalid"
		case 96:
			return "AIS internal GPS lost"
		case 97:
			return "AIS No sensor position"
		case 98:
			return "AIS Lock failure"
		case 99:
			return "AIS Internal GGA timeout"
		case 100:
			return "AIS Protocol stack restart"
		case 101:
			return "Pilot No IPS communications"
		case 102:
			return "Pilot Power-On or Sleep-Switch Reset While Engaged"
		case 103:
			return "Pilot Unexpected Reset While Engaged"
		case 104:
			return "AIS Dangerous Target"
		case 105:
			return "AIS Lost Target"
		case 106:
			return "AIS Safety Related Message (used to silence)"
		case 107:
			return "AIS Connection Lost"
		case 108:
			return "No Fix"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmIdConst", int(e))
	}
}

type SeatalkAlarmGroupConst uint8
const (
	Instrument	SeatalkAlarmGroupConst = 0
	Autopilot	SeatalkAlarmGroupConst = 1
	Radar	SeatalkAlarmGroupConst = 2
	ChartPlotter	SeatalkAlarmGroupConst = 3
	AIS	SeatalkAlarmGroupConst = 4
)

func (e SeatalkAlarmGroupConst) GoString() string {return e.String() }
func (e SeatalkAlarmGroupConst) String() string {
	switch e {
		case 0:
			return "Instrument"
		case 1:
			return "Autopilot"
		case 2:
			return "Radar"
		case 3:
			return "Chart Plotter"
		case 4:
			return "AIS"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkAlarmGroupConst", int(e))
	}
}

type SeatalkPilotModeConst uint8
const (
	Standby	SeatalkPilotModeConst = 64
	Auto	SeatalkPilotModeConst = 66
	Wind	SeatalkPilotModeConst = 70
	Track	SeatalkPilotModeConst = 74
)

func (e SeatalkPilotModeConst) GoString() string {return e.String() }
func (e SeatalkPilotModeConst) String() string {
	switch e {
		case 64:
			return "Standby"
		case 66:
			return "Auto"
		case 70:
			return "Wind"
		case 74:
			return "Track"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkPilotModeConst", int(e))
	}
}

type EntertainmentZoneConst uint8
const (
	AllZones	EntertainmentZoneConst = 0
	Zone1	EntertainmentZoneConst = 1
	Zone2	EntertainmentZoneConst = 2
	Zone3	EntertainmentZoneConst = 3
	Zone4	EntertainmentZoneConst = 4
)

func (e EntertainmentZoneConst) GoString() string {return e.String() }
func (e EntertainmentZoneConst) String() string {
	switch e {
		case 0:
			return "All zones"
		case 1:
			return "Zone 1"
		case 2:
			return "Zone 2"
		case 3:
			return "Zone 3"
		case 4:
			return "Zone 4"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentZoneConst", int(e))
	}
}

type EntertainmentSourceConst uint8
const (
	VesselAlarm	EntertainmentSourceConst = 0
	AM	EntertainmentSourceConst = 1
	FM	EntertainmentSourceConst = 2
	Weather	EntertainmentSourceConst = 3
	DAB	EntertainmentSourceConst = 4
	Aux	EntertainmentSourceConst = 5
	USB	EntertainmentSourceConst = 6
	CD	EntertainmentSourceConst = 7
	MP3	EntertainmentSourceConst = 8
	AppleIOS	EntertainmentSourceConst = 9
	Android	EntertainmentSourceConst = 10
	Bluetooth	EntertainmentSourceConst = 11
	SiriusXM	EntertainmentSourceConst = 12
	Pandora	EntertainmentSourceConst = 13
	Spotify	EntertainmentSourceConst = 14
	Slacker	EntertainmentSourceConst = 15
	Songza	EntertainmentSourceConst = 16
	AppleRadio	EntertainmentSourceConst = 17
	LastFM	EntertainmentSourceConst = 18
	Ethernet	EntertainmentSourceConst = 19
	VideoMP4	EntertainmentSourceConst = 20
	VideoDVD	EntertainmentSourceConst = 21
	VideoBluRay	EntertainmentSourceConst = 22
	HDMI	EntertainmentSourceConst = 23
	Video	EntertainmentSourceConst = 24
)

func (e EntertainmentSourceConst) GoString() string {return e.String() }
func (e EntertainmentSourceConst) String() string {
	switch e {
		case 0:
			return "Vessel alarm"
		case 1:
			return "AM"
		case 2:
			return "FM"
		case 3:
			return "Weather"
		case 4:
			return "DAB"
		case 5:
			return "Aux"
		case 6:
			return "USB"
		case 7:
			return "CD"
		case 8:
			return "MP3"
		case 9:
			return "Apple iOS"
		case 10:
			return "Android"
		case 11:
			return "Bluetooth"
		case 12:
			return "Sirius XM"
		case 13:
			return "Pandora"
		case 14:
			return "Spotify"
		case 15:
			return "Slacker"
		case 16:
			return "Songza"
		case 17:
			return "Apple Radio"
		case 18:
			return "Last FM"
		case 19:
			return "Ethernet"
		case 20:
			return "Video MP4"
		case 21:
			return "Video DVD"
		case 22:
			return "Video BluRay"
		case 23:
			return "HDMI"
		case 24:
			return "Video"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentSourceConst", int(e))
	}
}

type EntertainmentPlayStatusConst uint16
const (
	Play	EntertainmentPlayStatusConst = 0
	Pause	EntertainmentPlayStatusConst = 1
	Stop	EntertainmentPlayStatusConst = 2
	FF1x	EntertainmentPlayStatusConst = 3
	FF2x	EntertainmentPlayStatusConst = 4
	FF3x	EntertainmentPlayStatusConst = 5
	FF4x	EntertainmentPlayStatusConst = 6
	RW1x	EntertainmentPlayStatusConst = 7
	RW2x	EntertainmentPlayStatusConst = 8
	RW3x	EntertainmentPlayStatusConst = 9
	RW4x	EntertainmentPlayStatusConst = 10
	SkipAhead	EntertainmentPlayStatusConst = 11
	SkipBack	EntertainmentPlayStatusConst = 12
	JogAhead	EntertainmentPlayStatusConst = 13
	JogBack	EntertainmentPlayStatusConst = 14
	SeekUp	EntertainmentPlayStatusConst = 15
	SeekDown	EntertainmentPlayStatusConst = 16
	ScanUp	EntertainmentPlayStatusConst = 17
	ScanDown	EntertainmentPlayStatusConst = 18
	TuneUp	EntertainmentPlayStatusConst = 19
	TuneDown	EntertainmentPlayStatusConst = 20
	SlowMotion75x	EntertainmentPlayStatusConst = 21
	SlowMotion5x	EntertainmentPlayStatusConst = 22
	SlowMotion25x	EntertainmentPlayStatusConst = 23
	SlowMotion125x	EntertainmentPlayStatusConst = 24
)

func (e EntertainmentPlayStatusConst) GoString() string {return e.String() }
func (e EntertainmentPlayStatusConst) String() string {
	switch e {
		case 0:
			return "Play"
		case 1:
			return "Pause"
		case 2:
			return "Stop"
		case 3:
			return "FF 1x"
		case 4:
			return "FF 2x"
		case 5:
			return "FF 3x"
		case 6:
			return "FF 4x"
		case 7:
			return "RW 1x"
		case 8:
			return "RW 2x"
		case 9:
			return "RW 3x"
		case 10:
			return "RW 4x"
		case 11:
			return "Skip ahead"
		case 12:
			return "Skip back"
		case 13:
			return "Jog ahead"
		case 14:
			return "Jog back"
		case 15:
			return "Seek up"
		case 16:
			return "Seek down"
		case 17:
			return "Scan up"
		case 18:
			return "Scan down"
		case 19:
			return "Tune up"
		case 20:
			return "Tune down"
		case 21:
			return "Slow motion .75x"
		case 22:
			return "Slow motion .5x"
		case 23:
			return "Slow motion .25x"
		case 24:
			return "Slow motion .125x"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentPlayStatusConst", int(e))
	}
}

type EntertainmentRepeatStatusConst uint8
const (
	Off_2	EntertainmentRepeatStatusConst = 0
	One	EntertainmentRepeatStatusConst = 1
	All	EntertainmentRepeatStatusConst = 2
)

func (e EntertainmentRepeatStatusConst) GoString() string {return e.String() }
func (e EntertainmentRepeatStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "One"
		case 2:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRepeatStatusConst", int(e))
	}
}

type EntertainmentShuffleStatusConst uint8
const (
	Off_3	EntertainmentShuffleStatusConst = 0
	PlayQueue	EntertainmentShuffleStatusConst = 1
	All_2	EntertainmentShuffleStatusConst = 2
)

func (e EntertainmentShuffleStatusConst) GoString() string {return e.String() }
func (e EntertainmentShuffleStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Play queue"
		case 2:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentShuffleStatusConst", int(e))
	}
}

type EntertainmentLikeStatusConst uint8
const (
	None	EntertainmentLikeStatusConst = 0
	ThumbsUp	EntertainmentLikeStatusConst = 1
	ThumbsDown	EntertainmentLikeStatusConst = 2
)

func (e EntertainmentLikeStatusConst) GoString() string {return e.String() }
func (e EntertainmentLikeStatusConst) String() string {
	switch e {
		case 0:
			return "None"
		case 1:
			return "Thumbs up"
		case 2:
			return "Thumbs down"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentLikeStatusConst", int(e))
	}
}

type EntertainmentTypeConst uint8
const (
	File	EntertainmentTypeConst = 0
	PlaylistName	EntertainmentTypeConst = 1
	GenreName	EntertainmentTypeConst = 2
	AlbumName	EntertainmentTypeConst = 3
	ArtistName	EntertainmentTypeConst = 4
	TrackName	EntertainmentTypeConst = 5
	StationName	EntertainmentTypeConst = 6
	StationNumber	EntertainmentTypeConst = 7
	FavouriteNumber	EntertainmentTypeConst = 8
	PlayQueue_2	EntertainmentTypeConst = 9
	ContentInfo	EntertainmentTypeConst = 10
)

func (e EntertainmentTypeConst) GoString() string {return e.String() }
func (e EntertainmentTypeConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentTypeConst", int(e))
	}
}

type EntertainmentGroupConst uint8
const (
	File_2	EntertainmentGroupConst = 0
	PlaylistName_2	EntertainmentGroupConst = 1
	GenreName_2	EntertainmentGroupConst = 2
	AlbumName_2	EntertainmentGroupConst = 3
	ArtistName_2	EntertainmentGroupConst = 4
	TrackName_2	EntertainmentGroupConst = 5
	StationName_2	EntertainmentGroupConst = 6
	StationNumber_2	EntertainmentGroupConst = 7
	FavouriteNumber_2	EntertainmentGroupConst = 8
	PlayQueue_3	EntertainmentGroupConst = 9
	ContentInfo_2	EntertainmentGroupConst = 10
)

func (e EntertainmentGroupConst) GoString() string {return e.String() }
func (e EntertainmentGroupConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentGroupConst", int(e))
	}
}

type EntertainmentChannelConst uint8
const (
	AllChannels	EntertainmentChannelConst = 0
	StereoFullRange	EntertainmentChannelConst = 1
	StereoFront	EntertainmentChannelConst = 2
	StereoBack	EntertainmentChannelConst = 3
	StereoSurround	EntertainmentChannelConst = 4
	Center	EntertainmentChannelConst = 5
	Subwoofer	EntertainmentChannelConst = 6
	FrontLeft	EntertainmentChannelConst = 7
	FrontRight	EntertainmentChannelConst = 8
	BackLeft	EntertainmentChannelConst = 9
	BackRight	EntertainmentChannelConst = 10
	SurroundLeft	EntertainmentChannelConst = 11
	SurroundRight	EntertainmentChannelConst = 12
)

func (e EntertainmentChannelConst) GoString() string {return e.String() }
func (e EntertainmentChannelConst) String() string {
	switch e {
		case 0:
			return "All channels"
		case 1:
			return "Stereo full range"
		case 2:
			return "Stereo front"
		case 3:
			return "Stereo back"
		case 4:
			return "Stereo surround"
		case 5:
			return "Center"
		case 6:
			return "Subwoofer"
		case 7:
			return "Front left"
		case 8:
			return "Front right"
		case 9:
			return "Back left"
		case 10:
			return "Back right"
		case 11:
			return "Surround left"
		case 12:
			return "Surround right"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentChannelConst", int(e))
	}
}

type EntertainmentEqConst uint8
const (
	Flat	EntertainmentEqConst = 0
	Rock	EntertainmentEqConst = 1
	Hall	EntertainmentEqConst = 2
	Jazz	EntertainmentEqConst = 3
	Pop	EntertainmentEqConst = 4
	Live	EntertainmentEqConst = 5
	Classic	EntertainmentEqConst = 6
	Vocal	EntertainmentEqConst = 7
	Arena	EntertainmentEqConst = 8
	Cinema	EntertainmentEqConst = 9
	Custom	EntertainmentEqConst = 10
)

func (e EntertainmentEqConst) GoString() string {return e.String() }
func (e EntertainmentEqConst) String() string {
	switch e {
		case 0:
			return "Flat"
		case 1:
			return "Rock"
		case 2:
			return "Hall"
		case 3:
			return "Jazz"
		case 4:
			return "Pop"
		case 5:
			return "Live"
		case 6:
			return "Classic"
		case 7:
			return "Vocal"
		case 8:
			return "Arena"
		case 9:
			return "Cinema"
		case 10:
			return "Custom"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentEqConst", int(e))
	}
}

type EntertainmentFilterConst uint8
const (
	FullRange	EntertainmentFilterConst = 0
	HighPass	EntertainmentFilterConst = 1
	LowPass	EntertainmentFilterConst = 2
	BandPass	EntertainmentFilterConst = 3
	NotchFilter	EntertainmentFilterConst = 4
)

func (e EntertainmentFilterConst) GoString() string {return e.String() }
func (e EntertainmentFilterConst) String() string {
	switch e {
		case 0:
			return "Full range"
		case 1:
			return "High pass"
		case 2:
			return "Low pass"
		case 3:
			return "Band pass"
		case 4:
			return "Notch filter"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentFilterConst", int(e))
	}
}

type AlertTypeConst uint8
const (
	EmergencyAlarm	AlertTypeConst = 1
	Alarm	AlertTypeConst = 2
	Warning_2	AlertTypeConst = 5
	Caution_2	AlertTypeConst = 8
)

func (e AlertTypeConst) GoString() string {return e.String() }
func (e AlertTypeConst) String() string {
	switch e {
		case 1:
			return "Emergency Alarm"
		case 2:
			return "Alarm"
		case 5:
			return "Warning"
		case 8:
			return "Caution"
	default:
		return fmt.Sprintf("%s(%d)", "AlertTypeConst", int(e))
	}
}

type AlertCategoryConst uint8
const (
	Navigational	AlertCategoryConst = 0
	Technical	AlertCategoryConst = 1
)

func (e AlertCategoryConst) GoString() string {return e.String() }
func (e AlertCategoryConst) String() string {
	switch e {
		case 0:
			return "Navigational"
		case 1:
			return "Technical"
	default:
		return fmt.Sprintf("%s(%d)", "AlertCategoryConst", int(e))
	}
}

type AlertTriggerConditionConst uint8
const (
	Manual_3	AlertTriggerConditionConst = 0
	Auto_2	AlertTriggerConditionConst = 1
	Test_2	AlertTriggerConditionConst = 2
	Disabled	AlertTriggerConditionConst = 3
)

func (e AlertTriggerConditionConst) GoString() string {return e.String() }
func (e AlertTriggerConditionConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Auto"
		case 2:
			return "Test"
		case 3:
			return "Disabled"
	default:
		return fmt.Sprintf("%s(%d)", "AlertTriggerConditionConst", int(e))
	}
}

type AlertThresholdStatusConst uint8
const (
	Normal	AlertThresholdStatusConst = 0
	ThresholdExceeded	AlertThresholdStatusConst = 1
	ExtremeThresholdExceeded	AlertThresholdStatusConst = 2
	LowThresholdExceeded	AlertThresholdStatusConst = 3
	Acknowledged	AlertThresholdStatusConst = 4
	AwaitingAcknowledge	AlertThresholdStatusConst = 5
)

func (e AlertThresholdStatusConst) GoString() string {return e.String() }
func (e AlertThresholdStatusConst) String() string {
	switch e {
		case 0:
			return "Normal"
		case 1:
			return "Threshold Exceeded"
		case 2:
			return "Extreme Threshold Exceeded"
		case 3:
			return "Low Threshold Exceeded"
		case 4:
			return "Acknowledged"
		case 5:
			return "Awaiting Acknowledge"
	default:
		return fmt.Sprintf("%s(%d)", "AlertThresholdStatusConst", int(e))
	}
}

type AlertStateConst uint8
const (
	Disabled_2	AlertStateConst = 0
	Normal_2	AlertStateConst = 1
	Active	AlertStateConst = 2
	Silenced	AlertStateConst = 3
	Acknowledged_2	AlertStateConst = 4
	AwaitingAcknowledge_2	AlertStateConst = 5
)

func (e AlertStateConst) GoString() string {return e.String() }
func (e AlertStateConst) String() string {
	switch e {
		case 0:
			return "Disabled"
		case 1:
			return "Normal"
		case 2:
			return "Active"
		case 3:
			return "Silenced"
		case 4:
			return "Acknowledged"
		case 5:
			return "Awaiting Acknowledge"
	default:
		return fmt.Sprintf("%s(%d)", "AlertStateConst", int(e))
	}
}

type AlertLanguageIdConst uint8
const (
	EnglishUS	AlertLanguageIdConst = 0
	EnglishUK	AlertLanguageIdConst = 1
	Arabic	AlertLanguageIdConst = 2
	ChineseSimplified	AlertLanguageIdConst = 3
	Croatian	AlertLanguageIdConst = 4
	Danish	AlertLanguageIdConst = 5
	Dutch	AlertLanguageIdConst = 6
	Finnish	AlertLanguageIdConst = 7
	French	AlertLanguageIdConst = 8
	German	AlertLanguageIdConst = 9
	Greek	AlertLanguageIdConst = 10
	Italian	AlertLanguageIdConst = 11
	Japanese	AlertLanguageIdConst = 12
	Korean	AlertLanguageIdConst = 13
	Norwegian	AlertLanguageIdConst = 14
	Polish	AlertLanguageIdConst = 15
	Portuguese	AlertLanguageIdConst = 16
	Russian	AlertLanguageIdConst = 17
	Spanish	AlertLanguageIdConst = 18
	Swedish	AlertLanguageIdConst = 19
)

func (e AlertLanguageIdConst) GoString() string {return e.String() }
func (e AlertLanguageIdConst) String() string {
	switch e {
		case 0:
			return "English (US)"
		case 1:
			return "English (UK)"
		case 2:
			return "Arabic"
		case 3:
			return "Chinese (simplified)"
		case 4:
			return "Croatian"
		case 5:
			return "Danish"
		case 6:
			return "Dutch"
		case 7:
			return "Finnish"
		case 8:
			return "French"
		case 9:
			return "German"
		case 10:
			return "Greek"
		case 11:
			return "Italian"
		case 12:
			return "Japanese"
		case 13:
			return "Korean"
		case 14:
			return "Norwegian"
		case 15:
			return "Polish"
		case 16:
			return "Portuguese"
		case 17:
			return "Russian"
		case 18:
			return "Spanish"
		case 19:
			return "Swedish"
	default:
		return fmt.Sprintf("%s(%d)", "AlertLanguageIdConst", int(e))
	}
}

type AlertResponseCommandConst uint8
const (
	Acknowledge	AlertResponseCommandConst = 0
	TemporarySilence	AlertResponseCommandConst = 1
	TestCommandOff	AlertResponseCommandConst = 2
	TestCommandOn	AlertResponseCommandConst = 3
)

func (e AlertResponseCommandConst) GoString() string {return e.String() }
func (e AlertResponseCommandConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Temporary Silence"
		case 2:
			return "Test Command off"
		case 3:
			return "Test Command on"
	default:
		return fmt.Sprintf("%s(%d)", "AlertResponseCommandConst", int(e))
	}
}

type ConverterStateConst uint8
const (
	Off_4	ConverterStateConst = 0
	LowPowerMode	ConverterStateConst = 1
	Fault	ConverterStateConst = 2
	Bulk	ConverterStateConst = 3
	Absorption	ConverterStateConst = 4
	Float	ConverterStateConst = 5
	Storage	ConverterStateConst = 6
	Equalize	ConverterStateConst = 7
	PassThru	ConverterStateConst = 8
	Inverting	ConverterStateConst = 9
	Assisting	ConverterStateConst = 10
)

func (e ConverterStateConst) GoString() string {return e.String() }
func (e ConverterStateConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Low Power Mode"
		case 2:
			return "Fault"
		case 3:
			return "Bulk"
		case 4:
			return "Absorption"
		case 5:
			return "Float"
		case 6:
			return "Storage"
		case 7:
			return "Equalize"
		case 8:
			return "Pass thru"
		case 9:
			return "Inverting"
		case 10:
			return "Assisting"
	default:
		return fmt.Sprintf("%s(%d)", "ConverterStateConst", int(e))
	}
}

type ThrusterDirectionControlConst uint8
const (
	Off_5	ThrusterDirectionControlConst = 0
	Ready	ThrusterDirectionControlConst = 1
	ToPort	ThrusterDirectionControlConst = 2
	ToStarboard	ThrusterDirectionControlConst = 3
)

func (e ThrusterDirectionControlConst) GoString() string {return e.String() }
func (e ThrusterDirectionControlConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Ready"
		case 2:
			return "To Port"
		case 3:
			return "To Starboard"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterDirectionControlConst", int(e))
	}
}

type ThrusterRetractControlConst uint8
const (
	Off_6	ThrusterRetractControlConst = 0
	Extend	ThrusterRetractControlConst = 1
	Retract	ThrusterRetractControlConst = 2
)

func (e ThrusterRetractControlConst) GoString() string {return e.String() }
func (e ThrusterRetractControlConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Extend"
		case 2:
			return "Retract"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterRetractControlConst", int(e))
	}
}

type ThrusterMotorTypeConst uint8
const (
	A12VDC	ThrusterMotorTypeConst = 0
	A24VDC	ThrusterMotorTypeConst = 1
	A48VDC	ThrusterMotorTypeConst = 2
	A24VAC	ThrusterMotorTypeConst = 3
	Hydraulic_2	ThrusterMotorTypeConst = 4
)

func (e ThrusterMotorTypeConst) GoString() string {return e.String() }
func (e ThrusterMotorTypeConst) String() string {
	switch e {
		case 0:
			return "A12VDC"
		case 1:
			return "A24VDC"
		case 2:
			return "A48VDC"
		case 3:
			return "A24VAC"
		case 4:
			return "Hydraulic"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterMotorTypeConst", int(e))
	}
}

type BootStateConst uint8
const (
	InStartupMonitor	BootStateConst = 0
	RunningBootloader	BootStateConst = 1
	RunningApplication	BootStateConst = 2
)

func (e BootStateConst) GoString() string {return e.String() }
func (e BootStateConst) String() string {
	switch e {
		case 0:
			return "in Startup Monitor"
		case 1:
			return "running Bootloader"
		case 2:
			return "running Application"
	default:
		return fmt.Sprintf("%s(%d)", "BootStateConst", int(e))
	}
}

type AccessLevelConst uint8
const (
	Locked	AccessLevelConst = 0
	UnlockedLevel1	AccessLevelConst = 1
	UnlockedLevel2	AccessLevelConst = 2
)

func (e AccessLevelConst) GoString() string {return e.String() }
func (e AccessLevelConst) String() string {
	switch e {
		case 0:
			return "Locked"
		case 1:
			return "unlocked level 1"
		case 2:
			return "unlocked level 2"
	default:
		return fmt.Sprintf("%s(%d)", "AccessLevelConst", int(e))
	}
}

type TransmissionIntervalConst uint8
const (
	Acknowledge_2	TransmissionIntervalConst = 0
	TransmitIntervalPriorityNotSupported	TransmissionIntervalConst = 1
	TransmitIntervalTooLow	TransmissionIntervalConst = 2
	AccessDenied	TransmissionIntervalConst = 3
	NotSupported	TransmissionIntervalConst = 4
)

func (e TransmissionIntervalConst) GoString() string {return e.String() }
func (e TransmissionIntervalConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Transmit Interval/Priority not supported"
		case 2:
			return "Transmit Interval too low"
		case 3:
			return "Access denied"
		case 4:
			return "Not supported"
	default:
		return fmt.Sprintf("%s(%d)", "TransmissionIntervalConst", int(e))
	}
}

type ParameterFieldConst uint8
const (
	Acknowledge_3	ParameterFieldConst = 0
	InvalidParameterField	ParameterFieldConst = 1
	TemporaryError	ParameterFieldConst = 2
	ParameterOutOfRange	ParameterFieldConst = 3
	AccessDenied_2	ParameterFieldConst = 4
	NotSupported_2	ParameterFieldConst = 5
	ReadOrWriteNotSupported	ParameterFieldConst = 6
)

func (e ParameterFieldConst) GoString() string {return e.String() }
func (e ParameterFieldConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "Invalid parameter field"
		case 2:
			return "Temporary error"
		case 3:
			return "Parameter out of range"
		case 4:
			return "Access denied"
		case 5:
			return "Not supported"
		case 6:
			return "Read or Write not supported"
	default:
		return fmt.Sprintf("%s(%d)", "ParameterFieldConst", int(e))
	}
}

type PgnListFunctionConst uint8
const (
	TransmitPGNList	PgnListFunctionConst = 0
	ReceivePGNList	PgnListFunctionConst = 1
)

func (e PgnListFunctionConst) GoString() string {return e.String() }
func (e PgnListFunctionConst) String() string {
	switch e {
		case 0:
			return "Transmit PGN list"
		case 1:
			return "Receive PGN list"
	default:
		return fmt.Sprintf("%s(%d)", "PgnListFunctionConst", int(e))
	}
}

type FusionCommandConst uint8
const (
	Play_2	FusionCommandConst = 1
	Pause_2	FusionCommandConst = 2
	Next	FusionCommandConst = 4
	Prev	FusionCommandConst = 6
)

func (e FusionCommandConst) GoString() string {return e.String() }
func (e FusionCommandConst) String() string {
	switch e {
		case 1:
			return "Play"
		case 2:
			return "Pause"
		case 4:
			return "Next"
		case 6:
			return "Prev"
	default:
		return fmt.Sprintf("%s(%d)", "FusionCommandConst", int(e))
	}
}

type FusionSiriusCommandConst uint8
const (
	Next_2	FusionSiriusCommandConst = 1
	Prev_2	FusionSiriusCommandConst = 2
)

func (e FusionSiriusCommandConst) GoString() string {return e.String() }
func (e FusionSiriusCommandConst) String() string {
	switch e {
		case 1:
			return "Next"
		case 2:
			return "Prev"
	default:
		return fmt.Sprintf("%s(%d)", "FusionSiriusCommandConst", int(e))
	}
}

type FusionMuteCommandConst uint8
const (
	MuteOn	FusionMuteCommandConst = 1
	MuteOff	FusionMuteCommandConst = 2
)

func (e FusionMuteCommandConst) GoString() string {return e.String() }
func (e FusionMuteCommandConst) String() string {
	switch e {
		case 1:
			return "Mute On"
		case 2:
			return "Mute Off"
	default:
		return fmt.Sprintf("%s(%d)", "FusionMuteCommandConst", int(e))
	}
}

type SeatalkKeystrokeConst uint8
const (
	Auto_3	SeatalkKeystrokeConst = 1
	Standby_2	SeatalkKeystrokeConst = 2
	Wind_2	SeatalkKeystrokeConst = 3
	AMinus1	SeatalkKeystrokeConst = 5
	AMinus10	SeatalkKeystrokeConst = 6
	APlus1	SeatalkKeystrokeConst = 7
	APlus10	SeatalkKeystrokeConst = 8
	AMinus1AndMinus10	SeatalkKeystrokeConst = 33
	APlus1AndPlus10	SeatalkKeystrokeConst = 34
	Track_2	SeatalkKeystrokeConst = 35
)

func (e SeatalkKeystrokeConst) GoString() string {return e.String() }
func (e SeatalkKeystrokeConst) String() string {
	switch e {
		case 1:
			return "Auto"
		case 2:
			return "Standby"
		case 3:
			return "Wind"
		case 5:
			return "A-1"
		case 6:
			return "A-10"
		case 7:
			return "A+1"
		case 8:
			return "A+10"
		case 33:
			return "A-1 and -10"
		case 34:
			return "A+1 and +10"
		case 35:
			return "Track"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkKeystrokeConst", int(e))
	}
}

type SeatalkDeviceIdConst uint8
const (
	S100	SeatalkDeviceIdConst = 3
	CourseComputer	SeatalkDeviceIdConst = 5
)

func (e SeatalkDeviceIdConst) GoString() string {return e.String() }
func (e SeatalkDeviceIdConst) String() string {
	switch e {
		case 3:
			return "S100"
		case 5:
			return "Course Computer"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkDeviceIdConst", int(e))
	}
}

type SeatalkNetworkGroupConst uint8
const (
	None_2	SeatalkNetworkGroupConst = 0
	Helm1	SeatalkNetworkGroupConst = 1
	Helm2	SeatalkNetworkGroupConst = 2
	Cockpit	SeatalkNetworkGroupConst = 3
	Flybridge	SeatalkNetworkGroupConst = 4
	Mast	SeatalkNetworkGroupConst = 5
	Group1	SeatalkNetworkGroupConst = 6
	Group2	SeatalkNetworkGroupConst = 7
	Group3	SeatalkNetworkGroupConst = 8
	Group4	SeatalkNetworkGroupConst = 9
	Group5	SeatalkNetworkGroupConst = 10
)

func (e SeatalkNetworkGroupConst) GoString() string {return e.String() }
func (e SeatalkNetworkGroupConst) String() string {
	switch e {
		case 0:
			return "None"
		case 1:
			return "Helm 1"
		case 2:
			return "Helm 2"
		case 3:
			return "Cockpit"
		case 4:
			return "Flybridge"
		case 5:
			return "Mast"
		case 6:
			return "Group 1"
		case 7:
			return "Group 2"
		case 8:
			return "Group 3"
		case 9:
			return "Group 4"
		case 10:
			return "Group 5"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkNetworkGroupConst", int(e))
	}
}

type SeatalkDisplayColorConst uint8
const (
	Day1	SeatalkDisplayColorConst = 0
	Day2	SeatalkDisplayColorConst = 2
	RedBlack	SeatalkDisplayColorConst = 3
	Inverse	SeatalkDisplayColorConst = 4
)

func (e SeatalkDisplayColorConst) GoString() string {return e.String() }
func (e SeatalkDisplayColorConst) String() string {
	switch e {
		case 0:
			return "Day 1"
		case 2:
			return "Day 2"
		case 3:
			return "Red/Black"
		case 4:
			return "Inverse"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkDisplayColorConst", int(e))
	}
}

type AirmarCalibrateFunctionConst uint8
const (
	NormalCancelCalibration	AirmarCalibrateFunctionConst = 0
	EnterCalibrationMode	AirmarCalibrateFunctionConst = 1
	ResetCalibrationTo0	AirmarCalibrateFunctionConst = 2
	Verify	AirmarCalibrateFunctionConst = 3
	ResetCompassToDefaults	AirmarCalibrateFunctionConst = 4
	ResetDampingToDefaults	AirmarCalibrateFunctionConst = 5
)

func (e AirmarCalibrateFunctionConst) GoString() string {return e.String() }
func (e AirmarCalibrateFunctionConst) String() string {
	switch e {
		case 0:
			return "Normal/cancel calibration"
		case 1:
			return "Enter calibration mode"
		case 2:
			return "Reset calibration to 0"
		case 3:
			return "Verify"
		case 4:
			return "Reset compass to defaults"
		case 5:
			return "Reset damping to defaults"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCalibrateFunctionConst", int(e))
	}
}

type AirmarCalibrateStatusConst uint8
const (
	Queried	AirmarCalibrateStatusConst = 0
	Passed	AirmarCalibrateStatusConst = 1
	FailedTimeout	AirmarCalibrateStatusConst = 2
	FailedTiltError	AirmarCalibrateStatusConst = 3
	FailedOther	AirmarCalibrateStatusConst = 4
	InProgress	AirmarCalibrateStatusConst = 5
)

func (e AirmarCalibrateStatusConst) GoString() string {return e.String() }
func (e AirmarCalibrateStatusConst) String() string {
	switch e {
		case 0:
			return "Queried"
		case 1:
			return "Passed"
		case 2:
			return "Failed - timeout"
		case 3:
			return "Failed - tilt error"
		case 4:
			return "Failed - other"
		case 5:
			return "In progress"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCalibrateStatusConst", int(e))
	}
}

type AirmarTemperatureInstanceConst uint8
const (
	DeviceSensor	AirmarTemperatureInstanceConst = 0
	OnboardWaterSensor	AirmarTemperatureInstanceConst = 1
	OptionalWaterSensor	AirmarTemperatureInstanceConst = 2
)

func (e AirmarTemperatureInstanceConst) GoString() string {return e.String() }
func (e AirmarTemperatureInstanceConst) String() string {
	switch e {
		case 0:
			return "Device Sensor"
		case 1:
			return "Onboard Water Sensor"
		case 2:
			return "Optional Water Sensor"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarTemperatureInstanceConst", int(e))
	}
}

type AirmarFilterConst uint8
const (
	NoFilter	AirmarFilterConst = 0
	BasicIIRFilter	AirmarFilterConst = 1
)

func (e AirmarFilterConst) GoString() string {return e.String() }
func (e AirmarFilterConst) String() string {
	switch e {
		case 0:
			return "No filter"
		case 1:
			return "Basic IIR filter"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarFilterConst", int(e))
	}
}

type ControllerStateConst uint8
const (
	ErrorActive	ControllerStateConst = 0
	ErrorPassive	ControllerStateConst = 1
	BusOff	ControllerStateConst = 2
)

func (e ControllerStateConst) GoString() string {return e.String() }
func (e ControllerStateConst) String() string {
	switch e {
		case 0:
			return "Error Active"
		case 1:
			return "Error Passive"
		case 2:
			return "Bus Off"
	default:
		return fmt.Sprintf("%s(%d)", "ControllerStateConst", int(e))
	}
}

type EquipmentStatusConst uint8
const (
	Operational	EquipmentStatusConst = 0
	Fault_2	EquipmentStatusConst = 1
)

func (e EquipmentStatusConst) GoString() string {return e.String() }
func (e EquipmentStatusConst) String() string {
	switch e {
		case 0:
			return "Operational"
		case 1:
			return "Fault"
	default:
		return fmt.Sprintf("%s(%d)", "EquipmentStatusConst", int(e))
	}
}

type MobStatusConst uint8
const (
	MOBEmitterActivated	MobStatusConst = 0
	ManualOnBoardMOBButtonActivation	MobStatusConst = 1
	TestMode	MobStatusConst = 2
)

func (e MobStatusConst) GoString() string {return e.String() }
func (e MobStatusConst) String() string {
	switch e {
		case 0:
			return "MOB Emitter Activated"
		case 1:
			return "Manual on-board MOB Button Activation"
		case 2:
			return "Test mode"
	default:
		return fmt.Sprintf("%s(%d)", "MobStatusConst", int(e))
	}
}

type LowBatteryConst uint8
const (
	Good	LowBatteryConst = 0
	Low_2	LowBatteryConst = 1
)

func (e LowBatteryConst) GoString() string {return e.String() }
func (e LowBatteryConst) String() string {
	switch e {
		case 0:
			return "Good"
		case 1:
			return "Low"
	default:
		return fmt.Sprintf("%s(%d)", "LowBatteryConst", int(e))
	}
}

type TurnModeConst uint8
const (
	RudderLimitControlled	TurnModeConst = 0
	TurnRateControlled	TurnModeConst = 1
	RadiusControlled	TurnModeConst = 2
)

func (e TurnModeConst) GoString() string {return e.String() }
func (e TurnModeConst) String() string {
	switch e {
		case 0:
			return "Rudder limit controlled"
		case 1:
			return "Turn rate controlled"
		case 2:
			return "Radius controlled"
	default:
		return fmt.Sprintf("%s(%d)", "TurnModeConst", int(e))
	}
}

type AcceptabilityConst uint8
const (
	BadLevel	AcceptabilityConst = 0
	BadFrequency	AcceptabilityConst = 1
	BeingQualified	AcceptabilityConst = 2
	Good_2	AcceptabilityConst = 3
)

func (e AcceptabilityConst) GoString() string {return e.String() }
func (e AcceptabilityConst) String() string {
	switch e {
		case 0:
			return "Bad level"
		case 1:
			return "Bad frequency"
		case 2:
			return "Being qualified"
		case 3:
			return "Good"
	default:
		return fmt.Sprintf("%s(%d)", "AcceptabilityConst", int(e))
	}
}

type LineConst uint8
const (
	Line1	LineConst = 0
	Line2	LineConst = 1
	Line3	LineConst = 2
)

func (e LineConst) GoString() string {return e.String() }
func (e LineConst) String() string {
	switch e {
		case 0:
			return "Line 1"
		case 1:
			return "Line 2"
		case 2:
			return "Line 3"
	default:
		return fmt.Sprintf("%s(%d)", "LineConst", int(e))
	}
}

type WaveformConst uint8
const (
	SineWave	WaveformConst = 0
	ModifiedSineWave	WaveformConst = 1
)

func (e WaveformConst) GoString() string {return e.String() }
func (e WaveformConst) String() string {
	switch e {
		case 0:
			return "Sine wave"
		case 1:
			return "Modified sine wave"
	default:
		return fmt.Sprintf("%s(%d)", "WaveformConst", int(e))
	}
}

type TankTypeConst uint8
const (
	Fuel_2	TankTypeConst = 0
	Water_2	TankTypeConst = 1
	GrayWater	TankTypeConst = 2
	LiveWell	TankTypeConst = 3
	Oil_2	TankTypeConst = 4
	BlackWater	TankTypeConst = 5
)

func (e TankTypeConst) GoString() string {return e.String() }
func (e TankTypeConst) String() string {
	switch e {
		case 0:
			return "Fuel"
		case 1:
			return "Water"
		case 2:
			return "Gray water"
		case 3:
			return "Live well"
		case 4:
			return "Oil"
		case 5:
			return "Black water"
	default:
		return fmt.Sprintf("%s(%d)", "TankTypeConst", int(e))
	}
}

type DcSourceConst uint8
const (
	Battery	DcSourceConst = 0
	Alternator	DcSourceConst = 1
	Convertor	DcSourceConst = 2
	SolarCell	DcSourceConst = 3
	WindGenerator	DcSourceConst = 4
)

func (e DcSourceConst) GoString() string {return e.String() }
func (e DcSourceConst) String() string {
	switch e {
		case 0:
			return "Battery"
		case 1:
			return "Alternator"
		case 2:
			return "Convertor"
		case 3:
			return "Solar cell"
		case 4:
			return "Wind generator"
	default:
		return fmt.Sprintf("%s(%d)", "DcSourceConst", int(e))
	}
}

type ChargerStateConst uint8
const (
	NotCharging	ChargerStateConst = 0
	Bulk_2	ChargerStateConst = 1
	Absorption_2	ChargerStateConst = 2
	Overcharge	ChargerStateConst = 3
	Equalise	ChargerStateConst = 4
	Float_2	ChargerStateConst = 5
	NoFloat	ChargerStateConst = 6
	ConstantVI	ChargerStateConst = 7
	Disabled_3	ChargerStateConst = 8
	Fault_3	ChargerStateConst = 9
)

func (e ChargerStateConst) GoString() string {return e.String() }
func (e ChargerStateConst) String() string {
	switch e {
		case 0:
			return "Not charging"
		case 1:
			return "Bulk"
		case 2:
			return "Absorption"
		case 3:
			return "Overcharge"
		case 4:
			return "Equalise"
		case 5:
			return "Float"
		case 6:
			return "No float"
		case 7:
			return "Constant VI"
		case 8:
			return "Disabled"
		case 9:
			return "Fault"
	default:
		return fmt.Sprintf("%s(%d)", "ChargerStateConst", int(e))
	}
}

type ChargingAlgorithmConst uint8
const (
	Trickle	ChargingAlgorithmConst = 0
	ConstantVoltageConstantCurrent	ChargingAlgorithmConst = 1
	A2StageNoFloat	ChargingAlgorithmConst = 2
	A3Stage	ChargingAlgorithmConst = 3
)

func (e ChargingAlgorithmConst) GoString() string {return e.String() }
func (e ChargingAlgorithmConst) String() string {
	switch e {
		case 0:
			return "Trickle"
		case 1:
			return "Constant voltage / Constant current"
		case 2:
			return "A2 stage (no float)"
		case 3:
			return "A3 stage"
	default:
		return fmt.Sprintf("%s(%d)", "ChargingAlgorithmConst", int(e))
	}
}

type ChargerModeConst uint8
const (
	Standalone	ChargerModeConst = 0
	Primary	ChargerModeConst = 1
	Secondary	ChargerModeConst = 2
	Echo	ChargerModeConst = 3
)

func (e ChargerModeConst) GoString() string {return e.String() }
func (e ChargerModeConst) String() string {
	switch e {
		case 0:
			return "Standalone"
		case 1:
			return "Primary"
		case 2:
			return "Secondary"
		case 3:
			return "Echo"
	default:
		return fmt.Sprintf("%s(%d)", "ChargerModeConst", int(e))
	}
}

type InverterStateConst uint8
const (
	Invert	InverterStateConst = 0
	ACPassthru	InverterStateConst = 1
	LoadSense	InverterStateConst = 2
	Fault_4	InverterStateConst = 3
	Disabled_4	InverterStateConst = 4
)

func (e InverterStateConst) GoString() string {return e.String() }
func (e InverterStateConst) String() string {
	switch e {
		case 0:
			return "Invert"
		case 1:
			return "AC passthru"
		case 2:
			return "Load sense"
		case 3:
			return "Fault"
		case 4:
			return "Disabled"
	default:
		return fmt.Sprintf("%s(%d)", "InverterStateConst", int(e))
	}
}

type BatteryTypeConst uint8
const (
	Flooded	BatteryTypeConst = 0
	Gel	BatteryTypeConst = 1
	AGM	BatteryTypeConst = 2
)

func (e BatteryTypeConst) GoString() string {return e.String() }
func (e BatteryTypeConst) String() string {
	switch e {
		case 0:
			return "Flooded"
		case 1:
			return "Gel"
		case 2:
			return "AGM"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryTypeConst", int(e))
	}
}

type BatteryVoltageConst uint8
const (
	A6V	BatteryVoltageConst = 0
	A12V	BatteryVoltageConst = 1
	A24V	BatteryVoltageConst = 2
	A32V	BatteryVoltageConst = 3
	A36V	BatteryVoltageConst = 4
	A42V	BatteryVoltageConst = 5
	A48V	BatteryVoltageConst = 6
)

func (e BatteryVoltageConst) GoString() string {return e.String() }
func (e BatteryVoltageConst) String() string {
	switch e {
		case 0:
			return "A6V"
		case 1:
			return "A12V"
		case 2:
			return "A24V"
		case 3:
			return "A32V"
		case 4:
			return "A36V"
		case 5:
			return "A42V"
		case 6:
			return "A48V"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryVoltageConst", int(e))
	}
}

type BatteryChemistryConst uint8
const (
	PbLead	BatteryChemistryConst = 0
	Li	BatteryChemistryConst = 1
	NiCd	BatteryChemistryConst = 2
	ZnO	BatteryChemistryConst = 3
	NiMH	BatteryChemistryConst = 4
)

func (e BatteryChemistryConst) GoString() string {return e.String() }
func (e BatteryChemistryConst) String() string {
	switch e {
		case 0:
			return "Pb (Lead)"
		case 1:
			return "Li"
		case 2:
			return "NiCd"
		case 3:
			return "ZnO"
		case 4:
			return "NiMH"
	default:
		return fmt.Sprintf("%s(%d)", "BatteryChemistryConst", int(e))
	}
}

type GoodWarningErrorConst uint8
const (
	Good_3	GoodWarningErrorConst = 0
	Warning_3	GoodWarningErrorConst = 1
	Error_3	GoodWarningErrorConst = 2
)

func (e GoodWarningErrorConst) GoString() string {return e.String() }
func (e GoodWarningErrorConst) String() string {
	switch e {
		case 0:
			return "Good"
		case 1:
			return "Warning"
		case 2:
			return "Error"
	default:
		return fmt.Sprintf("%s(%d)", "GoodWarningErrorConst", int(e))
	}
}

type TrackingConst uint8
const (
	Cancelled	TrackingConst = 0
	Acquiring	TrackingConst = 1
	Tracking	TrackingConst = 2
	Lost	TrackingConst = 3
)

func (e TrackingConst) GoString() string {return e.String() }
func (e TrackingConst) String() string {
	switch e {
		case 0:
			return "Cancelled"
		case 1:
			return "Acquiring"
		case 2:
			return "Tracking"
		case 3:
			return "Lost"
	default:
		return fmt.Sprintf("%s(%d)", "TrackingConst", int(e))
	}
}

type TargetAcquisitionConst uint8
const (
	Manual_4	TargetAcquisitionConst = 0
	Automatic	TargetAcquisitionConst = 1
)

func (e TargetAcquisitionConst) GoString() string {return e.String() }
func (e TargetAcquisitionConst) String() string {
	switch e {
		case 0:
			return "Manual"
		case 1:
			return "Automatic"
	default:
		return fmt.Sprintf("%s(%d)", "TargetAcquisitionConst", int(e))
	}
}

type WindlassDirectionConst uint8
const (
	Off_7	WindlassDirectionConst = 0
	Down	WindlassDirectionConst = 1
	Up	WindlassDirectionConst = 2
)

func (e WindlassDirectionConst) GoString() string {return e.String() }
func (e WindlassDirectionConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "Down"
		case 2:
			return "Up"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassDirectionConst", int(e))
	}
}

type SpeedTypeConst uint8
const (
	SingleSpeed	SpeedTypeConst = 0
	DualSpeed	SpeedTypeConst = 1
	ProportionalSpeed	SpeedTypeConst = 2
)

func (e SpeedTypeConst) GoString() string {return e.String() }
func (e SpeedTypeConst) String() string {
	switch e {
		case 0:
			return "Single speed"
		case 1:
			return "Dual speed"
		case 2:
			return "Proportional speed"
	default:
		return fmt.Sprintf("%s(%d)", "SpeedTypeConst", int(e))
	}
}

type WindlassMotionConst uint8
const (
	WindlassStopped	WindlassMotionConst = 0
	DeploymentOccurring	WindlassMotionConst = 1
	RetrievalOccurring	WindlassMotionConst = 2
)

func (e WindlassMotionConst) GoString() string {return e.String() }
func (e WindlassMotionConst) String() string {
	switch e {
		case 0:
			return "Windlass stopped"
		case 1:
			return "Deployment occurring"
		case 2:
			return "Retrieval occurring"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassMotionConst", int(e))
	}
}

type RodeTypeConst uint8
const (
	ChainPresentlyDetected	RodeTypeConst = 0
	RopePresentlyDetected	RodeTypeConst = 1
)

func (e RodeTypeConst) GoString() string {return e.String() }
func (e RodeTypeConst) String() string {
	switch e {
		case 0:
			return "Chain presently detected"
		case 1:
			return "Rope presently detected"
	default:
		return fmt.Sprintf("%s(%d)", "RodeTypeConst", int(e))
	}
}

type DockingStatusConst uint8
const (
	NotDocked	DockingStatusConst = 0
	FullyDocked	DockingStatusConst = 1
)

func (e DockingStatusConst) GoString() string {return e.String() }
func (e DockingStatusConst) String() string {
	switch e {
		case 0:
			return "Not docked"
		case 1:
			return "Fully docked"
	default:
		return fmt.Sprintf("%s(%d)", "DockingStatusConst", int(e))
	}
}

type AisTypeConst uint8
const (
	SOTDMA	AisTypeConst = 0
	CS	AisTypeConst = 1
)

func (e AisTypeConst) GoString() string {return e.String() }
func (e AisTypeConst) String() string {
	switch e {
		case 0:
			return "SOTDMA"
		case 1:
			return "CS"
	default:
		return fmt.Sprintf("%s(%d)", "AisTypeConst", int(e))
	}
}

type AisBandConst uint8
const (
	Top525KHzOfMarineBand	AisBandConst = 0
	EntireMarineBand	AisBandConst = 1
)

func (e AisBandConst) GoString() string {return e.String() }
func (e AisBandConst) String() string {
	switch e {
		case 0:
			return "Top 525 kHz of marine band"
		case 1:
			return "Entire marine band"
	default:
		return fmt.Sprintf("%s(%d)", "AisBandConst", int(e))
	}
}

type AisModeConst uint8
const (
	Autonomous_2	AisModeConst = 0
	Assigned	AisModeConst = 1
)

func (e AisModeConst) GoString() string {return e.String() }
func (e AisModeConst) String() string {
	switch e {
		case 0:
			return "Autonomous"
		case 1:
			return "Assigned"
	default:
		return fmt.Sprintf("%s(%d)", "AisModeConst", int(e))
	}
}

type AisCommunicationStateConst uint8
const (
	SOTDMA_2	AisCommunicationStateConst = 0
	ITDMA	AisCommunicationStateConst = 1
)

func (e AisCommunicationStateConst) GoString() string {return e.String() }
func (e AisCommunicationStateConst) String() string {
	switch e {
		case 0:
			return "SOTDMA"
		case 1:
			return "ITDMA"
	default:
		return fmt.Sprintf("%s(%d)", "AisCommunicationStateConst", int(e))
	}
}

type AvailableConst uint8
const (
	Available	AvailableConst = 0
	NotAvailable_3	AvailableConst = 1
)

func (e AvailableConst) GoString() string {return e.String() }
func (e AvailableConst) String() string {
	switch e {
		case 0:
			return "Available"
		case 1:
			return "Not available"
	default:
		return fmt.Sprintf("%s(%d)", "AvailableConst", int(e))
	}
}

type BearingModeConst uint8
const (
	GreatCircle	BearingModeConst = 0
	Rhumbline	BearingModeConst = 1
)

func (e BearingModeConst) GoString() string {return e.String() }
func (e BearingModeConst) String() string {
	switch e {
		case 0:
			return "Great Circle"
		case 1:
			return "Rhumbline"
	default:
		return fmt.Sprintf("%s(%d)", "BearingModeConst", int(e))
	}
}

type MarkTypeConst uint8
const (
	Collision_2	MarkTypeConst = 0
	TurningPoint	MarkTypeConst = 1
	Reference	MarkTypeConst = 2
	Wheelover	MarkTypeConst = 3
	Waypoint	MarkTypeConst = 4
)

func (e MarkTypeConst) GoString() string {return e.String() }
func (e MarkTypeConst) String() string {
	switch e {
		case 0:
			return "Collision"
		case 1:
			return "Turning point"
		case 2:
			return "Reference"
		case 3:
			return "Wheelover"
		case 4:
			return "Waypoint"
	default:
		return fmt.Sprintf("%s(%d)", "MarkTypeConst", int(e))
	}
}

type GnssModeConst uint8
const (
	A1D	GnssModeConst = 0
	A2D	GnssModeConst = 1
	A3D	GnssModeConst = 2
	Auto_4	GnssModeConst = 3
)

func (e GnssModeConst) GoString() string {return e.String() }
func (e GnssModeConst) String() string {
	switch e {
		case 0:
			return "A1D"
		case 1:
			return "A2D"
		case 2:
			return "A3D"
		case 3:
			return "Auto"
	default:
		return fmt.Sprintf("%s(%d)", "GnssModeConst", int(e))
	}
}

type RangeResidualModeConst uint8
const (
	RangeResidualsWereUsedToCalculateData	RangeResidualModeConst = 0
	RangeResidualsWereCalculatedAfterThePosition	RangeResidualModeConst = 1
)

func (e RangeResidualModeConst) GoString() string {return e.String() }
func (e RangeResidualModeConst) String() string {
	switch e {
		case 0:
			return "Range residuals were used to calculate data"
		case 1:
			return "Range residuals were calculated after the position"
	default:
		return fmt.Sprintf("%s(%d)", "RangeResidualModeConst", int(e))
	}
}

type DgnssModeConst uint8
const (
	None_3	DgnssModeConst = 0
	SBASIfAvailable	DgnssModeConst = 1
	SBAS	DgnssModeConst = 3
)

func (e DgnssModeConst) GoString() string {return e.String() }
func (e DgnssModeConst) String() string {
	switch e {
		case 0:
			return "None"
		case 1:
			return "SBAS if available"
		case 3:
			return "SBAS"
	default:
		return fmt.Sprintf("%s(%d)", "DgnssModeConst", int(e))
	}
}

type SatelliteStatusConst uint8
const (
	NotTracked	SatelliteStatusConst = 0
	Tracked	SatelliteStatusConst = 1
	Used	SatelliteStatusConst = 2
	NotTrackedDiff	SatelliteStatusConst = 3
	TrackedDiff	SatelliteStatusConst = 4
	UsedDiff	SatelliteStatusConst = 5
)

func (e SatelliteStatusConst) GoString() string {return e.String() }
func (e SatelliteStatusConst) String() string {
	switch e {
		case 0:
			return "Not tracked"
		case 1:
			return "Tracked"
		case 2:
			return "Used"
		case 3:
			return "Not tracked+Diff"
		case 4:
			return "Tracked+Diff"
		case 5:
			return "Used+Diff"
	default:
		return fmt.Sprintf("%s(%d)", "SatelliteStatusConst", int(e))
	}
}

type AisVersionConst uint8
const (
	ITURM1371Minus1	AisVersionConst = 0
	ITURM13713	AisVersionConst = 1
	ITURM13715	AisVersionConst = 2
	ITURM1371FutureEdition	AisVersionConst = 3
)

func (e AisVersionConst) GoString() string {return e.String() }
func (e AisVersionConst) String() string {
	switch e {
		case 0:
			return "ITU-R M.1371-1"
		case 1:
			return "ITU-R M.1371-3"
		case 2:
			return "ITU-R M.1371-5"
		case 3:
			return "ITU-R M.1371 future edition"
	default:
		return fmt.Sprintf("%s(%d)", "AisVersionConst", int(e))
	}
}

type TideConst uint8
const (
	Falling	TideConst = 0
	Rising	TideConst = 1
)

func (e TideConst) GoString() string {return e.String() }
func (e TideConst) String() string {
	switch e {
		case 0:
			return "Falling"
		case 1:
			return "Rising"
	default:
		return fmt.Sprintf("%s(%d)", "TideConst", int(e))
	}
}

type WatermakerStateConst uint8
const (
	Stopped	WatermakerStateConst = 0
	Starting	WatermakerStateConst = 1
	Running	WatermakerStateConst = 2
	Stopping	WatermakerStateConst = 3
	Flushing	WatermakerStateConst = 4
	Rinsing	WatermakerStateConst = 5
	Initiating	WatermakerStateConst = 6
	Manual_5	WatermakerStateConst = 7
)

func (e WatermakerStateConst) GoString() string {return e.String() }
func (e WatermakerStateConst) String() string {
	switch e {
		case 0:
			return "Stopped"
		case 1:
			return "Starting"
		case 2:
			return "Running"
		case 3:
			return "Stopping"
		case 4:
			return "Flushing"
		case 5:
			return "Rinsing"
		case 6:
			return "Initiating"
		case 7:
			return "Manual"
	default:
		return fmt.Sprintf("%s(%d)", "WatermakerStateConst", int(e))
	}
}

type EntertainmentIdTypeConst uint8
const (
	Group	EntertainmentIdTypeConst = 0
	File_3	EntertainmentIdTypeConst = 1
	EncryptedGroup	EntertainmentIdTypeConst = 2
	EncryptedFile	EntertainmentIdTypeConst = 3
)

func (e EntertainmentIdTypeConst) GoString() string {return e.String() }
func (e EntertainmentIdTypeConst) String() string {
	switch e {
		case 0:
			return "Group"
		case 1:
			return "File"
		case 2:
			return "Encrypted group"
		case 3:
			return "Encrypted file"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentIdTypeConst", int(e))
	}
}

type EntertainmentDefaultSettingsConst uint8
const (
	SaveCurrentSettingsAsUserDefault	EntertainmentDefaultSettingsConst = 0
	LoadUserDefault	EntertainmentDefaultSettingsConst = 1
	LoadManufacturerDefault	EntertainmentDefaultSettingsConst = 2
)

func (e EntertainmentDefaultSettingsConst) GoString() string {return e.String() }
func (e EntertainmentDefaultSettingsConst) String() string {
	switch e {
		case 0:
			return "Save current settings as user default"
		case 1:
			return "Load user default"
		case 2:
			return "Load manufacturer default"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentDefaultSettingsConst", int(e))
	}
}

type EntertainmentRegionsConst uint8
const (
	USA	EntertainmentRegionsConst = 0
	Europe	EntertainmentRegionsConst = 1
	Asia	EntertainmentRegionsConst = 2
	MiddleEast	EntertainmentRegionsConst = 3
	LatinAmerica	EntertainmentRegionsConst = 4
	Australia	EntertainmentRegionsConst = 5
	Russia	EntertainmentRegionsConst = 6
	Japan	EntertainmentRegionsConst = 7
)

func (e EntertainmentRegionsConst) GoString() string {return e.String() }
func (e EntertainmentRegionsConst) String() string {
	switch e {
		case 0:
			return "USA"
		case 1:
			return "Europe"
		case 2:
			return "Asia"
		case 3:
			return "Middle East"
		case 4:
			return "Latin America"
		case 5:
			return "Australia"
		case 6:
			return "Russia"
		case 7:
			return "Japan"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRegionsConst", int(e))
	}
}

type VideoProtocolsConst uint8
const (
	PAL	VideoProtocolsConst = 0
	NTSC	VideoProtocolsConst = 1
)

func (e VideoProtocolsConst) GoString() string {return e.String() }
func (e VideoProtocolsConst) String() string {
	switch e {
		case 0:
			return "PAL"
		case 1:
			return "NTSC"
	default:
		return fmt.Sprintf("%s(%d)", "VideoProtocolsConst", int(e))
	}
}

type EntertainmentVolumeControlConst uint8
const (
	Up_2	EntertainmentVolumeControlConst = 0
	Down_2	EntertainmentVolumeControlConst = 1
)

func (e EntertainmentVolumeControlConst) GoString() string {return e.String() }
func (e EntertainmentVolumeControlConst) String() string {
	switch e {
		case 0:
			return "Up"
		case 1:
			return "Down"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentVolumeControlConst", int(e))
	}
}

type BluetoothStatusConst uint8
const (
	Connected	BluetoothStatusConst = 0
	NotConnected	BluetoothStatusConst = 1
	NotPaired	BluetoothStatusConst = 2
)

func (e BluetoothStatusConst) GoString() string {return e.String() }
func (e BluetoothStatusConst) String() string {
	switch e {
		case 0:
			return "Connected"
		case 1:
			return "Not connected"
		case 2:
			return "Not paired"
	default:
		return fmt.Sprintf("%s(%d)", "BluetoothStatusConst", int(e))
	}
}

type BluetoothSourceStatusConst uint8
const (
	Reserved_3	BluetoothSourceStatusConst = 0
	Connected_2	BluetoothSourceStatusConst = 1
	Connecting	BluetoothSourceStatusConst = 2
	NotConnected_2	BluetoothSourceStatusConst = 3
)

func (e BluetoothSourceStatusConst) GoString() string {return e.String() }
func (e BluetoothSourceStatusConst) String() string {
	switch e {
		case 0:
			return "Reserved"
		case 1:
			return "Connected"
		case 2:
			return "Connecting"
		case 3:
			return "Not connected"
	default:
		return fmt.Sprintf("%s(%d)", "BluetoothSourceStatusConst", int(e))
	}
}

type SonichubCommandConst uint8
const (
	Init2	SonichubCommandConst = 1
	AMRadio	SonichubCommandConst = 4
	ZoneInfo	SonichubCommandConst = 5
	Source	SonichubCommandConst = 6
	SourceList	SonichubCommandConst = 8
	Control	SonichubCommandConst = 9
	FMRadio	SonichubCommandConst = 12
	Playlist	SonichubCommandConst = 13
	Track_3	SonichubCommandConst = 14
	Artist	SonichubCommandConst = 15
	Album	SonichubCommandConst = 16
	MenuItem	SonichubCommandConst = 19
	Zones	SonichubCommandConst = 20
	MaxVolume	SonichubCommandConst = 23
	Volume	SonichubCommandConst = 24
	Init1	SonichubCommandConst = 25
	Position	SonichubCommandConst = 48
	Init3	SonichubCommandConst = 50
)

func (e SonichubCommandConst) GoString() string {return e.String() }
func (e SonichubCommandConst) String() string {
	switch e {
		case 1:
			return "Init #2"
		case 4:
			return "AM Radio"
		case 5:
			return "Zone Info"
		case 6:
			return "Source"
		case 8:
			return "Source List"
		case 9:
			return "Control"
		case 12:
			return "FM Radio"
		case 13:
			return "Playlist"
		case 14:
			return "Track"
		case 15:
			return "Artist"
		case 16:
			return "Album"
		case 19:
			return "Menu Item"
		case 20:
			return "Zones"
		case 23:
			return "Max Volume"
		case 24:
			return "Volume"
		case 25:
			return "Init #1"
		case 48:
			return "Position"
		case 50:
			return "Init #3"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubCommandConst", int(e))
	}
}

type SimnetApModeConst uint8
const (
	Heading	SimnetApModeConst = 2
	Wind_3	SimnetApModeConst = 3
	Nav	SimnetApModeConst = 10
	NoDrift	SimnetApModeConst = 11
)

func (e SimnetApModeConst) GoString() string {return e.String() }
func (e SimnetApModeConst) String() string {
	switch e {
		case 2:
			return "Heading"
		case 3:
			return "Wind"
		case 10:
			return "Nav"
		case 11:
			return "No Drift"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApModeConst", int(e))
	}
}

type SimnetDeviceModelConst uint8
const (
	AC	SimnetDeviceModelConst = 0
	OtherDevice	SimnetDeviceModelConst = 1
	NAC	SimnetDeviceModelConst = 100
)

func (e SimnetDeviceModelConst) GoString() string {return e.String() }
func (e SimnetDeviceModelConst) String() string {
	switch e {
		case 0:
			return "AC"
		case 1:
			return "Other device"
		case 100:
			return "NAC"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDeviceModelConst", int(e))
	}
}

type SimnetDeviceReportConst uint8
const (
	Status	SimnetDeviceReportConst = 2
	SendStatus	SimnetDeviceReportConst = 3
	Mode	SimnetDeviceReportConst = 10
	SendMode	SimnetDeviceReportConst = 11
	SailingProcessorStatus	SimnetDeviceReportConst = 23
)

func (e SimnetDeviceReportConst) GoString() string {return e.String() }
func (e SimnetDeviceReportConst) String() string {
	switch e {
		case 2:
			return "Status"
		case 3:
			return "Send Status"
		case 10:
			return "Mode"
		case 11:
			return "Send Mode"
		case 23:
			return "Sailing Processor Status"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDeviceReportConst", int(e))
	}
}

type SimnetApStatusConst uint8
const (
	Manual_6	SimnetApStatusConst = 2
	Automatic_2	SimnetApStatusConst = 16
)

func (e SimnetApStatusConst) GoString() string {return e.String() }
func (e SimnetApStatusConst) String() string {
	switch e {
		case 2:
			return "Manual"
		case 16:
			return "Automatic"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApStatusConst", int(e))
	}
}

type SimnetCommandConst uint8
const (
	Text	SimnetCommandConst = 50
)

func (e SimnetCommandConst) GoString() string {return e.String() }
func (e SimnetCommandConst) String() string {
	switch e {
		case 50:
			return "Text"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetCommandConst", int(e))
	}
}

type SimnetEventCommandConst uint8
const (
	Alarm_2	SimnetEventCommandConst = 1
	APCommand	SimnetEventCommandConst = 2
	Autopilot_2	SimnetEventCommandConst = 255
)

func (e SimnetEventCommandConst) GoString() string {return e.String() }
func (e SimnetEventCommandConst) String() string {
	switch e {
		case 1:
			return "Alarm"
		case 2:
			return "AP command"
		case 255:
			return "Autopilot"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetEventCommandConst", int(e))
	}
}

type SimnetNightModeConst uint8
const (
	Day	SimnetNightModeConst = 2
	Night	SimnetNightModeConst = 4
)

func (e SimnetNightModeConst) GoString() string {return e.String() }
func (e SimnetNightModeConst) String() string {
	switch e {
		case 2:
			return "Day"
		case 4:
			return "Night"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetNightModeConst", int(e))
	}
}

type SimnetNightModeColorConst uint8
const (
	Red	SimnetNightModeColorConst = 0
	Green	SimnetNightModeColorConst = 1
	Blue	SimnetNightModeColorConst = 2
	White	SimnetNightModeColorConst = 3
)

func (e SimnetNightModeColorConst) GoString() string {return e.String() }
func (e SimnetNightModeColorConst) String() string {
	switch e {
		case 0:
			return "Red"
		case 1:
			return "Green"
		case 2:
			return "Blue"
		case 3:
			return "White"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetNightModeColorConst", int(e))
	}
}

type SimnetDisplayGroupConst uint8
const (
	Default	SimnetDisplayGroupConst = 1
	Group1_2	SimnetDisplayGroupConst = 2
	Group2_2	SimnetDisplayGroupConst = 3
	Group3_2	SimnetDisplayGroupConst = 4
	Group4_2	SimnetDisplayGroupConst = 5
	Group5_2	SimnetDisplayGroupConst = 6
	Group6	SimnetDisplayGroupConst = 7
)

func (e SimnetDisplayGroupConst) GoString() string {return e.String() }
func (e SimnetDisplayGroupConst) String() string {
	switch e {
		case 1:
			return "Default"
		case 2:
			return "Group 1"
		case 3:
			return "Group 2"
		case 4:
			return "Group 3"
		case 5:
			return "Group 4"
		case 6:
			return "Group 5"
		case 7:
			return "Group 6"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDisplayGroupConst", int(e))
	}
}

type SimnetHourDisplayConst uint8
const (
	A24Hour	SimnetHourDisplayConst = 0
	A12Hour	SimnetHourDisplayConst = 1
)

func (e SimnetHourDisplayConst) GoString() string {return e.String() }
func (e SimnetHourDisplayConst) String() string {
	switch e {
		case 0:
			return "A24 hour"
		case 1:
			return "A12 hour"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetHourDisplayConst", int(e))
	}
}

type SimnetTimeFormatConst uint8
const (
	MMDdYyyy	SimnetTimeFormatConst = 1
	DdMMYyyy	SimnetTimeFormatConst = 2
)

func (e SimnetTimeFormatConst) GoString() string {return e.String() }
func (e SimnetTimeFormatConst) String() string {
	switch e {
		case 1:
			return "MM/dd/yyyy"
		case 2:
			return "dd/MM/yyyy"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetTimeFormatConst", int(e))
	}
}

type SimnetBacklightLevelConst uint8
const (
	A10PercentMin	SimnetBacklightLevelConst = 0
	DayMode	SimnetBacklightLevelConst = 1
	NightMode	SimnetBacklightLevelConst = 4
	A20Percent	SimnetBacklightLevelConst = 11
	A30Percent	SimnetBacklightLevelConst = 22
	A40Percent	SimnetBacklightLevelConst = 33
	A50Percent	SimnetBacklightLevelConst = 44
	A60Percent	SimnetBacklightLevelConst = 55
	A70Percent	SimnetBacklightLevelConst = 66
	A80Percent	SimnetBacklightLevelConst = 77
	A90Percent	SimnetBacklightLevelConst = 88
	A100PercentMax	SimnetBacklightLevelConst = 99
)

func (e SimnetBacklightLevelConst) GoString() string {return e.String() }
func (e SimnetBacklightLevelConst) String() string {
	switch e {
		case 0:
			return "A10% (Min)"
		case 1:
			return "Day mode"
		case 4:
			return "Night mode"
		case 11:
			return "A20%"
		case 22:
			return "A30%"
		case 33:
			return "A40%"
		case 44:
			return "A50%"
		case 55:
			return "A60%"
		case 66:
			return "A70%"
		case 77:
			return "A80%"
		case 88:
			return "A90%"
		case 99:
			return "A100% (Max)"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetBacklightLevelConst", int(e))
	}
}

type SimnetApEventsConst uint8
const (
	Standby_3	SimnetApEventsConst = 6
	AutoMode	SimnetApEventsConst = 9
	NavMode	SimnetApEventsConst = 10
	NonFollowUpMode	SimnetApEventsConst = 13
	FollowUpMode	SimnetApEventsConst = 14
	WindMode	SimnetApEventsConst = 15
	SquareTurn	SimnetApEventsConst = 18
	CTurn	SimnetApEventsConst = 19
	UTurn	SimnetApEventsConst = 20
	SpiralTurn	SimnetApEventsConst = 21
	ZigZagTurn	SimnetApEventsConst = 22
	LazySTurn	SimnetApEventsConst = 23
	DepthTurn	SimnetApEventsConst = 24
	ChangeCourse	SimnetApEventsConst = 26
	TimerSync	SimnetApEventsConst = 61
	PingPortEnd	SimnetApEventsConst = 112
	PingStarboardEnd	SimnetApEventsConst = 113
)

func (e SimnetApEventsConst) GoString() string {return e.String() }
func (e SimnetApEventsConst) String() string {
	switch e {
		case 6:
			return "Standby"
		case 9:
			return "Auto mode"
		case 10:
			return "Nav mode"
		case 13:
			return "Non Follow Up mode"
		case 14:
			return "Follow Up mode"
		case 15:
			return "Wind mode"
		case 18:
			return "Square (Turn)"
		case 19:
			return "C-Turn"
		case 20:
			return "U-Turn"
		case 21:
			return "Spiral (Turn)"
		case 22:
			return "Zig Zag (Turn)"
		case 23:
			return "Lazy-S (Turn)"
		case 24:
			return "Depth (Turn)"
		case 26:
			return "Change course"
		case 61:
			return "Timer sync"
		case 112:
			return "Ping port end"
		case 113:
			return "Ping starboard end"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApEventsConst", int(e))
	}
}

type SimnetDirectionConst uint8
const (
	Port	SimnetDirectionConst = 2
	Starboard	SimnetDirectionConst = 3
	LeftRudderPort	SimnetDirectionConst = 4
	RightRudderStarboard	SimnetDirectionConst = 5
)

func (e SimnetDirectionConst) GoString() string {return e.String() }
func (e SimnetDirectionConst) String() string {
	switch e {
		case 2:
			return "Port"
		case 3:
			return "Starboard"
		case 4:
			return "Left rudder (port)"
		case 5:
			return "Right rudder (starboard)"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetDirectionConst", int(e))
	}
}

type SimnetAlarmConst uint8
const (
	LowBoatSpeed	SimnetAlarmConst = 57
	WindDataMissing	SimnetAlarmConst = 58
)

func (e SimnetAlarmConst) GoString() string {return e.String() }
func (e SimnetAlarmConst) String() string {
	switch e {
		case 57:
			return "Low boat speed"
		case 58:
			return "Wind data missing"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetAlarmConst", int(e))
	}
}

type FusionMessageIdConst uint8
const (
	RequestStatus	FusionMessageIdConst = 1
	Source_2	FusionMessageIdConst = 2
	TrackInfo	FusionMessageIdConst = 4
	TrackTitle	FusionMessageIdConst = 5
	TrackArtist	FusionMessageIdConst = 6
	TrackAlbum	FusionMessageIdConst = 7
	TrackProgress	FusionMessageIdConst = 9
	AMFMStation	FusionMessageIdConst = 11
	VHF	FusionMessageIdConst = 12
	Squelch	FusionMessageIdConst = 13
	Scan	FusionMessageIdConst = 14
	MenuItem_2	FusionMessageIdConst = 17
	Replay	FusionMessageIdConst = 20
	Mute	FusionMessageIdConst = 23
	SetZoneVolume	FusionMessageIdConst = 24
	SetAllVolumes	FusionMessageIdConst = 25
	SubVolume	FusionMessageIdConst = 26
	Tone	FusionMessageIdConst = 27
	Volume_2	FusionMessageIdConst = 29
	Power	FusionMessageIdConst = 32
	UnitName	FusionMessageIdConst = 33
	SiriusXMChannel	FusionMessageIdConst = 36
	SiriusXMTitle	FusionMessageIdConst = 37
	SiriusXMArtist	FusionMessageIdConst = 38
	SiriusXMGenre	FusionMessageIdConst = 40
	ZoneName	FusionMessageIdConst = 45
)

func (e FusionMessageIdConst) GoString() string {return e.String() }
func (e FusionMessageIdConst) String() string {
	switch e {
		case 1:
			return "Request Status"
		case 2:
			return "Source"
		case 4:
			return "Track Info"
		case 5:
			return "Track Title"
		case 6:
			return "Track Artist"
		case 7:
			return "Track Album"
		case 9:
			return "Track Progress"
		case 11:
			return "AM/FM Station"
		case 12:
			return "VHF"
		case 13:
			return "Squelch"
		case 14:
			return "Scan"
		case 17:
			return "Menu Item"
		case 20:
			return "Replay"
		case 23:
			return "Mute"
		case 24:
			return "Set Zone Volume"
		case 25:
			return "Set All Volumes"
		case 26:
			return "Sub Volume"
		case 27:
			return "Tone"
		case 29:
			return "Volume"
		case 32:
			return "Power"
		case 33:
			return "Unit Name"
		case 36:
			return "SiriusXM Channel"
		case 37:
			return "SiriusXM Title"
		case 38:
			return "SiriusXM Artist"
		case 40:
			return "SiriusXM Genre"
		case 45:
			return "Zone Name"
	default:
		return fmt.Sprintf("%s(%d)", "FusionMessageIdConst", int(e))
	}
}

type SonichubControlConst uint8
const (
	Set	SonichubControlConst = 0
	Ack	SonichubControlConst = 128
)

func (e SonichubControlConst) GoString() string {return e.String() }
func (e SonichubControlConst) String() string {
	switch e {
		case 0:
			return "Set"
		case 128:
			return "Ack"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubControlConst", int(e))
	}
}

type SonichubSourceConst uint8
const (
	AM_2	SonichubSourceConst = 0
	FM_2	SonichubSourceConst = 1
	IPod	SonichubSourceConst = 2
	USB_2	SonichubSourceConst = 3
	AUX	SonichubSourceConst = 4
	AUX2	SonichubSourceConst = 5
	Mic	SonichubSourceConst = 6
)

func (e SonichubSourceConst) GoString() string {return e.String() }
func (e SonichubSourceConst) String() string {
	switch e {
		case 0:
			return "AM"
		case 1:
			return "FM"
		case 2:
			return "iPod"
		case 3:
			return "USB"
		case 4:
			return "AUX"
		case 5:
			return "AUX 2"
		case 6:
			return "Mic"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubSourceConst", int(e))
	}
}

type IsoControlConst uint8
const (
	ACK	IsoControlConst = 0
	NAK	IsoControlConst = 1
	AccessDenied_3	IsoControlConst = 2
	AddressBusy	IsoControlConst = 3
)

func (e IsoControlConst) GoString() string {return e.String() }
func (e IsoControlConst) String() string {
	switch e {
		case 0:
			return "ACK"
		case 1:
			return "NAK"
		case 2:
			return "Access Denied"
		case 3:
			return "Address Busy"
	default:
		return fmt.Sprintf("%s(%d)", "IsoControlConst", int(e))
	}
}

type IsoCommandConst uint8
const (
	ACK_2	IsoCommandConst = 0
	RTS	IsoCommandConst = 16
	CTS	IsoCommandConst = 17
	EOM	IsoCommandConst = 19
	BAM	IsoCommandConst = 32
	Abort	IsoCommandConst = 255
)

func (e IsoCommandConst) GoString() string {return e.String() }
func (e IsoCommandConst) String() string {
	switch e {
		case 0:
			return "ACK"
		case 16:
			return "RTS"
		case 17:
			return "CTS"
		case 19:
			return "EOM"
		case 32:
			return "BAM"
		case 255:
			return "Abort"
	default:
		return fmt.Sprintf("%s(%d)", "IsoCommandConst", int(e))
	}
}

type GroupFunctionConst uint8
const (
	Request	GroupFunctionConst = 0
	Command	GroupFunctionConst = 1
	Acknowledge_4	GroupFunctionConst = 2
	ReadFields	GroupFunctionConst = 3
	ReadFieldsReply	GroupFunctionConst = 4
	WriteFields	GroupFunctionConst = 5
	WriteFieldsReply	GroupFunctionConst = 6
)

func (e GroupFunctionConst) GoString() string {return e.String() }
func (e GroupFunctionConst) String() string {
	switch e {
		case 0:
			return "Request"
		case 1:
			return "Command"
		case 2:
			return "Acknowledge"
		case 3:
			return "Read Fields"
		case 4:
			return "Read Fields Reply"
		case 5:
			return "Write Fields"
		case 6:
			return "Write Fields Reply"
	default:
		return fmt.Sprintf("%s(%d)", "GroupFunctionConst", int(e))
	}
}

type AirmarCommandConst uint8
const (
	AttitudeOffsets	AirmarCommandConst = 32
	CalibrateCompass	AirmarCommandConst = 33
	TrueWindOptions	AirmarCommandConst = 34
	SimulateMode_2	AirmarCommandConst = 35
	CalibrateDepth	AirmarCommandConst = 40
	CalibrateSpeed	AirmarCommandConst = 41
	CalibrateTemperature	AirmarCommandConst = 42
	SpeedFilter	AirmarCommandConst = 43
	TemperatureFilter	AirmarCommandConst = 44
	NMEA2000Options	AirmarCommandConst = 46
)

func (e AirmarCommandConst) GoString() string {return e.String() }
func (e AirmarCommandConst) String() string {
	switch e {
		case 32:
			return "Attitude Offsets"
		case 33:
			return "Calibrate Compass"
		case 34:
			return "True Wind Options"
		case 35:
			return "Simulate Mode"
		case 40:
			return "Calibrate Depth"
		case 41:
			return "Calibrate Speed"
		case 42:
			return "Calibrate Temperature"
		case 43:
			return "Speed Filter"
		case 44:
			return "Temperature Filter"
		case 46:
			return "NMEA 2000 options"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarCommandConst", int(e))
	}
}

type AirmarDepthQualityFactorConst uint8
const (
	DepthUnlocked	AirmarDepthQualityFactorConst = 0
	Quality10Percent	AirmarDepthQualityFactorConst = 1
	Quality20Percent	AirmarDepthQualityFactorConst = 2
	Quality30Percent	AirmarDepthQualityFactorConst = 3
	Quality40Percent	AirmarDepthQualityFactorConst = 4
	Quality50Percent	AirmarDepthQualityFactorConst = 5
	Quality60Percent	AirmarDepthQualityFactorConst = 6
	Quality70Percent	AirmarDepthQualityFactorConst = 7
	Quality80Percent	AirmarDepthQualityFactorConst = 8
	Quality90Percent	AirmarDepthQualityFactorConst = 9
	Quality100Percent	AirmarDepthQualityFactorConst = 10
)

func (e AirmarDepthQualityFactorConst) GoString() string {return e.String() }
func (e AirmarDepthQualityFactorConst) String() string {
	switch e {
		case 0:
			return "Depth unlocked"
		case 1:
			return "Quality 10%"
		case 2:
			return "Quality 20%"
		case 3:
			return "Quality 30%"
		case 4:
			return "Quality 40%"
		case 5:
			return "Quality 50%"
		case 6:
			return "Quality 60%"
		case 7:
			return "Quality 70%"
		case 8:
			return "Quality 80%"
		case 9:
			return "Quality 90%"
		case 10:
			return "Quality 100%"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarDepthQualityFactorConst", int(e))
	}
}

type PgnErrorCodeConst uint8
const (
	Acknowledge_5	PgnErrorCodeConst = 0
	PGNNotSupported	PgnErrorCodeConst = 1
	PGNNotAvailable	PgnErrorCodeConst = 2
	AccessDenied_4	PgnErrorCodeConst = 3
	NotSupported_3	PgnErrorCodeConst = 4
	TagNotSupported	PgnErrorCodeConst = 5
	ReadOrWriteNotSupported_2	PgnErrorCodeConst = 6
)

func (e PgnErrorCodeConst) GoString() string {return e.String() }
func (e PgnErrorCodeConst) String() string {
	switch e {
		case 0:
			return "Acknowledge"
		case 1:
			return "PGN not supported"
		case 2:
			return "PGN not available"
		case 3:
			return "Access denied"
		case 4:
			return "Not supported"
		case 5:
			return "Tag not supported"
		case 6:
			return "Read or Write not supported"
	default:
		return fmt.Sprintf("%s(%d)", "PgnErrorCodeConst", int(e))
	}
}

type AirmarTransmissionIntervalConst uint8
const (
	MeasureInterval	AirmarTransmissionIntervalConst = 0
	RequestedByUser	AirmarTransmissionIntervalConst = 1
)

func (e AirmarTransmissionIntervalConst) GoString() string {return e.String() }
func (e AirmarTransmissionIntervalConst) String() string {
	switch e {
		case 0:
			return "Measure interval"
		case 1:
			return "Requested by user"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarTransmissionIntervalConst", int(e))
	}
}

type MobPositionSourceConst uint8
const (
	PositionEstimatedByTheVessel	MobPositionSourceConst = 0
	PositionReportedByMOBEmitter	MobPositionSourceConst = 1
)

func (e MobPositionSourceConst) GoString() string {return e.String() }
func (e MobPositionSourceConst) String() string {
	switch e {
		case 0:
			return "Position estimated by the vessel"
		case 1:
			return "Position reported by MOB emitter"
	default:
		return fmt.Sprintf("%s(%d)", "MobPositionSourceConst", int(e))
	}
}

type SteeringModeConst uint8
const (
	MainSteering	SteeringModeConst = 0
	NonFollowUpDevice	SteeringModeConst = 1
	FollowUpDevice	SteeringModeConst = 2
	HeadingControlStandalone	SteeringModeConst = 3
	HeadingControl	SteeringModeConst = 4
	TrackControl	SteeringModeConst = 5
)

func (e SteeringModeConst) GoString() string {return e.String() }
func (e SteeringModeConst) String() string {
	switch e {
		case 0:
			return "Main Steering"
		case 1:
			return "Non-Follow-Up Device"
		case 2:
			return "Follow-Up Device"
		case 3:
			return "Heading Control Standalone"
		case 4:
			return "Heading Control"
		case 5:
			return "Track Control"
	default:
		return fmt.Sprintf("%s(%d)", "SteeringModeConst", int(e))
	}
}

type FusionRadioSourceConst uint8
const (
	AM_3	FusionRadioSourceConst = 0
	FM_3	FusionRadioSourceConst = 1
)

func (e FusionRadioSourceConst) GoString() string {return e.String() }
func (e FusionRadioSourceConst) String() string {
	switch e {
		case 0:
			return "AM"
		case 1:
			return "FM"
	default:
		return fmt.Sprintf("%s(%d)", "FusionRadioSourceConst", int(e))
	}
}

type FusionReplayModeConst uint8
const (
	USBRepeat	FusionReplayModeConst = 9
	USBShuffle	FusionReplayModeConst = 10
	IPodRepeat	FusionReplayModeConst = 12
	IPodShuffle	FusionReplayModeConst = 13
)

func (e FusionReplayModeConst) GoString() string {return e.String() }
func (e FusionReplayModeConst) String() string {
	switch e {
		case 9:
			return "USB repeat"
		case 10:
			return "USB shuffle"
		case 12:
			return "iPod repeat"
		case 13:
			return "iPod shuffle"
	default:
		return fmt.Sprintf("%s(%d)", "FusionReplayModeConst", int(e))
	}
}

type FusionReplayStatusConst uint8
const (
	Off_8	FusionReplayStatusConst = 0
	OneTrack	FusionReplayStatusConst = 1
	AllAlbum	FusionReplayStatusConst = 2
)

func (e FusionReplayStatusConst) GoString() string {return e.String() }
func (e FusionReplayStatusConst) String() string {
	switch e {
		case 0:
			return "Off"
		case 1:
			return "One/track"
		case 2:
			return "All/album"
	default:
		return fmt.Sprintf("%s(%d)", "FusionReplayStatusConst", int(e))
	}
}

type AirmarPostControlConst uint8
const (
	ReportPreviousValues	AirmarPostControlConst = 0
	GenerateNewValues	AirmarPostControlConst = 1
)

func (e AirmarPostControlConst) GoString() string {return e.String() }
func (e AirmarPostControlConst) String() string {
	switch e {
		case 0:
			return "Report previous values"
		case 1:
			return "Generate new values"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarPostControlConst", int(e))
	}
}

type AirmarPostIdConst uint8
const (
	FormatCode	AirmarPostIdConst = 1
	FactoryEEPROM	AirmarPostIdConst = 2
	UserEEPROM	AirmarPostIdConst = 3
	WaterTemperatureSensor	AirmarPostIdConst = 4
	SonarTransceiver	AirmarPostIdConst = 5
	SpeedSensor	AirmarPostIdConst = 6
	InternalTemperatureSensor	AirmarPostIdConst = 7
	BatteryVoltageSensor	AirmarPostIdConst = 8
)

func (e AirmarPostIdConst) GoString() string {return e.String() }
func (e AirmarPostIdConst) String() string {
	switch e {
		case 1:
			return "Format Code"
		case 2:
			return "Factory EEPROM"
		case 3:
			return "User EEPROM"
		case 4:
			return "Water Temperature Sensor"
		case 5:
			return "Sonar Transceiver"
		case 6:
			return "Speed sensor"
		case 7:
			return "Internal temperature sensor"
		case 8:
			return "Battery voltage sensor"
	default:
		return fmt.Sprintf("%s(%d)", "AirmarPostIdConst", int(e))
	}
}

type SonichubTuningConst uint8
const (
	SeekingUp	SonichubTuningConst = 1
	Tuned	SonichubTuningConst = 2
	SeekingDown	SonichubTuningConst = 3
)

func (e SonichubTuningConst) GoString() string {return e.String() }
func (e SonichubTuningConst) String() string {
	switch e {
		case 1:
			return "Seeking up"
		case 2:
			return "Tuned"
		case 3:
			return "Seeking down"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubTuningConst", int(e))
	}
}

type SonichubPlaylistConst uint8
const (
	Report	SonichubPlaylistConst = 1
	NextSong	SonichubPlaylistConst = 4
	PreviousSong	SonichubPlaylistConst = 6
)

func (e SonichubPlaylistConst) GoString() string {return e.String() }
func (e SonichubPlaylistConst) String() string {
	switch e {
		case 1:
			return "Report"
		case 4:
			return "Next song"
		case 6:
			return "Previous song"
	default:
		return fmt.Sprintf("%s(%d)", "SonichubPlaylistConst", int(e))
	}
}

type FusionPowerStateConst uint8
const (
	On_2	FusionPowerStateConst = 1
	Off_9	FusionPowerStateConst = 2
)

func (e FusionPowerStateConst) GoString() string {return e.String() }
func (e FusionPowerStateConst) String() string {
	switch e {
		case 1:
			return "On"
		case 2:
			return "Off"
	default:
		return fmt.Sprintf("%s(%d)", "FusionPowerStateConst", int(e))
	}
}

type PriorityConst uint8
const (
	A0	PriorityConst = 0
	A1	PriorityConst = 1
	A2	PriorityConst = 2
	A3	PriorityConst = 3
	A4	PriorityConst = 4
	A5	PriorityConst = 5
	A6	PriorityConst = 6
	A7	PriorityConst = 7
	LeaveUnchanged	PriorityConst = 8
	ResetToDefault	PriorityConst = 9
)

func (e PriorityConst) GoString() string {return e.String() }
func (e PriorityConst) String() string {
	switch e {
		case 0:
			return "A0"
		case 1:
			return "A1"
		case 2:
			return "A2"
		case 3:
			return "A3"
		case 4:
			return "A4"
		case 5:
			return "A5"
		case 6:
			return "A6"
		case 7:
			return "A7"
		case 8:
			return "Leave unchanged"
		case 9:
			return "Reset to default"
	default:
		return fmt.Sprintf("%s(%d)", "PriorityConst", int(e))
	}
}

type DeviceTempStateConst uint8
const (
	Cold	DeviceTempStateConst = 0
	Warm	DeviceTempStateConst = 1
	Hot	DeviceTempStateConst = 2
)

func (e DeviceTempStateConst) GoString() string {return e.String() }
func (e DeviceTempStateConst) String() string {
	switch e {
		case 0:
			return "Cold"
		case 1:
			return "Warm"
		case 2:
			return "Hot"
	default:
		return fmt.Sprintf("%s(%d)", "DeviceTempStateConst", int(e))
	}
}

type BandgDecimalsConst uint8
const (
	A0_2	BandgDecimalsConst = 0
	A1_2	BandgDecimalsConst = 1
	A2_2	BandgDecimalsConst = 2
	A3_2	BandgDecimalsConst = 3
	A4_2	BandgDecimalsConst = 4
	Auto_5	BandgDecimalsConst = 254
)

func (e BandgDecimalsConst) GoString() string {return e.String() }
func (e BandgDecimalsConst) String() string {
	switch e {
		case 0:
			return "A0"
		case 1:
			return "A1"
		case 2:
			return "A2"
		case 3:
			return "A3"
		case 4:
			return "A4"
		case 254:
			return "Auto"
	default:
		return fmt.Sprintf("%s(%d)", "BandgDecimalsConst", int(e))
	}
}

type GarminColorModeConst uint8
const (
	Day_2	GarminColorModeConst = 0
	Night_2	GarminColorModeConst = 1
	Color	GarminColorModeConst = 13
)

func (e GarminColorModeConst) GoString() string {return e.String() }
func (e GarminColorModeConst) String() string {
	switch e {
		case 0:
			return "Day"
		case 1:
			return "Night"
		case 13:
			return "Color"
	default:
		return fmt.Sprintf("%s(%d)", "GarminColorModeConst", int(e))
	}
}

type GarminColorConst uint8
const (
	DayFullColor	GarminColorConst = 0
	DayHighContrast	GarminColorConst = 1
	NightFullColor	GarminColorConst = 2
	NightRedBlack	GarminColorConst = 3
	NightGreenBlack	GarminColorConst = 4
)

func (e GarminColorConst) GoString() string {return e.String() }
func (e GarminColorConst) String() string {
	switch e {
		case 0:
			return "Day full color"
		case 1:
			return "Day high contrast"
		case 2:
			return "Night full color"
		case 3:
			return "Night red/black"
		case 4:
			return "Night green/black"
	default:
		return fmt.Sprintf("%s(%d)", "GarminColorConst", int(e))
	}
}

type GarminBacklightLevelConst uint8
const (
	A0Percent	GarminBacklightLevelConst = 0
	A5Percent	GarminBacklightLevelConst = 1
	A10Percent	GarminBacklightLevelConst = 2
	A15Percent	GarminBacklightLevelConst = 3
	A20Percent_2	GarminBacklightLevelConst = 4
	A25Percent	GarminBacklightLevelConst = 5
	A30Percent_2	GarminBacklightLevelConst = 6
	A35Percent	GarminBacklightLevelConst = 7
	A40Percent_2	GarminBacklightLevelConst = 8
	A45Percent	GarminBacklightLevelConst = 9
	A50Percent_2	GarminBacklightLevelConst = 10
	A55Percent	GarminBacklightLevelConst = 11
	A60Percent_2	GarminBacklightLevelConst = 12
	A65Percent	GarminBacklightLevelConst = 13
	A70Percent_2	GarminBacklightLevelConst = 14
	A75Percent	GarminBacklightLevelConst = 15
	A80Percent_2	GarminBacklightLevelConst = 16
	A85Percent	GarminBacklightLevelConst = 17
	A90Percent_2	GarminBacklightLevelConst = 18
	A95Percent	GarminBacklightLevelConst = 19
	A100Percent	GarminBacklightLevelConst = 20
)

func (e GarminBacklightLevelConst) GoString() string {return e.String() }
func (e GarminBacklightLevelConst) String() string {
	switch e {
		case 0:
			return "A0%"
		case 1:
			return "A5%"
		case 2:
			return "A10%"
		case 3:
			return "A15%"
		case 4:
			return "A20%"
		case 5:
			return "A25%"
		case 6:
			return "A30%"
		case 7:
			return "A35%"
		case 8:
			return "A40%"
		case 9:
			return "A45%"
		case 10:
			return "A50%"
		case 11:
			return "A55%"
		case 12:
			return "A60%"
		case 13:
			return "A65%"
		case 14:
			return "A70%"
		case 15:
			return "A75%"
		case 16:
			return "A80%"
		case 17:
			return "A85%"
		case 18:
			return "A90%"
		case 19:
			return "A95%"
		case 20:
			return "A100%"
	default:
		return fmt.Sprintf("%s(%d)", "GarminBacklightLevelConst", int(e))
	}
}

type SeatalkPilotMode16Const uint16
const (
	Standby_4	SeatalkPilotMode16Const = 0
	AutoCompassCommanded	SeatalkPilotMode16Const = 64
	VaneWindMode	SeatalkPilotMode16Const = 256
	TrackMode	SeatalkPilotMode16Const = 384
	NoDriftCOGReferencedInTrackCourseChanges	SeatalkPilotMode16Const = 385
)

func (e SeatalkPilotMode16Const) GoString() string {return e.String() }
func (e SeatalkPilotMode16Const) String() string {
	switch e {
		case 0:
			return "Standby"
		case 64:
			return "Auto, compass commanded"
		case 256:
			return "Vane, Wind Mode"
		case 384:
			return "Track Mode"
		case 385:
			return "No Drift, COG referenced (In track, course changes)"
	default:
		return fmt.Sprintf("%s(%d)", "SeatalkPilotMode16Const", int(e))
	}
}


type DeviceFunctionConst uint16
var DeviceFunctionConstMap = map[int]map[int]string{10: {130: "Diagnostic",
	140: "Bus Traffic Logger",
	 },
20: {110: "Alarm Enunciator",
	130: "Emergency Position Indicating Radio Beacon (EPIRB)",
	135: "Man Overboard",
	140: "Voyage Data Recorder",
	150: "Camera",
	 },
25: {130: "PC Gateway",
	131: "NMEA 2000 to Analog Gateway",
	132: "Analog to NMEA 2000 Gateway",
	133: "NMEA 2000 to Serial Gateway",
	135: "NMEA 0183 Gateway",
	136: "NMEA Network Gateway",
	137: "NMEA 2000 Wireless Gateway",
	140: "Router",
	150: "Bridge",
	160: "Repeater",
	 },
30: {130: "Binary Event Monitor",
	140: "Load Controller",
	141: "AC/DC Input",
	150: "Function Controller",
	 },
35: {140: "Engine",
	141: "DC Generator/Alternator",
	142: "Solar Panel (Solar Array)",
	143: "Wind Generator (DC)",
	144: "Fuel Cell",
	145: "Network Power Supply",
	151: "AC Generator",
	152: "AC Bus",
	153: "AC Mains (Utility/Shore)",
	154: "AC Output",
	160: "Power Converter - Battery Charger",
	161: "Power Converter - Battery Charger+Inverter",
	162: "Power Converter - Inverter",
	163: "Power Converter - DC",
	170: "Battery",
	180: "Engine Gateway",
	 },
40: {130: "Follow-up Controller",
	140: "Mode Controller",
	150: "Autopilot",
	155: "Rudder",
	160: "Heading Sensors",
	170: "Trim (Tabs)/Interceptors",
	180: "Attitude (Pitch, Roll, Yaw) Control",
	 },
50: {130: "Engineroom Monitoring",
	140: "Engine",
	141: "DC Generator/Alternator",
	150: "Engine Controller",
	151: "AC Generator",
	155: "Motor",
	160: "Engine Gateway",
	165: "Transmission",
	170: "Throttle/Shift Control",
	180: "Actuator",
	190: "Gauge Interface",
	200: "Gauge Large",
	210: "Gauge Small",
	 },
60: {130: "Bottom Depth",
	135: "Bottom Depth/Speed",
	136: "Bottom Depth/Speed/Temperature",
	140: "Ownship Attitude",
	145: "Ownship Position (GNSS)",
	150: "Ownship Position (Loran C)",
	155: "Speed",
	160: "Turn Rate Indicator",
	170: "Integrated Navigation",
	175: "Integrated Navigation System",
	190: "Navigation Management",
	195: "Automatic Identification System (AIS)",
	200: "Radar",
	201: "Infrared Imaging",
	205: "ECDIS",
	210: "ECS",
	220: "Direction Finder",
	230: "Voyage Status",
	 },
70: {130: "EPIRB",
	140: "AIS",
	150: "DSC",
	160: "Data Receiver/Transceiver",
	170: "Satellite",
	180: "Radio-telephone (MF/HF)",
	190: "Radiotelephone",
	 },
75: {130: "Temperature",
	140: "Pressure",
	150: "Fluid Level",
	160: "Flow",
	170: "Humidity",
	 },
80: {130: "Time/Date Systems",
	140: "VDR",
	150: "Integrated Instrumentation",
	160: "General Purpose Displays",
	170: "General Sensor Box",
	180: "Weather Instruments",
	190: "Transducer/General",
	200: "NMEA 0183 Converter",
	 },
85: {130: "Atmospheric",
	160: "Aquatic",
	 },
90: {130: "HVAC",
	 },
100: {130: "Scale (Catch)",
	 },
110: {130: "Button Interface",
	135: "Switch Interface",
	140: "Analog Interface",
	 },
120: {130: "Display",
	140: "Alarm Enunciator",
	 },
125: {130: "Multimedia Player",
	140: "Multimedia Controller",
	 },

}








type SimnetKeyValueConst uint16
var SimnetKeyValueConstMap = map[int]FieldDescriptor{0: {
		Name: "Heading Offset",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	41: {
		Name: "Timezone offset",
		CanboatType: "TIME",
		Resolution: 60,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	260: {
		Name: "True wind high",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	264: {
		Name: "Deep water",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	516: {
		Name: "True wind low",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	517: {
		Name: "Low boat speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	520: {
		Name: "Shallow water",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	768: {
		Name: "Local field",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	1024: {
		Name: "Field angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	1800: {
		Name: "Anchor depth",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	4863: {
		Name: "Backlight level",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	5160: {
		Name: "Time format",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	5161: {
		Name: "Time hour display",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	9983: {
		Name: "Night mode",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	11524: {
		Name: "True wind shift",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	22296: {
		Name: "AP low boat speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	32789: {
		Name: "Alert bits",
		CanboatType: "BITLOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "SIMNET_ALERT_BITFIELD",
		},
	44079: {
		Name: "Night mode color",
		CanboatType: "LOOKUP",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	55087: {
		Name: "Day mode invert",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	 
}



type BandgKeyValueConst uint16
var BandgKeyValueConstMap = map[int]FieldDescriptor{0: {
		Name: "Altitude",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	11: {
		Name: "Rudder Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	16: {
		Name: "User 5",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	17: {
		Name: "User 6",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	18: {
		Name: "User 7",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	19: {
		Name: "User 8",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	20: {
		Name: "User 9",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	21: {
		Name: "User 10",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	22: {
		Name: "User 11",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	23: {
		Name: "User 12",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	24: {
		Name: "User 13",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	25: {
		Name: "User 14",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	26: {
		Name: "User 15",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	27: {
		Name: "User 16",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	28: {
		Name: "Outside Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	29: {
		Name: "Outside Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	30: {
		Name: "Water Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	31: {
		Name: "Water Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	50: {
		Name: "Tacking Performance",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "%",
		BitLength: 0,
		BitLookupName: "",
		},
	52: {
		Name: "Attitude Roll",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	53: {
		Name: "Optimum Wind Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	56: {
		Name: "User 1",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	57: {
		Name: "User 2",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	58: {
		Name: "User 3",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	59: {
		Name: "User 4",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	60: {
		Name: "Roll Rate",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	64: {
		Name: "Forestay",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	65: {
		Name: "Water Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	77: {
		Name: "Wind Speed Apparent",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	79: {
		Name: "Wind Speed Apparent",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	80: {
		Name: "Average True Wind Direction",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	81: {
		Name: "Wind Angle Apparent",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	83: {
		Name: "Target TWA",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	85: {
		Name: "Wind Speed True",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	86: {
		Name: "Wind Speed True",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	89: {
		Name: "Wind Angle True",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	100: {
		Name: "Unknown",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	102: {
		Name: "Keel Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	103: {
		Name: "Canard Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	104: {
		Name: "Keel Trim Tab Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	105: {
		Name: "Course",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	109: {
		Name: "Wind Direction",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	111: {
		Name: "Next Leg AWA",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	113: {
		Name: "Next Leg AWS",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	117: {
		Name: "Race Timer",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	124: {
		Name: "Polar Performance",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "%",
		BitLength: 0,
		BitLookupName: "",
		},
	125: {
		Name: "Target Boat Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	126: {
		Name: "Polar Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	127: {
		Name: "VMG to Wind",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	129: {
		Name: "DR Distance",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	130: {
		Name: "Leeway Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	131: {
		Name: "Current Drift",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	132: {
		Name: "Current Set",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	135: {
		Name: "Barometric Pressure",
		CanboatType: "NUMBER",
		Resolution: 100,
		Unit: "Pa",
		BitLength: 0,
		BitLookupName: "",
		},
	152: {
		Name: "Distance to Start Line",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	154: {
		Name: "Heading on Opposite Tack",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	155: {
		Name: "Attitude Pitch",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	156: {
		Name: "Mast Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	157: {
		Name: "Wind Angle to Mast",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	158: {
		Name: "Pitch Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	163: {
		Name: "Daggerboard Position",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	164: {
		Name: "Boom Position",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	185: {
		Name: "MOB DR Bearing",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	186: {
		Name: "MOB DR Range",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	194: {
		Name: "Depth",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	195: {
		Name: "Depth",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	199: {
		Name: "Aft Depth",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	205: {
		Name: "Odometer",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	207: {
		Name: "Trip Distance",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	211: {
		Name: "DR Bearing",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	233: {
		Name: "Course Over Ground",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	235: {
		Name: "Speed Over Ground",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	239: {
		Name: "Remote 0",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	240: {
		Name: "Remote 1",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	241: {
		Name: "Remote 2",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	242: {
		Name: "Remote 3",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	243: {
		Name: "Remote 4",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	244: {
		Name: "Remote 5",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	245: {
		Name: "Remote 6",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	246: {
		Name: "Remote 7",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	247: {
		Name: "Remote 8",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	248: {
		Name: "Remote 9",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	256: {
		Name: "Layline Time",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	258: {
		Name: "Layline Distance",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	259: {
		Name: "Layline Distance",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	260: {
		Name: "Sailing Time to Waypoint",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	261: {
		Name: "Sailing Distance to Waypoint",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	262: {
		Name: "Sailing ETA",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	265: {
		Name: "Trip Time",
		CanboatType: "TIME",
		Resolution: 0.001,
		Unit: "s",
		BitLength: 0,
		BitLookupName: "",
		},
	270: {
		Name: "Bow Latitude",
		CanboatType: "NUMBER",
		Resolution: 1e-07,
		Unit: "deg",
		BitLength: 0,
		BitLookupName: "",
		},
	271: {
		Name: "Bow Longitude",
		CanboatType: "NUMBER",
		Resolution: 1e-07,
		Unit: "deg",
		BitLength: 0,
		BitLookupName: "",
		},
	272: {
		Name: "Start Line Bearing",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	273: {
		Name: "Start Line Bias",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	274: {
		Name: "Distance to Start Line Port",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	275: {
		Name: "Distance to Start Line Starboard",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	280: {
		Name: "Bias Advantage in Boat Lengths",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	281: {
		Name: "Distance to Start Line in Boat Lengths",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	282: {
		Name: "Backstay",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	283: {
		Name: "Boom Vang",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	284: {
		Name: "Chain Length",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	285: {
		Name: "VMG Performance",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "%",
		BitLength: 0,
		BitLookupName: "",
		},
	286: {
		Name: "Inner Forestay Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	287: {
		Name: "Inner Forestay Halyard Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	288: {
		Name: "Jib Furl",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	289: {
		Name: "Jib Halyard Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	290: {
		Name: "Outhaul Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	291: {
		Name: "Plow Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	292: {
		Name: "Cunningham",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	293: {
		Name: "Jacuzzi Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	294: {
		Name: "Pool Temperature",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "K",
		BitLength: 0,
		BitLookupName: "",
		},
	296: {
		Name: "Keel Draught",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	297: {
		Name: "Boom Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	298: {
		Name: "Code Zero Load",
		CanboatType: "NUMBER",
		Resolution: 0.001,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	301: {
		Name: "Distance Behind Start Line",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	302: {
		Name: "Distance Behind Start Line in Boat Lengths",
		CanboatType: "NUMBER",
		Resolution: 0.1,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	305: {
		Name: "Bias Advantage",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m",
		BitLength: 0,
		BitLookupName: "",
		},
	306: {
		Name: "Opposite Tack COG",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	307: {
		Name: "Opposite Tack Target Heading",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	308: {
		Name: "Mast Rake",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	309: {
		Name: "Next Leg Bearing",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	310: {
		Name: "Next Leg Target Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	311: {
		Name: "Ground Wind Direction",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	312: {
		Name: "Ground Wind Speed",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "m/s",
		BitLength: 0,
		BitLookupName: "",
		},
	313: {
		Name: "Mast Cant Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	314: {
		Name: "Rudder Toe In",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	315: {
		Name: "Daggerboard Port",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	316: {
		Name: "Daggerboard Starboard",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	317: {
		Name: "User 17",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	318: {
		Name: "User 18",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	319: {
		Name: "User 19",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	320: {
		Name: "User 20",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	321: {
		Name: "User 21",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	322: {
		Name: "User 22",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	323: {
		Name: "User 23",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	324: {
		Name: "User 24",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	325: {
		Name: "User 25",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	326: {
		Name: "User 26",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	327: {
		Name: "User 27",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	328: {
		Name: "User 28",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	329: {
		Name: "User 29",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	330: {
		Name: "User 30",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	331: {
		Name: "User 31",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	332: {
		Name: "User 32",
		CanboatType: "NUMBER",
		Resolution: 0.01,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	336: {
		Name: "Average True Wind Direction",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	337: {
		Name: "Wind Phase",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	338: {
		Name: "Wind Lift",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	380: {
		Name: "Active Perf Mode",
		CanboatType: "NUMBER",
		Resolution: 0,
		Unit: "",
		BitLength: 0,
		BitLookupName: "",
		},
	381: {
		Name: "Gust Bear Away",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	382: {
		Name: "TWS Bear Away",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	383: {
		Name: "Heel Compensation",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	384: {
		Name: "Pilot Net Course",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	385: {
		Name: "Pilot Target Wind Angle",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	386: {
		Name: "Pilot Weather Helm",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	387: {
		Name: "Pilot Mean Heel",
		CanboatType: "NUMBER",
		Resolution: 0.0001,
		Unit: "rad",
		BitLength: 0,
		BitLookupName: "",
		},
	 
}


type StationStatusConst uint16
const (
	StationInUse	StationStatusConst = 0
	LowSNR	StationStatusConst = 1
	CycleError	StationStatusConst = 2
	Blink	StationStatusConst = 3
)

func (e StationStatusConst) GoString() string {return e.String() }
func (e StationStatusConst) String() string {
	switch e {
		case 0:
			return "Station in use"
		case 1:
			return "Low SNR"
		case 2:
			return "Cycle Error"
		case 3:
			return "Blink"
	default:
		return fmt.Sprintf("%s(%d)", "StationStatusConst", int(e))
	}
}

type EngineStatus1Const uint16
const (
	CheckEngine	EngineStatus1Const = 0
	OverTemperature	EngineStatus1Const = 1
	LowOilPressure	EngineStatus1Const = 2
	LowOilLevel	EngineStatus1Const = 3
	LowFuelPressure	EngineStatus1Const = 4
	LowSystemVoltage	EngineStatus1Const = 5
	LowCoolantLevel	EngineStatus1Const = 6
	WaterFlow	EngineStatus1Const = 7
	WaterInFuel	EngineStatus1Const = 8
	ChargeIndicator	EngineStatus1Const = 9
	PreheatIndicator	EngineStatus1Const = 10
	HighBoostPressure	EngineStatus1Const = 11
	RevLimitExceeded	EngineStatus1Const = 12
	EGRSystem	EngineStatus1Const = 13
	ThrottlePositionSensor	EngineStatus1Const = 14
	EmergencyStop	EngineStatus1Const = 15
)

func (e EngineStatus1Const) GoString() string {return e.String() }
func (e EngineStatus1Const) String() string {
	switch e {
		case 0:
			return "Check Engine"
		case 1:
			return "Over Temperature"
		case 2:
			return "Low Oil Pressure"
		case 3:
			return "Low Oil Level"
		case 4:
			return "Low Fuel Pressure"
		case 5:
			return "Low System Voltage"
		case 6:
			return "Low Coolant Level"
		case 7:
			return "Water Flow"
		case 8:
			return "Water In Fuel"
		case 9:
			return "Charge Indicator"
		case 10:
			return "Preheat Indicator"
		case 11:
			return "High Boost Pressure"
		case 12:
			return "Rev Limit Exceeded"
		case 13:
			return "EGR System"
		case 14:
			return "Throttle Position Sensor"
		case 15:
			return "Emergency Stop"
	default:
		return fmt.Sprintf("%s(%d)", "EngineStatus1Const", int(e))
	}
}

type EngineStatus2Const uint16
const (
	WarningLevel1	EngineStatus2Const = 0
	WarningLevel2	EngineStatus2Const = 1
	PowerReduction	EngineStatus2Const = 2
	MaintenanceNeeded	EngineStatus2Const = 3
	EngineCommError	EngineStatus2Const = 4
	SubOrSecondaryThrottle	EngineStatus2Const = 5
	NeutralStartProtect	EngineStatus2Const = 6
	EngineShuttingDown	EngineStatus2Const = 7
)

func (e EngineStatus2Const) GoString() string {return e.String() }
func (e EngineStatus2Const) String() string {
	switch e {
		case 0:
			return "Warning Level 1"
		case 1:
			return "Warning Level 2"
		case 2:
			return "Power Reduction"
		case 3:
			return "Maintenance Needed"
		case 4:
			return "Engine Comm Error"
		case 5:
			return "Sub or Secondary Throttle"
		case 6:
			return "Neutral Start Protect"
		case 7:
			return "Engine Shutting Down"
	default:
		return fmt.Sprintf("%s(%d)", "EngineStatus2Const", int(e))
	}
}

type EntertainmentPlayStatusBitfieldConst uint16
const (
	Play_3	EntertainmentPlayStatusBitfieldConst = 0
	Pause_3	EntertainmentPlayStatusBitfieldConst = 1
	Stop_2	EntertainmentPlayStatusBitfieldConst = 2
	FF1x_2	EntertainmentPlayStatusBitfieldConst = 3
	FF2x_2	EntertainmentPlayStatusBitfieldConst = 4
	FF3x_2	EntertainmentPlayStatusBitfieldConst = 5
	FF4x_2	EntertainmentPlayStatusBitfieldConst = 6
	RW1x_2	EntertainmentPlayStatusBitfieldConst = 7
	RW2x_2	EntertainmentPlayStatusBitfieldConst = 8
	RW3x_2	EntertainmentPlayStatusBitfieldConst = 9
	RW4x_2	EntertainmentPlayStatusBitfieldConst = 10
	SkipAhead_2	EntertainmentPlayStatusBitfieldConst = 11
	SkipBack_2	EntertainmentPlayStatusBitfieldConst = 12
	JogAhead_2	EntertainmentPlayStatusBitfieldConst = 13
	JogBack_2	EntertainmentPlayStatusBitfieldConst = 14
	SeekUp_2	EntertainmentPlayStatusBitfieldConst = 15
	SeekDown_2	EntertainmentPlayStatusBitfieldConst = 16
	ScanUp_2	EntertainmentPlayStatusBitfieldConst = 17
	ScanDown_2	EntertainmentPlayStatusBitfieldConst = 18
	TuneUp_2	EntertainmentPlayStatusBitfieldConst = 19
	TuneDown_2	EntertainmentPlayStatusBitfieldConst = 20
	SlowMotion75x_2	EntertainmentPlayStatusBitfieldConst = 21
	SlowMotion5x_2	EntertainmentPlayStatusBitfieldConst = 22
	SlowMotion25x_2	EntertainmentPlayStatusBitfieldConst = 23
	SlowMotion125x_2	EntertainmentPlayStatusBitfieldConst = 24
	SourceRenaming	EntertainmentPlayStatusBitfieldConst = 25
)

func (e EntertainmentPlayStatusBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentPlayStatusBitfieldConst) String() string {
	switch e {
		case 0:
			return "Play"
		case 1:
			return "Pause"
		case 2:
			return "Stop"
		case 3:
			return "FF 1x"
		case 4:
			return "FF 2x"
		case 5:
			return "FF 3x"
		case 6:
			return "FF 4x"
		case 7:
			return "RW 1x"
		case 8:
			return "RW 2x"
		case 9:
			return "RW 3x"
		case 10:
			return "RW 4x"
		case 11:
			return "Skip ahead"
		case 12:
			return "Skip back"
		case 13:
			return "Jog ahead"
		case 14:
			return "Jog back"
		case 15:
			return "Seek up"
		case 16:
			return "Seek down"
		case 17:
			return "Scan up"
		case 18:
			return "Scan down"
		case 19:
			return "Tune up"
		case 20:
			return "Tune down"
		case 21:
			return "Slow motion .75x"
		case 22:
			return "Slow motion .5x"
		case 23:
			return "Slow motion .25x"
		case 24:
			return "Slow motion .125x"
		case 25:
			return "Source renaming"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentPlayStatusBitfieldConst", int(e))
	}
}

type EntertainmentGroupBitfieldConst uint16
const (
	File_4	EntertainmentGroupBitfieldConst = 0
	PlaylistName_3	EntertainmentGroupBitfieldConst = 1
	GenreName_3	EntertainmentGroupBitfieldConst = 2
	AlbumName_3	EntertainmentGroupBitfieldConst = 3
	ArtistName_3	EntertainmentGroupBitfieldConst = 4
	TrackName_3	EntertainmentGroupBitfieldConst = 5
	StationName_3	EntertainmentGroupBitfieldConst = 6
	StationNumber_3	EntertainmentGroupBitfieldConst = 7
	FavouriteNumber_3	EntertainmentGroupBitfieldConst = 8
	PlayQueue_4	EntertainmentGroupBitfieldConst = 9
	ContentInfo_3	EntertainmentGroupBitfieldConst = 10
)

func (e EntertainmentGroupBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentGroupBitfieldConst) String() string {
	switch e {
		case 0:
			return "File"
		case 1:
			return "Playlist Name"
		case 2:
			return "Genre Name"
		case 3:
			return "Album Name"
		case 4:
			return "Artist Name"
		case 5:
			return "Track Name"
		case 6:
			return "Station Name"
		case 7:
			return "Station Number"
		case 8:
			return "Favourite Number"
		case 9:
			return "Play Queue"
		case 10:
			return "Content Info"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentGroupBitfieldConst", int(e))
	}
}

type ThrusterControlEventsConst uint16
const (
	AnotherDeviceControllingThruster	ThrusterControlEventsConst = 0
	BoatSpeedTooFastToSafelyUseThruster	ThrusterControlEventsConst = 1
)

func (e ThrusterControlEventsConst) GoString() string {return e.String() }
func (e ThrusterControlEventsConst) String() string {
	switch e {
		case 0:
			return "Another device controlling thruster"
		case 1:
			return "Boat speed too fast to safely use thruster"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterControlEventsConst", int(e))
	}
}

type ThrusterMotorEventsConst uint16
const (
	MotorOverTemperatureCutout	ThrusterMotorEventsConst = 0
	MotorOverCurrentCutout	ThrusterMotorEventsConst = 1
	LowOilLevelWarning	ThrusterMotorEventsConst = 2
	OilOverTemperatureWarning	ThrusterMotorEventsConst = 3
	ControllerUnderVoltageCutout	ThrusterMotorEventsConst = 4
	ManufacturerDefined	ThrusterMotorEventsConst = 5
)

func (e ThrusterMotorEventsConst) GoString() string {return e.String() }
func (e ThrusterMotorEventsConst) String() string {
	switch e {
		case 0:
			return "Motor over temperature cutout"
		case 1:
			return "Motor over current cutout"
		case 2:
			return "Low oil level warning"
		case 3:
			return "Oil over temperature warning"
		case 4:
			return "Controller under voltage cutout"
		case 5:
			return "Manufacturer defined"
	default:
		return fmt.Sprintf("%s(%d)", "ThrusterMotorEventsConst", int(e))
	}
}

type WindlassControlConst uint16
const (
	AnotherDeviceControllingWindlass	WindlassControlConst = 0
)

func (e WindlassControlConst) GoString() string {return e.String() }
func (e WindlassControlConst) String() string {
	switch e {
		case 0:
			return "Another device controlling windlass"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassControlConst", int(e))
	}
}

type WindlassOperationConst uint16
const (
	SystemError	WindlassOperationConst = 0
	SensorError	WindlassOperationConst = 1
	NoWindlassMotionDetected	WindlassOperationConst = 2
	RetrievalDockingDistanceReached	WindlassOperationConst = 3
	EndOfRodeReached	WindlassOperationConst = 4
)

func (e WindlassOperationConst) GoString() string {return e.String() }
func (e WindlassOperationConst) String() string {
	switch e {
		case 0:
			return "System error"
		case 1:
			return "Sensor error"
		case 2:
			return "No windlass motion detected"
		case 3:
			return "Retrieval docking distance reached"
		case 4:
			return "End of rode reached"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassOperationConst", int(e))
	}
}

type WindlassMonitoringConst uint16
const (
	ControllerUnderVoltageCutOut	WindlassMonitoringConst = 0
	ControllerOverCurrentCutOut	WindlassMonitoringConst = 1
	ControllerOverTemperatureCutOut	WindlassMonitoringConst = 2
	ManufacturerDefined_2	WindlassMonitoringConst = 3
)

func (e WindlassMonitoringConst) GoString() string {return e.String() }
func (e WindlassMonitoringConst) String() string {
	switch e {
		case 0:
			return "Controller under voltage cut-out"
		case 1:
			return "Controller over current cut-out"
		case 2:
			return "Controller over temperature cut-out"
		case 3:
			return "Manufacturer defined"
	default:
		return fmt.Sprintf("%s(%d)", "WindlassMonitoringConst", int(e))
	}
}

type SimnetApModeBitfieldConst uint16
const (
	Standby_5	SimnetApModeBitfieldConst = 3
	Heading_2	SimnetApModeBitfieldConst = 4
	Nav_2	SimnetApModeBitfieldConst = 6
	NoDrift_2	SimnetApModeBitfieldConst = 8
	Wind_4	SimnetApModeBitfieldConst = 10
)

func (e SimnetApModeBitfieldConst) GoString() string {return e.String() }
func (e SimnetApModeBitfieldConst) String() string {
	switch e {
		case 3:
			return "Standby"
		case 4:
			return "Heading"
		case 6:
			return "Nav"
		case 8:
			return "No Drift"
		case 10:
			return "Wind"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetApModeBitfieldConst", int(e))
	}
}

type SimnetAlertBitfieldConst uint16
const (
	NoGPSFix	SimnetAlertBitfieldConst = 0
	NoActiveAutopilotControlUnit	SimnetAlertBitfieldConst = 2
	NoAutopilotComputer	SimnetAlertBitfieldConst = 4
	APClutchOverload	SimnetAlertBitfieldConst = 6
	APClutchDisengaged	SimnetAlertBitfieldConst = 8
	RudderControllerFault	SimnetAlertBitfieldConst = 10
	NoRudderResponse	SimnetAlertBitfieldConst = 12
	RudderDriveOverload	SimnetAlertBitfieldConst = 14
	HighDriveSupply	SimnetAlertBitfieldConst = 16
	LowDriveSupply	SimnetAlertBitfieldConst = 18
	MemoryFail	SimnetAlertBitfieldConst = 20
	APPositionDataMissing	SimnetAlertBitfieldConst = 22
	APSpeedDataMissing	SimnetAlertBitfieldConst = 24
	APDepthDataMissing	SimnetAlertBitfieldConst = 26
	APHeadingDataMissing	SimnetAlertBitfieldConst = 28
	APNavDataMissing	SimnetAlertBitfieldConst = 30
	APRudderDataMissing	SimnetAlertBitfieldConst = 32
	APWindDataMissing	SimnetAlertBitfieldConst = 34
	APOffCourse	SimnetAlertBitfieldConst = 36
	HighDriveTemperature	SimnetAlertBitfieldConst = 38
	DriveInhibit	SimnetAlertBitfieldConst = 40
	RudderLimit	SimnetAlertBitfieldConst = 42
	DriveComputerMissing	SimnetAlertBitfieldConst = 44
	DriveReadyMissing	SimnetAlertBitfieldConst = 46
	EVCComError	SimnetAlertBitfieldConst = 48
	EVCOverride	SimnetAlertBitfieldConst = 50
	LowCANBusVoltage	SimnetAlertBitfieldConst = 52
	CANBusSupplyOverload	SimnetAlertBitfieldConst = 54
	WindSensorBatteryLow	SimnetAlertBitfieldConst = 56
)

func (e SimnetAlertBitfieldConst) GoString() string {return e.String() }
func (e SimnetAlertBitfieldConst) String() string {
	switch e {
		case 0:
			return "No GPS fix"
		case 2:
			return "No active autopilot control unit"
		case 4:
			return "No autopilot computer"
		case 6:
			return "AP clutch overload"
		case 8:
			return "AP clutch disengaged"
		case 10:
			return "Rudder controller fault"
		case 12:
			return "No rudder response"
		case 14:
			return "Rudder drive overload"
		case 16:
			return "High drive supply"
		case 18:
			return "Low drive supply"
		case 20:
			return "Memory fail"
		case 22:
			return "AP position data missing"
		case 24:
			return "AP speed data missing"
		case 26:
			return "AP depth data missing"
		case 28:
			return "AP heading data missing"
		case 30:
			return "AP nav data missing"
		case 32:
			return "AP rudder data missing"
		case 34:
			return "AP wind data missing"
		case 36:
			return "AP off course"
		case 38:
			return "High drive temperature"
		case 40:
			return "Drive inhibit"
		case 42:
			return "Rudder limit"
		case 44:
			return "Drive computer missing"
		case 46:
			return "Drive ready missing"
		case 48:
			return "EVC com error"
		case 50:
			return "EVC override"
		case 52:
			return "Low CAN bus voltage"
		case 54:
			return "CAN bus supply overload"
		case 56:
			return "Wind sensor battery low"
	default:
		return fmt.Sprintf("%s(%d)", "SimnetAlertBitfieldConst", int(e))
	}
}

type EntertainmentRepeatBitfieldConst uint16
const (
	Song	EntertainmentRepeatBitfieldConst = 0
	PlayQueue_5	EntertainmentRepeatBitfieldConst = 1
)

func (e EntertainmentRepeatBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentRepeatBitfieldConst) String() string {
	switch e {
		case 0:
			return "Song"
		case 1:
			return "Play queue"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentRepeatBitfieldConst", int(e))
	}
}

type EntertainmentShuffleBitfieldConst uint16
const (
	PlayQueue_6	EntertainmentShuffleBitfieldConst = 0
	All_3	EntertainmentShuffleBitfieldConst = 1
)

func (e EntertainmentShuffleBitfieldConst) GoString() string {return e.String() }
func (e EntertainmentShuffleBitfieldConst) String() string {
	switch e {
		case 0:
			return "Play queue"
		case 1:
			return "All"
	default:
		return fmt.Sprintf("%s(%d)", "EntertainmentShuffleBitfieldConst", int(e))
	}
}

var unseenList = []PgnInfo{
	{
		PGN: 127490,
		Description: "Electric Drive Status, Dynamic",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 127491,
		Description: "Electric Energy Storage Status, Dynamic",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 127494,
		Description: "Electric Drive Information",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 127495,
		Description: "Electric Energy Storage Information",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 127510,
		Description: "Charger Configuration Status",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 128001,
		Description: "Vessel Acceleration",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128002,
		Description: "Electric Drive Status, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128003,
		Description: "Electric Energy Storage Status, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128520,
		Description: "Tracked Target Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 128538,
		Description: "Elevator Car Status",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 128768,
		Description: "Elevator Motor Control",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128769,
		Description: "Elevator Deck Push Button",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 128780,
		Description: "Linear Actuator Control/Status",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129027,
		Description: "Position Delta, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129028,
		Description: "Altitude Delta, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129040,
		Description: "AIS Class B Extended Position Report",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129291,
		Description: "Set & Drift, Rapid Update",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129301,
		Description: "Navigation - Route / Time to+from Mark",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129302,
		Description: "Bearing and Distance between two Marks",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129538,
		Description: "GNSS Control Status",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129542,
		Description: "GNSS Pseudorange Noise Statistics",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129545,
		Description: "GNSS RAIM Output",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129546,
		Description: "GNSS RAIM Settings",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 129547,
		Description: "GNSS Pseudorange Error Statistics",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129549,
		Description: "DGNSS Corrections",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129550,
		Description: "GNSS Differential Correction Receiver Interface",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129551,
		Description: "GNSS Differential Correction Receiver Signal",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129556,
		Description: "GLONASS Almanac Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129792,
		Description: "AIS DGNSS Broadcast Binary Message",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129798,
		Description: "AIS SAR Aircraft Position Report",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129804,
		Description: "AIS Assignment Mode Command",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129807,
		Description: "AIS Class B Group Assignment",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129808,
		Description: "DSC Distress Call Information",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 129808,
		Description: "DSC Call Information",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130052,
		Description: "Loran-C TD Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130053,
		Description: "Loran-C Range Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130054,
		Description: "Loran-C Signal Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130060,
		Description: "Label",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130061,
		Description: "Channel Source Configuration",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130064,
		Description: "Route and WP Service - Database List",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130065,
		Description: "Route and WP Service - Route List",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130066,
		Description: "Route and WP Service - Route/WP-List Attributes",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130067,
		Description: "Route and WP Service - Route - WP Name & Position",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130068,
		Description: "Route and WP Service - Route - WP Name",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130069,
		Description: "Route and WP Service - XTE Limit & Navigation Method",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130070,
		Description: "Route and WP Service - WP Comment",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130071,
		Description: "Route and WP Service - Route Comment",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130072,
		Description: "Route and WP Service - Database Comment",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130073,
		Description: "Route and WP Service - Radius of Turn",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130074,
		Description: "Route and WP Service - WP List - WP Name & Position",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130321,
		Description: "Salinity Station Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130322,
		Description: "Current Station Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130323,
		Description: "Meteorological Station Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130324,
		Description: "Moored Buoy Station Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130330,
		Description: "Lighting System Settings",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130560,
		Description: "Payload Mass",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130561,
		Description: "Lighting Zone",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130562,
		Description: "Lighting Scene",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130563,
		Description: "Lighting Device",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130564,
		Description: "Lighting Device Enumeration",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130565,
		Description: "Lighting Color Sequence",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130566,
		Description: "Lighting Program",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130569,
		Description: "Current Status and File",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130570,
		Description: "Library Data File",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130571,
		Description: "Library Data Group",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130572,
		Description: "Library Data Search",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130573,
		Description: "Supported Source Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130574,
		Description: "Supported Zone Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130576,
		Description: "Small Craft Status",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130577,
		Description: "Direction Data",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130579,
		Description: "System Configuration",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130580,
		Description: "System Configuration (deprecated)",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130581,
		Description: "Zone Configuration (deprecated)",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130582,
		Description: "Zone Volume",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130583,
		Description: "Available Audio EQ presets",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130584,
		Description: "Available Bluetooth addresses",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130585,
		Description: "Bluetooth source status",
		Fast: false,
		ManId: 0,
	},
	{
		PGN: 130586,
		Description: "Zone Configuration",
		Fast: true,
		ManId: 0,
	},
	{
		PGN: 130816,
		Description: "SonicHub: Init #2",
		Fast: true,
		ManId: 275,
	},
	{
		PGN: 130816,
		Description: "SonicHub: AM Radio",
		Fast: true,
		ManId: 275,
	},
	{
		PGN: 130816,
		Description: "SonicHub: Init #3",
		Fast: true,
		ManId: 275,
	},
	{
		PGN: 130819,
		Description: "Simnet: Request Reprogram",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130820,
		Description: "Simnet: Reprogram Status",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130820,
		Description: "Fusion: Tone",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: Volume",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: Power State",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Channel",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Title",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Artist",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130820,
		Description: "Fusion: SiriusXM Genre",
		Fast: true,
		ManId: 419,
	},
	{
		PGN: 130827,
		Description: "Lowrance: unknown",
		Fast: true,
		ManId: 140,
	},
	{
		PGN: 130828,
		Description: "Simnet: Set Serial Number",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130831,
		Description: "Suzuki: Engine and Storage Device Config",
		Fast: true,
		ManId: 586,
	},
	{
		PGN: 130832,
		Description: "Simnet: Fuel Used - High Resolution",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130834,
		Description: "Simnet: Engine and Tank Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130835,
		Description: "Simnet: Set Engine and Tank Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130837,
		Description: "Simnet: Fuel Flow Turbine Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130838,
		Description: "Simnet: Fluid Level Warning",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130839,
		Description: "Simnet: Pressure Sensor Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130840,
		Description: "Simnet: Data User Group Configuration",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130842,
		Description: "Simnet: AIS Class B static data (msg 24 Part A)",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130843,
		Description: "Simnet: Sonar Status, Frequency and DSP Voltage",
		Fast: true,
		ManId: 1857,
	},
	{
		PGN: 130847,
		Description: "SeaTalk: Node Statistics",
		Fast: true,
		ManId: 1851,
	},
	{
		PGN: 130880,
		Description: "Airmar: Additional Weather Data",
		Fast: true,
		ManId: 135,
	},
	{
		PGN: 130881,
		Description: "Airmar: Heater Control",
		Fast: true,
		ManId: 135,
	},
	{
		PGN: 130944,
		Description: "Airmar: POST",
		Fast: true,
		ManId: 135,
	},
}
var PgnList = pgnList		
var pgnList = []PgnInfo{
	{
		Id: "IsoAcknowledgement",
		PGN: 59392,
		Description: "ISO Acknowledgement",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoAcknowledgement,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Control",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Group Function",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 24,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoRequest",
		PGN: 59904,
		Description: "ISO Request",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoRequest,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoTransportProtocolDataTransfer",
		PGN: 60160,
		Description: "ISO Transport Protocol, Data Transfer",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolDataTransfer,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Data",
			BitLength: 56,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoTransportProtocolConnectionManagementRequestToSend",
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - Request To Send",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementRequestToSend,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Group Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Message size",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Packets",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Packets reply",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoTransportProtocolConnectionManagementClearToSend",
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - Clear To Send",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementClearToSend,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Group Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Max packets",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Next SID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoTransportProtocolConnectionManagementEndOfMessage",
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - End Of Message",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementEndOfMessage,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Group Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Total message size",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Total number of frames received",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoTransportProtocolConnectionManagementBroadcastAnnounce",
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - Broadcast Announce",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementBroadcastAnnounce,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Group Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Message size",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Packets",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoTransportProtocolConnectionManagementAbort",
		PGN: 60416,
		Description: "ISO Transport Protocol, Connection Management - Abort",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoTransportProtocolConnectionManagementAbort,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Group Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reason",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 24,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoAddressClaim",
		PGN: 60928,
		Description: "ISO Address Claim",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoAddressClaim,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Unique Number",
			BitLength: 21,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 21,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Device Instance Lower",
			BitLength: 3,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Device Instance Upper",
			BitLength: 5,
			BitOffset: 35,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Device Function",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "INDIRECT_LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Spare",
			BitLength: 1,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		7: { 
			Name: "Device Class",
			BitLength: 7,
			BitOffset: 49,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "System Instance",
			BitLength: 4,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		9: { 
			Name: "Industry Group",
			BitLength: 3,
			BitOffset: 60,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Arbitrary address capable",
			BitLength: 1,
			BitOffset: 63,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "Bus1PhaseCBasicAcQuantities",
		PGN: 65001,
		Description: "Bus #1 Phase C Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBus1PhaseCBasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "Bus1PhaseBBasicAcQuantities",
		PGN: 65002,
		Description: "Bus #1 Phase B Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBus1PhaseBBasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "Bus1PhaseABasicAcQuantities",
		PGN: 65003,
		Description: "Bus #1 Phase A Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBus1PhaseABasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseCAcReactivePower",
		PGN: 65006,
		Description: "Utility Phase C AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseCAcReactivePower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Reactive Power",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Power factor",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:6.10352e-05,
			},
		3: { 
			Name: "Power Factor Lagging",
			BitLength: 2,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 30,
			BitOffset: 34,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseCAcPower",
		PGN: 65007,
		Description: "Utility Phase C AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseCAcPower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Real Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Apparent Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseCBasicAcQuantities",
		PGN: 65008,
		Description: "Utility Phase C Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseCBasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseBAcReactivePower",
		PGN: 65009,
		Description: "Utility Phase B AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseBAcReactivePower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Reactive Power",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Power factor",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:6.10352e-05,
			},
		3: { 
			Name: "Power Factor Lagging",
			BitLength: 2,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 30,
			BitOffset: 34,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseBAcPower",
		PGN: 65010,
		Description: "Utility Phase B AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseBAcPower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Real Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Apparent Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseBBasicAcQuantities",
		PGN: 65011,
		Description: "Utility Phase B Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseBBasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseAAcReactivePower",
		PGN: 65012,
		Description: "Utility Phase A AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseAAcReactivePower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Reactive Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Power factor",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:6.10352e-05,
			},
		3: { 
			Name: "Power Factor Lagging",
			BitLength: 2,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 14,
			BitOffset: 50,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseAAcPower",
		PGN: 65013,
		Description: "Utility Phase A AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseAAcPower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Real Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Apparent Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityPhaseABasicAcQuantities",
		PGN: 65014,
		Description: "Utility Phase A Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityPhaseABasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityTotalAcReactivePower",
		PGN: 65015,
		Description: "Utility Total AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityTotalAcReactivePower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Reactive Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Power factor",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:6.10352e-05,
			},
		3: { 
			Name: "Power Factor Lagging",
			BitLength: 2,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 14,
			BitOffset: 50,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityTotalAcPower",
		PGN: 65016,
		Description: "Utility Total AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityTotalAcPower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Real Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Apparent Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "UtilityAverageBasicAcQuantities",
		PGN: 65017,
		Description: "Utility Average Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeUtilityAverageBasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseCAcReactivePower",
		PGN: 65019,
		Description: "Generator Phase C AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseCAcReactivePower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Reactive Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Power factor",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:6.10352e-05,
			},
		3: { 
			Name: "Power Factor Lagging",
			BitLength: 2,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 14,
			BitOffset: 50,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseCAcPower",
		PGN: 65020,
		Description: "Generator Phase C AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseCAcPower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Real Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Apparent Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseCBasicAcQuantities",
		PGN: 65021,
		Description: "Generator Phase C Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseCBasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseBAcReactivePower",
		PGN: 65022,
		Description: "Generator Phase B AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseBAcReactivePower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Reactive Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Power factor",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:6.10352e-05,
			},
		3: { 
			Name: "Power Factor Lagging",
			BitLength: 2,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 14,
			BitOffset: 50,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseBAcPower",
		PGN: 65023,
		Description: "Generator Phase B AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseBAcPower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Real Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Apparent Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseBBasicAcQuantities",
		PGN: 65024,
		Description: "Generator Phase B Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseBBasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseAAcReactivePower",
		PGN: 65025,
		Description: "Generator Phase A AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseAAcReactivePower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Reactive Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Power factor",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:6.10352e-05,
			},
		3: { 
			Name: "Power Factor Lagging",
			BitLength: 2,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 14,
			BitOffset: 50,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseAAcPower",
		PGN: 65026,
		Description: "Generator Phase A AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseAAcPower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Real Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Apparent Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorPhaseABasicAcQuantities",
		PGN: 65027,
		Description: "Generator Phase A Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorPhaseABasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorTotalAcReactivePower",
		PGN: 65028,
		Description: "Generator Total AC Reactive Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorTotalAcReactivePower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Reactive Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Power factor",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:6.10352e-05,
			},
		3: { 
			Name: "Power Factor Lagging",
			BitLength: 2,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 14,
			BitOffset: 50,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorTotalAcPower",
		PGN: 65029,
		Description: "Generator Total AC Power",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorTotalAcPower,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Real Power",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Apparent Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "GeneratorAverageBasicAcQuantities",
		PGN: 65030,
		Description: "Generator Average Basic AC Quantities",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGeneratorAverageBasicAcQuantities,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Line-Line AC RMS Voltage",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Line-Neutral AC RMS Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC Frequency",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0078125,
			},
		4: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "IsoCommandedAddress",
		PGN: 65240,
		Description: "ISO Commanded Address",
		Fast: false,
		ManId: 0,
		Decoder: DecodeIsoCommandedAddress,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Unique Number",
			BitLength: 21,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		2: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 21,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Device Instance Lower",
			BitLength: 3,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Device Instance Upper",
			BitLength: 5,
			BitOffset: 35,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Device Function",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "INDIRECT_LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 1,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Device Class",
			BitLength: 7,
			BitOffset: 49,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "System Instance",
			BitLength: 4,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		9: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 60,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Reserved",
			BitLength: 1,
			BitOffset: 63,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		11: { 
			Name: "New Source Address",
			BitLength: 8,
			BitOffset: 64,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "MaretronProprietaryDcBreakerCurrent",
		PGN: 65284,
		Description: "Maretron: Proprietary DC Breaker Current",
		Fast: false,
		ManId: 137,
		Decoder: DecodeMaretronProprietaryDcBreakerCurrent,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Bank Instance",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Indicator Number",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Breaker Current",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		7: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AirmarBootStateAcknowledgment",
		PGN: 65285,
		Description: "Airmar: Boot State Acknowledgment",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarBootStateAcknowledgment,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Boot State",
			BitLength: 3,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Reserved",
			BitLength: 45,
			BitOffset: 19,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "LowranceTemperature",
		PGN: 65285,
		Description: "Lowrance: Temperature",
		Fast: false,
		ManId: 140,
		Decoder: DecodeLowranceTemperature,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Temperature Source",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Actual Temperature",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		6: { 
			Name: "Reserved",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AirmarBootStateRequest",
		PGN: 65286,
		Description: "Airmar: Boot State Request",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarBootStateRequest,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 48,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AirmarAccessLevel",
		PGN: 65287,
		Description: "Airmar: Access Level",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarAccessLevel,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Format Code",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Access Level",
			BitLength: 3,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 5,
			BitOffset: 27,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Access Seed/Key",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "SimnetDeviceStatus",
		PGN: 65305,
		Description: "Simnet: Device Status",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetDeviceStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Model",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Report",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Status",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Spare",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		},
	},
	{
		Id: "SimnetDeviceStatusRequest",
		PGN: 65305,
		Description: "Simnet: Device Status Request",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetDeviceStatusRequest,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Model",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Report",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Spare",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		},
	},
	{
		Id: "SimnetPilotMode",
		PGN: 65305,
		Description: "Simnet: Pilot Mode",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetPilotMode,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Model",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Report",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Mode",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "BITLOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Spare",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		},
	},
	{
		Id: "SimnetDeviceModeRequest",
		PGN: 65305,
		Description: "Simnet: Device Mode Request",
		Fast: false,
		ManId: 1857,
		Decoder: DecodeSimnetDeviceModeRequest,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Model",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Report",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Spare",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		},
	},
	{
		Id: "SeatalkPilotLockedHeading",
		PGN: 65360,
		Description: "Seatalk: Pilot Locked Heading",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkPilotLockedHeading,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		5: { 
			Name: "Target Heading True",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		6: { 
			Name: "Target Heading Magnetic",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		7: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "SeatalkSilenceAlarm",
		PGN: 65361,
		Description: "Seatalk: Silence Alarm",
		Fast: false,
		ManId: 1851,
		Decoder: DecodeSeatalkSilenceAlarm,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Alarm ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Alarm Group",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AirmarSpeedPulseCount",
		PGN: 65409,
		Description: "Airmar: Speed Pulse Count",
		Fast: false,
		ManId: 135,
		Decoder: DecodeAirmarSpeedPulseCount,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Duration of interval",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.001,
			},
		6: { 
			Name: "Number of pulses received",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "NmeaRequestGroupFunction",
		PGN: 126208,
		Description: "NMEA - Request group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaRequestGroupFunction,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Transmission interval",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.001,
			},
		4: { 
			Name: "Transmission interval offset",
			BitLength: 16,
			BitOffset: 64,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.01,
			},
		5: { 
			Name: "Number of Parameters",
			BitLength: 8,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "NmeaCommandGroupFunction",
		PGN: 126208,
		Description: "NMEA - Command group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaCommandGroupFunction,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Priority",
			BitLength: 4,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 36,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "Number of Parameters",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "NmeaAcknowledgeGroupFunction",
		PGN: 126208,
		Description: "NMEA - Acknowledge group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaAcknowledgeGroupFunction,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "PGN error code",
			BitLength: 4,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Transmission interval/Priority error code",
			BitLength: 4,
			BitOffset: 36,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Number of Parameters",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "NmeaReadFieldsReplyGroupFunction",
		PGN: 126208,
		Description: "NMEA - Read Fields reply group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaReadFieldsReplyGroupFunction,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Unique ID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Number of Selection Pairs",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Number of Parameters",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "NmeaWriteFieldsGroupFunction",
		PGN: 126208,
		Description: "NMEA - Write Fields group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaWriteFieldsGroupFunction,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Unique ID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Number of Selection Pairs",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Number of Parameters",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "NmeaWriteFieldsReplyGroupFunction",
		PGN: 126208,
		Description: "NMEA - Write Fields reply group function",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNmeaWriteFieldsReplyGroupFunction,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "PGN",
			BitLength: 24,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Unique ID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Number of Selection Pairs",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Number of Parameters",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "PgnListTransmitAndReceive",
		PGN: 126464,
		Description: "PGN List (Transmit and Receive)",
		Fast: true,
		ManId: 0,
		Decoder: DecodePgnListTransmitAndReceive,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Function Code",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		},
	},
	{
		Id: "AirmarAttitudeOffset",
		PGN: 126720,
		Description: "Airmar: Attitude Offset",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarAttitudeOffset,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Azimuth offset",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		6: { 
			Name: "Pitch offset",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		7: { 
			Name: "Roll offset",
			BitLength: 16,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		},
	},
	{
		Id: "AirmarSimulateMode",
		PGN: 126720,
		Description: "Airmar: Simulate Mode",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarSimulateMode,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Simulate Mode",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 22,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AirmarCalibrateDepth",
		PGN: 126720,
		Description: "Airmar: Calibrate Depth",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarCalibrateDepth,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Speed of Sound Mode",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AirmarCalibrateSpeed",
		PGN: 126720,
		Description: "Airmar: Calibrate Speed",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarCalibrateSpeed,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Number of pairs of data points",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "AirmarCalibrateTemperature",
		PGN: 126720,
		Description: "Airmar: Calibrate Temperature",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarCalibrateTemperature,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Temperature instance",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Temperature offset",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		},
	},
	{
		Id: "AirmarSpeedFilterNone",
		PGN: 126720,
		Description: "Airmar: Speed Filter None",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarSpeedFilterNone,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Filter type",
			BitLength: 4,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Sample interval",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.01,
			},
		},
	},
	{
		Id: "AirmarSpeedFilterIir",
		PGN: 126720,
		Description: "Airmar: Speed Filter IIR",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarSpeedFilterIir,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Filter type",
			BitLength: 4,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Sample interval",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.01,
			},
		8: { 
			Name: "Filter duration",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.01,
			},
		},
	},
	{
		Id: "AirmarTemperatureFilterNone",
		PGN: 126720,
		Description: "Airmar: Temperature Filter None",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarTemperatureFilterNone,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Filter type",
			BitLength: 4,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Sample interval",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.01,
			},
		},
	},
	{
		Id: "AirmarTemperatureFilterIir",
		PGN: 126720,
		Description: "Airmar: Temperature Filter IIR",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarTemperatureFilterIir,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Filter type",
			BitLength: 4,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Sample interval",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.01,
			},
		8: { 
			Name: "Filter duration",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.01,
			},
		},
	},
	{
		Id: "AirmarNmea2000Options",
		PGN: 126720,
		Description: "Airmar: NMEA 2000 options",
		Fast: true,
		ManId: 135,
		Decoder: DecodeAirmarNmea2000Options,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Transmission Interval",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 22,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "MaretronSlaveResponse",
		PGN: 126720,
		Description: "Maretron: Slave Response",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronSlaveResponse,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Product code",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Software code",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Command",
			BitLength: 8,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Status",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "Alert",
		PGN: 126983,
		Description: "Alert",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlert,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Alert Type",
			BitLength: 4,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Alert Category",
			BitLength: 4,
			BitOffset: 4,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Alert System",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Alert Sub-System",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Alert ID",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Data Source Network ID NAME",
			BitLength: 64,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Data Source Instance",
			BitLength: 8,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Data Source Index-Source",
			BitLength: 8,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		9: { 
			Name: "Alert Occurrence Number",
			BitLength: 8,
			BitOffset: 120,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		10: { 
			Name: "Temporary Silence Status",
			BitLength: 1,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		11: { 
			Name: "Acknowledge Status",
			BitLength: 1,
			BitOffset: 129,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Escalation Status",
			BitLength: 1,
			BitOffset: 130,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		13: { 
			Name: "Temporary Silence Support",
			BitLength: 1,
			BitOffset: 131,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		14: { 
			Name: "Acknowledge Support",
			BitLength: 1,
			BitOffset: 132,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		15: { 
			Name: "Escalation Support",
			BitLength: 1,
			BitOffset: 133,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		16: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 134,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		17: { 
			Name: "Acknowledge Source Network ID NAME",
			BitLength: 64,
			BitOffset: 136,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		18: { 
			Name: "Trigger Condition",
			BitLength: 4,
			BitOffset: 200,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		19: { 
			Name: "Threshold Status",
			BitLength: 4,
			BitOffset: 204,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		20: { 
			Name: "Alert Priority",
			BitLength: 8,
			BitOffset: 208,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		21: { 
			Name: "Alert State",
			BitLength: 8,
			BitOffset: 216,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		},
	},
	{
		Id: "AlertResponse",
		PGN: 126984,
		Description: "Alert Response",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlertResponse,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Alert Type",
			BitLength: 4,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Alert Category",
			BitLength: 4,
			BitOffset: 4,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Alert System",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Alert Sub-System",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Alert ID",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Data Source Network ID NAME",
			BitLength: 64,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Data Source Instance",
			BitLength: 8,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Data Source Index-Source",
			BitLength: 8,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		9: { 
			Name: "Alert Occurrence Number",
			BitLength: 8,
			BitOffset: 120,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		10: { 
			Name: "Acknowledge Source Network ID NAME",
			BitLength: 64,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		11: { 
			Name: "Response Command",
			BitLength: 2,
			BitOffset: 192,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 194,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AlertText",
		PGN: 126985,
		Description: "Alert Text",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAlertText,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Alert Type",
			BitLength: 4,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Alert Category",
			BitLength: 4,
			BitOffset: 4,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Alert System",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Alert Sub-System",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Alert ID",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Data Source Network ID NAME",
			BitLength: 64,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Data Source Instance",
			BitLength: 8,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Data Source Index-Source",
			BitLength: 8,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		9: { 
			Name: "Alert Occurrence Number",
			BitLength: 8,
			BitOffset: 120,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		10: { 
			Name: "Language ID",
			BitLength: 8,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		11: { 
			Name: "Alert Text Description",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		12: { 
			Name: "Alert Location Text Description",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		},
	},
	{
		Id: "SystemTime",
		PGN: 126992,
		Description: "System Time",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSystemTime,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Source",
			BitLength: 4,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 12,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "Date",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		5: { 
			Name: "Time",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		},
	},
	{
		Id: "Heartbeat",
		PGN: 126993,
		Description: "Heartbeat",
		Fast: false,
		ManId: 0,
		Decoder: DecodeHeartbeat,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Data transmit offset",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.001,
			},
		2: { 
			Name: "Sequence Counter",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Controller 1 State",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Controller 2 State",
			BitLength: 2,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Equipment Status",
			BitLength: 2,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 34,
			BitOffset: 30,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "ProductInformation",
		PGN: 126996,
		Description: "Product Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeProductInformation,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "NMEA 2000 Version",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		2: { 
			Name: "Product Code",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Model ID",
			BitLength: 256,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		4: { 
			Name: "Software Version Code",
			BitLength: 256,
			BitOffset: 288,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		5: { 
			Name: "Model Version",
			BitLength: 256,
			BitOffset: 544,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		6: { 
			Name: "Model Serial Code",
			BitLength: 256,
			BitOffset: 800,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		7: { 
			Name: "Certification Level",
			BitLength: 8,
			BitOffset: 1056,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Load Equivalency",
			BitLength: 8,
			BitOffset: 1064,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "ConfigurationInformation",
		PGN: 126998,
		Description: "Configuration Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeConfigurationInformation,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Installation Description #1",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		2: { 
			Name: "Installation Description #2",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		3: { 
			Name: "Manufacturer Information",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		},
	},
	{
		Id: "ManOverboardNotification",
		PGN: 127233,
		Description: "Man Overboard Notification",
		Fast: true,
		ManId: 0,
		Decoder: DecodeManOverboardNotification,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "MOB Emitter ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Man Overboard Status",
			BitLength: 3,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 5,
			BitOffset: 43,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "Activation Time",
			BitLength: 32,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		6: { 
			Name: "Position Source",
			BitLength: 3,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Reserved",
			BitLength: 5,
			BitOffset: 83,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		8: { 
			Name: "Position Date",
			BitLength: 16,
			BitOffset: 88,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		9: { 
			Name: "Position Time",
			BitLength: 32,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		10: { 
			Name: "Latitude",
			BitLength: 32,
			BitOffset: 136,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		11: { 
			Name: "Longitude",
			BitLength: 32,
			BitOffset: 168,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		12: { 
			Name: "COG Reference",
			BitLength: 2,
			BitOffset: 200,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		13: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 202,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		14: { 
			Name: "COG",
			BitLength: 16,
			BitOffset: 208,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		15: { 
			Name: "SOG",
			BitLength: 16,
			BitOffset: 224,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		16: { 
			Name: "MMSI of vessel of origin",
			BitLength: 32,
			BitOffset: 240,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		17: { 
			Name: "MOB Emitter Battery Low Status",
			BitLength: 3,
			BitOffset: 272,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		18: { 
			Name: "Reserved",
			BitLength: 5,
			BitOffset: 275,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "HeadingTrackControl",
		PGN: 127237,
		Description: "Heading/Track control",
		Fast: true,
		ManId: 0,
		Decoder: DecodeHeadingTrackControl,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Rudder Limit Exceeded",
			BitLength: 2,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Off-Heading Limit Exceeded",
			BitLength: 2,
			BitOffset: 2,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Off-Track Limit Exceeded",
			BitLength: 2,
			BitOffset: 4,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Override",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Steering Mode",
			BitLength: 3,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Turn Mode",
			BitLength: 3,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Heading Reference",
			BitLength: 2,
			BitOffset: 14,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Reserved",
			BitLength: 5,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		9: { 
			Name: "Commanded Rudder Direction",
			BitLength: 3,
			BitOffset: 21,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Commanded Rudder Angle",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		11: { 
			Name: "Heading-To-Steer (Course)",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		12: { 
			Name: "Track",
			BitLength: 16,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		13: { 
			Name: "Rudder Limit",
			BitLength: 16,
			BitOffset: 72,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		14: { 
			Name: "Off-Heading Limit",
			BitLength: 16,
			BitOffset: 88,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		15: { 
			Name: "Radius of Turn Order",
			BitLength: 16,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		16: { 
			Name: "Rate of Turn Order",
			BitLength: 16,
			BitOffset: 120,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:3.125e-05,
			},
		17: { 
			Name: "Off-Track Limit",
			BitLength: 16,
			BitOffset: 136,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		18: { 
			Name: "Vessel Heading",
			BitLength: 16,
			BitOffset: 152,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		},
	},
	{
		Id: "Rudder",
		PGN: 127245,
		Description: "Rudder",
		Fast: false,
		ManId: 0,
		Decoder: DecodeRudder,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Direction Order",
			BitLength: 3,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 5,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "Angle Order",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		5: { 
			Name: "Position",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		6: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "VesselHeading",
		PGN: 127250,
		Description: "Vessel Heading",
		Fast: false,
		ManId: 0,
		Decoder: DecodeVesselHeading,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Heading",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		3: { 
			Name: "Deviation",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		4: { 
			Name: "Variation",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		5: { 
			Name: "Reference",
			BitLength: 2,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 58,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "RateOfTurn",
		PGN: 127251,
		Description: "Rate of Turn",
		Fast: false,
		ManId: 0,
		Decoder: DecodeRateOfTurn,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Rate",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:3.125e-08,
			},
		3: { 
			Name: "Reserved",
			BitLength: 24,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "Attitude",
		PGN: 127257,
		Description: "Attitude",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAttitude,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Yaw",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		3: { 
			Name: "Pitch",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		4: { 
			Name: "Roll",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		5: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "MagneticVariation",
		PGN: 127258,
		Description: "Magnetic Variation",
		Fast: false,
		ManId: 0,
		Decoder: DecodeMagneticVariation,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Source",
			BitLength: 4,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 12,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "Age of service",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		5: { 
			Name: "Variation",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		6: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "EngineParametersRapidUpdate",
		PGN: 127488,
		Description: "Engine Parameters, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodeEngineParametersRapidUpdate,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Speed",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.25,
			},
		3: { 
			Name: "Boost Pressure",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:100,
			},
		4: { 
			Name: "Tilt/Trim",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "EngineParametersDynamic",
		PGN: 127489,
		Description: "Engine Parameters, Dynamic",
		Fast: true,
		ManId: 0,
		Decoder: DecodeEngineParametersDynamic,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Oil pressure",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:100,
			},
		3: { 
			Name: "Oil temperature",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		4: { 
			Name: "Temperature",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		5: { 
			Name: "Alternator Potential",
			BitLength: 16,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		6: { 
			Name: "Fuel Rate",
			BitLength: 16,
			BitOffset: 72,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		7: { 
			Name: "Total Engine hours",
			BitLength: 32,
			BitOffset: 88,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:1,
			},
		8: { 
			Name: "Coolant Pressure",
			BitLength: 16,
			BitOffset: 120,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:100,
			},
		9: { 
			Name: "Fuel Pressure",
			BitLength: 16,
			BitOffset: 136,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1000,
			},
		10: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 152,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		11: { 
			Name: "Discrete Status 1",
			BitLength: 16,
			BitOffset: 160,
			BitLengthVariable: false,
			CanboatType: "BITLOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Discrete Status 2",
			BitLength: 16,
			BitOffset: 176,
			BitLengthVariable: false,
			CanboatType: "BITLOOKUP",
			Resolution:1,
			},
		13: { 
			Name: "Engine Load",
			BitLength: 8,
			BitOffset: 192,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		14: { 
			Name: "Engine Torque",
			BitLength: 8,
			BitOffset: 200,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "TransmissionParametersDynamic",
		PGN: 127493,
		Description: "Transmission Parameters, Dynamic",
		Fast: false,
		ManId: 0,
		Decoder: DecodeTransmissionParametersDynamic,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Transmission Gear",
			BitLength: 2,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 10,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "Oil pressure",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:100,
			},
		5: { 
			Name: "Oil temperature",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		6: { 
			Name: "Discrete Status 1",
			BitLength: 8,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "TripParametersVessel",
		PGN: 127496,
		Description: "Trip Parameters, Vessel",
		Fast: true,
		ManId: 0,
		Decoder: DecodeTripParametersVessel,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Time to Empty",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.001,
			},
		2: { 
			Name: "Distance to Empty",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		3: { 
			Name: "Estimated Fuel Remaining",
			BitLength: 16,
			BitOffset: 64,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Trip Run Time",
			BitLength: 32,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.001,
			},
		},
	},
	{
		Id: "TripParametersEngine",
		PGN: 127497,
		Description: "Trip Parameters, Engine",
		Fast: true,
		ManId: 0,
		Decoder: DecodeTripParametersEngine,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Trip Fuel Used",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Fuel Rate, Average",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		4: { 
			Name: "Fuel Rate, Economy",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		5: { 
			Name: "Instantaneous Fuel Economy",
			BitLength: 16,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		},
	},
	{
		Id: "EngineParametersStatic",
		PGN: 127498,
		Description: "Engine Parameters, Static",
		Fast: true,
		ManId: 0,
		Decoder: DecodeEngineParametersStatic,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Rated Engine Speed",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.25,
			},
		3: { 
			Name: "VIN",
			BitLength: 136,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		4: { 
			Name: "Software ID",
			BitLength: 256,
			BitOffset: 160,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		},
	},
	{
		Id: "LoadControllerConnectionStateControl",
		PGN: 127500,
		Description: "Load Controller Connection State/Control",
		Fast: false,
		ManId: 0,
		Decoder: DecodeLoadControllerConnectionStateControl,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Sequence ID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Connection ID",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "State",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Status",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Operational Status & Control",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "PWM Duty Cycle",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "TimeON",
			BitLength: 8,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "TimeOFF",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "BinarySwitchBankStatus",
		PGN: 127501,
		Description: "Binary Switch Bank Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBinarySwitchBankStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Indicator1",
			BitLength: 2,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Indicator2",
			BitLength: 2,
			BitOffset: 10,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Indicator3",
			BitLength: 2,
			BitOffset: 12,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Indicator4",
			BitLength: 2,
			BitOffset: 14,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Indicator5",
			BitLength: 2,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Indicator6",
			BitLength: 2,
			BitOffset: 18,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Indicator7",
			BitLength: 2,
			BitOffset: 20,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		9: { 
			Name: "Indicator8",
			BitLength: 2,
			BitOffset: 22,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Indicator9",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		11: { 
			Name: "Indicator10",
			BitLength: 2,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Indicator11",
			BitLength: 2,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		13: { 
			Name: "Indicator12",
			BitLength: 2,
			BitOffset: 30,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		14: { 
			Name: "Indicator13",
			BitLength: 2,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		15: { 
			Name: "Indicator14",
			BitLength: 2,
			BitOffset: 34,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		16: { 
			Name: "Indicator15",
			BitLength: 2,
			BitOffset: 36,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		17: { 
			Name: "Indicator16",
			BitLength: 2,
			BitOffset: 38,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		18: { 
			Name: "Indicator17",
			BitLength: 2,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		19: { 
			Name: "Indicator18",
			BitLength: 2,
			BitOffset: 42,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		20: { 
			Name: "Indicator19",
			BitLength: 2,
			BitOffset: 44,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		21: { 
			Name: "Indicator20",
			BitLength: 2,
			BitOffset: 46,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		22: { 
			Name: "Indicator21",
			BitLength: 2,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		23: { 
			Name: "Indicator22",
			BitLength: 2,
			BitOffset: 50,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		24: { 
			Name: "Indicator23",
			BitLength: 2,
			BitOffset: 52,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		25: { 
			Name: "Indicator24",
			BitLength: 2,
			BitOffset: 54,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		26: { 
			Name: "Indicator25",
			BitLength: 2,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		27: { 
			Name: "Indicator26",
			BitLength: 2,
			BitOffset: 58,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		28: { 
			Name: "Indicator27",
			BitLength: 2,
			BitOffset: 60,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		29: { 
			Name: "Indicator28",
			BitLength: 2,
			BitOffset: 62,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		},
	},
	{
		Id: "SwitchBankControl",
		PGN: 127502,
		Description: "Switch Bank Control",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSwitchBankControl,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Switch1",
			BitLength: 2,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Switch2",
			BitLength: 2,
			BitOffset: 10,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Switch3",
			BitLength: 2,
			BitOffset: 12,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Switch4",
			BitLength: 2,
			BitOffset: 14,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Switch5",
			BitLength: 2,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Switch6",
			BitLength: 2,
			BitOffset: 18,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Switch7",
			BitLength: 2,
			BitOffset: 20,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		9: { 
			Name: "Switch8",
			BitLength: 2,
			BitOffset: 22,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Switch9",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		11: { 
			Name: "Switch10",
			BitLength: 2,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Switch11",
			BitLength: 2,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		13: { 
			Name: "Switch12",
			BitLength: 2,
			BitOffset: 30,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		14: { 
			Name: "Switch13",
			BitLength: 2,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		15: { 
			Name: "Switch14",
			BitLength: 2,
			BitOffset: 34,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		16: { 
			Name: "Switch15",
			BitLength: 2,
			BitOffset: 36,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		17: { 
			Name: "Switch16",
			BitLength: 2,
			BitOffset: 38,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		18: { 
			Name: "Switch17",
			BitLength: 2,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		19: { 
			Name: "Switch18",
			BitLength: 2,
			BitOffset: 42,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		20: { 
			Name: "Switch19",
			BitLength: 2,
			BitOffset: 44,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		21: { 
			Name: "Switch20",
			BitLength: 2,
			BitOffset: 46,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		22: { 
			Name: "Switch21",
			BitLength: 2,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		23: { 
			Name: "Switch22",
			BitLength: 2,
			BitOffset: 50,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		24: { 
			Name: "Switch23",
			BitLength: 2,
			BitOffset: 52,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		25: { 
			Name: "Switch24",
			BitLength: 2,
			BitOffset: 54,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		26: { 
			Name: "Switch25",
			BitLength: 2,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		27: { 
			Name: "Switch26",
			BitLength: 2,
			BitOffset: 58,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		28: { 
			Name: "Switch27",
			BitLength: 2,
			BitOffset: 60,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		29: { 
			Name: "Switch28",
			BitLength: 2,
			BitOffset: 62,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		},
	},
	{
		Id: "AcInputStatus",
		PGN: 127503,
		Description: "AC Input Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAcInputStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Number of Lines",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "AcOutputStatus",
		PGN: 127504,
		Description: "AC Output Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAcOutputStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Number of Lines",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "FluidLevel",
		PGN: 127505,
		Description: "Fluid Level",
		Fast: false,
		ManId: 0,
		Decoder: DecodeFluidLevel,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 4,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Type",
			BitLength: 4,
			BitOffset: 4,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Level",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.004,
			},
		4: { 
			Name: "Capacity",
			BitLength: 32,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		5: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "DcDetailedStatus",
		PGN: 127506,
		Description: "DC Detailed Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDcDetailedStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "DC Type",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "State of Charge",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "State of Health",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Time Remaining",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:60,
			},
		7: { 
			Name: "Ripple Voltage",
			BitLength: 16,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		8: { 
			Name: "Remaining capacity",
			BitLength: 16,
			BitOffset: 72,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "ChargerStatus",
		PGN: 127507,
		Description: "Charger Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeChargerStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Battery Instance",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Operating State",
			BitLength: 4,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Charge Mode",
			BitLength: 4,
			BitOffset: 20,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Enabled",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Equalization Pending",
			BitLength: 2,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		8: { 
			Name: "Equalization Time Remaining",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:60,
			},
		},
	},
	{
		Id: "BatteryStatus",
		PGN: 127508,
		Description: "Battery Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeBatteryStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Voltage",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		3: { 
			Name: "Current",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		4: { 
			Name: "Temperature",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		5: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "InverterStatus",
		PGN: 127509,
		Description: "Inverter Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeInverterStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "AC Instance",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "DC Instance",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Operating State",
			BitLength: 4,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Inverter Enable",
			BitLength: 2,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 30,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AcPowerCurrentPhaseA",
		PGN: 127744,
		Description: "AC Power / Current - Phase A",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAcPowerCurrentPhaseA,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Connection Number",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		4: { 
			Name: "Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "AcPowerCurrentPhaseB",
		PGN: 127745,
		Description: "AC Power / Current - Phase B",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAcPowerCurrentPhaseB,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Connection Number",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		4: { 
			Name: "Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "AcPowerCurrentPhaseC",
		PGN: 127746,
		Description: "AC Power / Current - Phase C",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAcPowerCurrentPhaseC,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Connection Number",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "AC RMS Current",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		4: { 
			Name: "Power",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "ConverterStatus",
		PGN: 127750,
		Description: "Converter Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeConverterStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		2: { 
			Name: "Connection Number",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Operating State",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Temperature State",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Overload State",
			BitLength: 2,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Low DC Voltage State",
			BitLength: 2,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Ripple State",
			BitLength: 2,
			BitOffset: 30,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Reserved",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "DcVoltageCurrent",
		PGN: 127751,
		Description: "DC Voltage/Current",
		Fast: false,
		ManId: 0,
		Decoder: DecodeDcVoltageCurrent,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		2: { 
			Name: "Connection Number",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "DC Voltage",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		4: { 
			Name: "DC Current",
			BitLength: 24,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		5: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "LeewayAngle",
		PGN: 128000,
		Description: "Leeway Angle",
		Fast: false,
		ManId: 0,
		Decoder: DecodeLeewayAngle,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Leeway Angle",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		3: { 
			Name: "Reserved",
			BitLength: 40,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "ThrusterControlStatus",
		PGN: 128006,
		Description: "Thruster Control Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeThrusterControlStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Identifier",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Direction Control",
			BitLength: 4,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Power Enabled",
			BitLength: 2,
			BitOffset: 20,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Retract Control",
			BitLength: 2,
			BitOffset: 22,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Speed Control",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Control Events",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "BITLOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Command Timeout",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.005,
			},
		9: { 
			Name: "Azimuth Control",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		},
	},
	{
		Id: "ThrusterInformation",
		PGN: 128007,
		Description: "Thruster Information",
		Fast: false,
		ManId: 0,
		Decoder: DecodeThrusterInformation,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Identifier",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Motor Type",
			BitLength: 4,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 4,
			BitOffset: 12,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "Power Rating",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Maximum Temperature Rating",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		6: { 
			Name: "Maximum Rotational Speed",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.25,
			},
		},
	},
	{
		Id: "ThrusterMotorStatus",
		PGN: 128008,
		Description: "Thruster Motor Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeThrusterMotorStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Identifier",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Motor Events",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "BITLOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Current",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Temperature",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		6: { 
			Name: "Operating Time",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:60,
			},
		},
	},
	{
		Id: "Speed",
		PGN: 128259,
		Description: "Speed",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSpeed,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Speed Water Referenced",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		3: { 
			Name: "Speed Ground Referenced",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		4: { 
			Name: "Speed Water Referenced Type",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Speed Direction",
			BitLength: 4,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 12,
			BitOffset: 52,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "WaterDepth",
		PGN: 128267,
		Description: "Water Depth",
		Fast: false,
		ManId: 0,
		Decoder: DecodeWaterDepth,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Depth",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		3: { 
			Name: "Offset",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		4: { 
			Name: "Range",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:10,
			},
		},
	},
	{
		Id: "DistanceLog",
		PGN: 128275,
		Description: "Distance Log",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDistanceLog,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Date",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		2: { 
			Name: "Time",
			BitLength: 32,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		3: { 
			Name: "Log",
			BitLength: 32,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Trip Log",
			BitLength: 32,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "WindlassControlStatus",
		PGN: 128776,
		Description: "Windlass Control Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeWindlassControlStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Windlass ID",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Windlass Direction Control",
			BitLength: 2,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Anchor Docking Control",
			BitLength: 2,
			BitOffset: 18,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Speed Control Type",
			BitLength: 2,
			BitOffset: 20,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 22,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Speed Control",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		8: { 
			Name: "Power Enable",
			BitLength: 2,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		9: { 
			Name: "Mechanical Lock",
			BitLength: 2,
			BitOffset: 34,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Deck and Anchor Wash",
			BitLength: 2,
			BitOffset: 36,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		11: { 
			Name: "Anchor Light",
			BitLength: 2,
			BitOffset: 38,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Command Timeout",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.005,
			},
		13: { 
			Name: "Windlass Control Events",
			BitLength: 4,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "BITLOOKUP",
			Resolution:1,
			},
		14: { 
			Name: "Reserved",
			BitLength: 12,
			BitOffset: 52,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AnchorWindlassOperatingStatus",
		PGN: 128777,
		Description: "Anchor Windlass Operating Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAnchorWindlassOperatingStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Windlass ID",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Windlass Direction Control",
			BitLength: 2,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Windlass Motion Status",
			BitLength: 2,
			BitOffset: 18,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Rode Type Status",
			BitLength: 2,
			BitOffset: 20,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 22,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Rode Counter Value",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		8: { 
			Name: "Windlass Line Speed",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		9: { 
			Name: "Anchor Docking Status",
			BitLength: 2,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Windlass Operating Events",
			BitLength: 6,
			BitOffset: 58,
			BitLengthVariable: false,
			CanboatType: "BITLOOKUP",
			Resolution:1,
			},
		},
	},
	{
		Id: "AnchorWindlassMonitoringStatus",
		PGN: 128778,
		Description: "Anchor Windlass Monitoring Status",
		Fast: false,
		ManId: 0,
		Decoder: DecodeAnchorWindlassMonitoringStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Windlass ID",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Windlass Monitoring Events",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "BITLOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Controller voltage",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.2,
			},
		5: { 
			Name: "Motor current",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Total Motor Time",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:60,
			},
		7: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "PositionRapidUpdate",
		PGN: 129025,
		Description: "Position, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodePositionRapidUpdate,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Latitude",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		2: { 
			Name: "Longitude",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		},
	},
	{
		Id: "CogSogRapidUpdate",
		PGN: 129026,
		Description: "COG & SOG, Rapid Update",
		Fast: false,
		ManId: 0,
		Decoder: DecodeCogSogRapidUpdate,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "COG Reference",
			BitLength: 2,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 10,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "COG",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		5: { 
			Name: "SOG",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		6: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "GnssPositionData",
		PGN: 129029,
		Description: "GNSS Position Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssPositionData,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Date",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		3: { 
			Name: "Time",
			BitLength: 32,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		4: { 
			Name: "Latitude",
			BitLength: 64,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-16,
			},
		5: { 
			Name: "Longitude",
			BitLength: 64,
			BitOffset: 120,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-16,
			},
		6: { 
			Name: "Altitude",
			BitLength: 64,
			BitOffset: 184,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-06,
			},
		7: { 
			Name: "GNSS type",
			BitLength: 4,
			BitOffset: 248,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Method",
			BitLength: 4,
			BitOffset: 252,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		9: { 
			Name: "Integrity",
			BitLength: 2,
			BitOffset: 256,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 258,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		11: { 
			Name: "Number of SVs",
			BitLength: 8,
			BitOffset: 264,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		12: { 
			Name: "HDOP",
			BitLength: 16,
			BitOffset: 272,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		13: { 
			Name: "PDOP",
			BitLength: 16,
			BitOffset: 288,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		14: { 
			Name: "Geoidal Separation",
			BitLength: 32,
			BitOffset: 304,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		15: { 
			Name: "Reference Stations",
			BitLength: 8,
			BitOffset: 336,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "TimeDate",
		PGN: 129033,
		Description: "Time & Date",
		Fast: false,
		ManId: 0,
		Decoder: DecodeTimeDate,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Date",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		2: { 
			Name: "Time",
			BitLength: 32,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		3: { 
			Name: "Local Offset",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:60,
			},
		},
	},
	{
		Id: "AisClassAPositionReport",
		PGN: 129038,
		Description: "AIS Class A Position Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassAPositionReport,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "User ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		4: { 
			Name: "Longitude",
			BitLength: 32,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		5: { 
			Name: "Latitude",
			BitLength: 32,
			BitOffset: 72,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		6: { 
			Name: "Position Accuracy",
			BitLength: 1,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "RAIM",
			BitLength: 1,
			BitOffset: 105,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Time Stamp",
			BitLength: 6,
			BitOffset: 106,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		9: { 
			Name: "COG",
			BitLength: 16,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		10: { 
			Name: "SOG",
			BitLength: 16,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		11: { 
			Name: "Communication State",
			BitLength: 19,
			BitOffset: 144,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		12: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 163,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		13: { 
			Name: "Heading",
			BitLength: 16,
			BitOffset: 168,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		14: { 
			Name: "Rate of Turn",
			BitLength: 16,
			BitOffset: 184,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:3.125e-05,
			},
		15: { 
			Name: "Nav Status",
			BitLength: 4,
			BitOffset: 200,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		16: { 
			Name: "Special Maneuver Indicator",
			BitLength: 2,
			BitOffset: 204,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		17: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 206,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		18: { 
			Name: "Spare",
			BitLength: 3,
			BitOffset: 208,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		19: { 
			Name: "Reserved",
			BitLength: 5,
			BitOffset: 211,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		20: { 
			Name: "Sequence ID",
			BitLength: 8,
			BitOffset: 216,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "AisClassBPositionReport",
		PGN: 129039,
		Description: "AIS Class B Position Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassBPositionReport,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "User ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		4: { 
			Name: "Longitude",
			BitLength: 32,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		5: { 
			Name: "Latitude",
			BitLength: 32,
			BitOffset: 72,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		6: { 
			Name: "Position Accuracy",
			BitLength: 1,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "RAIM",
			BitLength: 1,
			BitOffset: 105,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Time Stamp",
			BitLength: 6,
			BitOffset: 106,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		9: { 
			Name: "COG",
			BitLength: 16,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		10: { 
			Name: "SOG",
			BitLength: 16,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		11: { 
			Name: "Communication State",
			BitLength: 19,
			BitOffset: 144,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		12: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 163,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		13: { 
			Name: "Heading",
			BitLength: 16,
			BitOffset: 168,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		14: { 
			Name: "Regional Application",
			BitLength: 8,
			BitOffset: 184,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		15: { 
			Name: "Regional Application B",
			BitLength: 2,
			BitOffset: 192,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		16: { 
			Name: "Unit type",
			BitLength: 1,
			BitOffset: 194,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		17: { 
			Name: "Integrated Display",
			BitLength: 1,
			BitOffset: 195,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		18: { 
			Name: "DSC",
			BitLength: 1,
			BitOffset: 196,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		19: { 
			Name: "Band",
			BitLength: 1,
			BitOffset: 197,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		20: { 
			Name: "Can handle Msg 22",
			BitLength: 1,
			BitOffset: 198,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		21: { 
			Name: "AIS mode",
			BitLength: 1,
			BitOffset: 199,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		22: { 
			Name: "AIS communication state",
			BitLength: 1,
			BitOffset: 200,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		23: { 
			Name: "Reserved",
			BitLength: 15,
			BitOffset: 201,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AisAidsToNavigationAtonReport",
		PGN: 129041,
		Description: "AIS Aids to Navigation (AtoN) Report",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisAidsToNavigationAtonReport,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "User ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		4: { 
			Name: "Longitude",
			BitLength: 32,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		5: { 
			Name: "Latitude",
			BitLength: 32,
			BitOffset: 72,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		6: { 
			Name: "Position Accuracy",
			BitLength: 1,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "RAIM",
			BitLength: 1,
			BitOffset: 105,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Time Stamp",
			BitLength: 6,
			BitOffset: 106,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		9: { 
			Name: "Length/Diameter",
			BitLength: 16,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		10: { 
			Name: "Beam/Diameter",
			BitLength: 16,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		11: { 
			Name: "Position Reference from Starboard Edge",
			BitLength: 16,
			BitOffset: 144,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		12: { 
			Name: "Position Reference from True North Facing Edge",
			BitLength: 16,
			BitOffset: 160,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		13: { 
			Name: "AtoN Type",
			BitLength: 5,
			BitOffset: 176,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		14: { 
			Name: "Off Position Indicator",
			BitLength: 1,
			BitOffset: 181,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		15: { 
			Name: "Virtual AtoN Flag",
			BitLength: 1,
			BitOffset: 182,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		16: { 
			Name: "Assigned Mode Flag",
			BitLength: 1,
			BitOffset: 183,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		17: { 
			Name: "Spare",
			BitLength: 1,
			BitOffset: 184,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		18: { 
			Name: "Position Fixing Device Type",
			BitLength: 4,
			BitOffset: 185,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		19: { 
			Name: "Reserved",
			BitLength: 3,
			BitOffset: 189,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		20: { 
			Name: "AtoN Status",
			BitLength: 8,
			BitOffset: 192,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		21: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 200,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		22: { 
			Name: "Reserved",
			BitLength: 3,
			BitOffset: 205,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		23: { 
			Name: "AtoN Name",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		},
	},
	{
		Id: "Datum",
		PGN: 129044,
		Description: "Datum",
		Fast: true,
		ManId: 0,
		Decoder: DecodeDatum,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Local Datum",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		2: { 
			Name: "Delta Latitude",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		3: { 
			Name: "Delta Longitude",
			BitLength: 32,
			BitOffset: 64,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		4: { 
			Name: "Delta Altitude",
			BitLength: 32,
			BitOffset: 96,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		5: { 
			Name: "Reference Datum",
			BitLength: 32,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		},
	},
	{
		Id: "UserDatum",
		PGN: 129045,
		Description: "User Datum",
		Fast: true,
		ManId: 0,
		Decoder: DecodeUserDatum,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Delta X",
			BitLength: 32,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		2: { 
			Name: "Delta Y",
			BitLength: 32,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		3: { 
			Name: "Delta Z",
			BitLength: 32,
			BitOffset: 64,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		4: { 
			Name: "Rotation in X",
			BitLength: 32,
			BitOffset: 96,
			BitLengthVariable: false,
			CanboatType: "FLOAT",
			Resolution:1,
			},
		5: { 
			Name: "Rotation in Y",
			BitLength: 32,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "FLOAT",
			Resolution:1,
			},
		6: { 
			Name: "Rotation in Z",
			BitLength: 32,
			BitOffset: 160,
			BitLengthVariable: false,
			CanboatType: "FLOAT",
			Resolution:1,
			},
		7: { 
			Name: "Scale",
			BitLength: 32,
			BitOffset: 192,
			BitLengthVariable: false,
			CanboatType: "FLOAT",
			Resolution:1,
			},
		8: { 
			Name: "Ellipsoid Semi-major Axis",
			BitLength: 32,
			BitOffset: 224,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		9: { 
			Name: "Ellipsoid Flattening Inverse",
			BitLength: 32,
			BitOffset: 256,
			BitLengthVariable: false,
			CanboatType: "FLOAT",
			Resolution:1,
			},
		10: { 
			Name: "Datum Name",
			BitLength: 32,
			BitOffset: 288,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		},
	},
	{
		Id: "CrossTrackError",
		PGN: 129283,
		Description: "Cross Track Error",
		Fast: false,
		ManId: 0,
		Decoder: DecodeCrossTrackError,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "XTE mode",
			BitLength: 4,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 12,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "Navigation Terminated",
			BitLength: 2,
			BitOffset: 14,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "XTE",
			BitLength: 32,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		6: { 
			Name: "Reserved",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "NavigationData",
		PGN: 129284,
		Description: "Navigation Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNavigationData,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Distance to Waypoint",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		3: { 
			Name: "Course/Bearing reference",
			BitLength: 2,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Perpendicular Crossed",
			BitLength: 2,
			BitOffset: 42,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Arrival Circle Entered",
			BitLength: 2,
			BitOffset: 44,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Calculation Type",
			BitLength: 2,
			BitOffset: 46,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "ETA Time",
			BitLength: 32,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		8: { 
			Name: "ETA Date",
			BitLength: 16,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		9: { 
			Name: "Bearing, Origin to Destination Waypoint",
			BitLength: 16,
			BitOffset: 96,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		10: { 
			Name: "Bearing, Position to Destination Waypoint",
			BitLength: 16,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		11: { 
			Name: "Origin Waypoint Number",
			BitLength: 32,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		12: { 
			Name: "Destination Waypoint Number",
			BitLength: 32,
			BitOffset: 160,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		13: { 
			Name: "Destination Latitude",
			BitLength: 32,
			BitOffset: 192,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		14: { 
			Name: "Destination Longitude",
			BitLength: 32,
			BitOffset: 224,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		15: { 
			Name: "Waypoint Closing Velocity",
			BitLength: 16,
			BitOffset: 256,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		},
	},
	{
		Id: "NavigationRouteWpInformation",
		PGN: 129285,
		Description: "Navigation - Route/WP Information",
		Fast: true,
		ManId: 0,
		Decoder: DecodeNavigationRouteWpInformation,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Start RPS#",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "nItems",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Database ID",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Route ID",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Navigation direction in route",
			BitLength: 3,
			BitOffset: 64,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Supplementary Route/WP data available",
			BitLength: 2,
			BitOffset: 67,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Reserved",
			BitLength: 3,
			BitOffset: 69,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		8: { 
			Name: "Route Name",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		9: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "GnssDops",
		PGN: 129539,
		Description: "GNSS DOPs",
		Fast: false,
		ManId: 0,
		Decoder: DecodeGnssDops,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Desired Mode",
			BitLength: 3,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Actual Mode",
			BitLength: 3,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 14,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "HDOP",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		6: { 
			Name: "VDOP",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		7: { 
			Name: "TDOP",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		},
	},
	{
		Id: "GnssSatsInView",
		PGN: 129540,
		Description: "GNSS Sats in View",
		Fast: true,
		ManId: 0,
		Decoder: DecodeGnssSatsInView,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Range Residual Mode",
			BitLength: 2,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 10,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "Sats in View",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "AisClassAStaticAndVoyageRelatedData",
		PGN: 129794,
		Description: "AIS Class A Static and Voyage Related Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassAStaticAndVoyageRelatedData,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "User ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		4: { 
			Name: "IMO number",
			BitLength: 32,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Callsign",
			BitLength: 56,
			BitOffset: 72,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		6: { 
			Name: "Name",
			BitLength: 160,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		7: { 
			Name: "Type of ship",
			BitLength: 8,
			BitOffset: 288,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Length",
			BitLength: 16,
			BitOffset: 296,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		9: { 
			Name: "Beam",
			BitLength: 16,
			BitOffset: 312,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		10: { 
			Name: "Position reference from Starboard",
			BitLength: 16,
			BitOffset: 328,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		11: { 
			Name: "Position reference from Bow",
			BitLength: 16,
			BitOffset: 344,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		12: { 
			Name: "ETA Date",
			BitLength: 16,
			BitOffset: 360,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		13: { 
			Name: "ETA Time",
			BitLength: 32,
			BitOffset: 376,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		14: { 
			Name: "Draft",
			BitLength: 16,
			BitOffset: 408,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		15: { 
			Name: "Destination",
			BitLength: 160,
			BitOffset: 424,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		16: { 
			Name: "AIS version indicator",
			BitLength: 2,
			BitOffset: 584,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		17: { 
			Name: "GNSS type",
			BitLength: 4,
			BitOffset: 586,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		18: { 
			Name: "DTE",
			BitLength: 1,
			BitOffset: 590,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		19: { 
			Name: "Reserved",
			BitLength: 1,
			BitOffset: 591,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		20: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 592,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		21: { 
			Name: "Reserved",
			BitLength: 3,
			BitOffset: 597,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AisAddressedBinaryMessage",
		PGN: 129795,
		Description: "AIS Addressed Binary Message",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisAddressedBinaryMessage,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Source ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 1,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 41,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Sequence Number",
			BitLength: 2,
			BitOffset: 46,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		7: { 
			Name: "Destination ID",
			BitLength: 32,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		8: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		9: { 
			Name: "Retransmit flag",
			BitLength: 1,
			BitOffset: 86,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		10: { 
			Name: "Reserved",
			BitLength: 1,
			BitOffset: 87,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		11: { 
			Name: "Number of Bits in Binary Data Field",
			BitLength: 16,
			BitOffset: 88,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		12: { 
			Name: "Binary Data",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "BINARY",
			Resolution:1,
			},
		},
	},
	{
		Id: "AisAcknowledge",
		PGN: 129796,
		Description: "AIS Acknowledge",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisAcknowledge,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Source ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 1,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 41,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 46,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Destination ID #1",
			BitLength: 32,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Sequence Number for ID 1",
			BitLength: 2,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		9: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 82,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		10: { 
			Name: "Sequence Number for ID n",
			BitLength: 2,
			BitOffset: 88,
			BitLengthVariable: false,
			CanboatType: "BINARY",
			Resolution:1,
			},
		11: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 90,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "AisBinaryBroadcastMessage",
		PGN: 129797,
		Description: "AIS Binary Broadcast Message",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisBinaryBroadcastMessage,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Source ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 1,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 41,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 46,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Number of Bits in Binary Data Field",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Binary Data",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "BINARY",
			Resolution:1,
			},
		},
	},
	{
		Id: "AisClassBStaticDataMsg24PartA",
		PGN: 129809,
		Description: "AIS Class B static data (msg 24 Part A)",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassBStaticDataMsg24PartA,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "User ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		4: { 
			Name: "Name",
			BitLength: 160,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		5: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 200,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Reserved",
			BitLength: 3,
			BitOffset: 205,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		7: { 
			Name: "Sequence ID",
			BitLength: 8,
			BitOffset: 208,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "AisClassBStaticDataMsg24PartB",
		PGN: 129810,
		Description: "AIS Class B static data (msg 24 Part B)",
		Fast: true,
		ManId: 0,
		Decoder: DecodeAisClassBStaticDataMsg24PartB,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Message ID",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Repeat Indicator",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "User ID",
			BitLength: 32,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		4: { 
			Name: "Type of ship",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Vendor ID",
			BitLength: 56,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		6: { 
			Name: "Callsign",
			BitLength: 56,
			BitOffset: 104,
			BitLengthVariable: false,
			CanboatType: "STRING_FIX",
			Resolution:1,
			},
		7: { 
			Name: "Length",
			BitLength: 16,
			BitOffset: 160,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		8: { 
			Name: "Beam",
			BitLength: 16,
			BitOffset: 176,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		9: { 
			Name: "Position reference from Starboard",
			BitLength: 16,
			BitOffset: 192,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		10: { 
			Name: "Position reference from Bow",
			BitLength: 16,
			BitOffset: 208,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		11: { 
			Name: "Mothership User ID",
			BitLength: 32,
			BitOffset: 224,
			BitLengthVariable: false,
			CanboatType: "MMSI",
			Resolution:1,
			},
		12: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 256,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		13: { 
			Name: "Spare",
			BitLength: 2,
			BitOffset: 258,
			BitLengthVariable: false,
			CanboatType: "SPARE",
			Resolution:1,
			},
		14: { 
			Name: "GNSS type",
			BitLength: 4,
			BitOffset: 260,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		15: { 
			Name: "AIS Transceiver information",
			BitLength: 5,
			BitOffset: 264,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		16: { 
			Name: "Reserved",
			BitLength: 3,
			BitOffset: 269,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		17: { 
			Name: "Sequence ID",
			BitLength: 8,
			BitOffset: 272,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "WindData",
		PGN: 130306,
		Description: "Wind Data",
		Fast: false,
		ManId: 0,
		Decoder: DecodeWindData,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Wind Speed",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		3: { 
			Name: "Wind Angle",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.0001,
			},
		4: { 
			Name: "Reference",
			BitLength: 3,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "Reserved",
			BitLength: 21,
			BitOffset: 43,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "EnvironmentalParametersObsolete",
		PGN: 130310,
		Description: "Environmental Parameters (obsolete)",
		Fast: false,
		ManId: 0,
		Decoder: DecodeEnvironmentalParametersObsolete,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Water Temperature",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		3: { 
			Name: "Outside Ambient Air Temperature",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		4: { 
			Name: "Atmospheric Pressure",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:100,
			},
		5: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "EnvironmentalParameters",
		PGN: 130311,
		Description: "Environmental Parameters",
		Fast: false,
		ManId: 0,
		Decoder: DecodeEnvironmentalParameters,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Temperature Source",
			BitLength: 6,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Humidity Source",
			BitLength: 2,
			BitOffset: 14,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Temperature",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		5: { 
			Name: "Humidity",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.004,
			},
		6: { 
			Name: "Atmospheric Pressure",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:100,
			},
		},
	},
	{
		Id: "Temperature",
		PGN: 130312,
		Description: "Temperature",
		Fast: false,
		ManId: 0,
		Decoder: DecodeTemperature,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Source",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Actual Temperature",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		5: { 
			Name: "Set Temperature",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		6: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "Humidity",
		PGN: 130313,
		Description: "Humidity",
		Fast: false,
		ManId: 0,
		Decoder: DecodeHumidity,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Source",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Actual Humidity",
			BitLength: 16,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.004,
			},
		5: { 
			Name: "Set Humidity",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.004,
			},
		6: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "ActualPressure",
		PGN: 130314,
		Description: "Actual Pressure",
		Fast: false,
		ManId: 0,
		Decoder: DecodeActualPressure,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Source",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Pressure",
			BitLength: 32,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		5: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "SetPressure",
		PGN: 130315,
		Description: "Set Pressure",
		Fast: false,
		ManId: 0,
		Decoder: DecodeSetPressure,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Source",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Pressure",
			BitLength: 32,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		5: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "TemperatureExtendedRange",
		PGN: 130316,
		Description: "Temperature Extended Range",
		Fast: false,
		ManId: 0,
		Decoder: DecodeTemperatureExtendedRange,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		2: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		3: { 
			Name: "Source",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Temperature",
			BitLength: 24,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		5: { 
			Name: "Set Temperature",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		},
	},
	{
		Id: "TideStationData",
		PGN: 130320,
		Description: "Tide Station Data",
		Fast: true,
		ManId: 0,
		Decoder: DecodeTideStationData,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Mode",
			BitLength: 4,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Tide Tendency",
			BitLength: 2,
			BitOffset: 4,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		4: { 
			Name: "Measurement Date",
			BitLength: 16,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		5: { 
			Name: "Measurement Time",
			BitLength: 32,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		6: { 
			Name: "Station Latitude",
			BitLength: 32,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		7: { 
			Name: "Station Longitude",
			BitLength: 32,
			BitOffset: 88,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1e-07,
			},
		8: { 
			Name: "Tide Level",
			BitLength: 16,
			BitOffset: 120,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		9: { 
			Name: "Tide Level standard deviation",
			BitLength: 16,
			BitOffset: 136,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		10: { 
			Name: "Station ID",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		11: { 
			Name: "Station Name",
			BitLength: 0,
			BitOffset: 0,
			BitLengthVariable: true,
			CanboatType: "STRING_LAU",
			Resolution:1,
			},
		},
	},
	{
		Id: "WatermakerInputSettingAndStatus",
		PGN: 130567,
		Description: "Watermaker Input Setting and Status",
		Fast: true,
		ManId: 0,
		Decoder: DecodeWatermakerInputSettingAndStatus,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Watermaker Operating State",
			BitLength: 6,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Production Start/Stop",
			BitLength: 2,
			BitOffset: 6,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		3: { 
			Name: "Rinse Start/Stop",
			BitLength: 2,
			BitOffset: 8,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Low Pressure Pump Status",
			BitLength: 2,
			BitOffset: 10,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		5: { 
			Name: "High Pressure Pump Status",
			BitLength: 2,
			BitOffset: 12,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Emergency Stop",
			BitLength: 2,
			BitOffset: 14,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Product Solenoid Valve Status",
			BitLength: 2,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		8: { 
			Name: "Flush Mode Status",
			BitLength: 2,
			BitOffset: 18,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		9: { 
			Name: "Salinity Status",
			BitLength: 2,
			BitOffset: 20,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		10: { 
			Name: "Sensor Status",
			BitLength: 2,
			BitOffset: 22,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		11: { 
			Name: "Oil Change Indicator Status",
			BitLength: 2,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Filter Status",
			BitLength: 2,
			BitOffset: 26,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		13: { 
			Name: "System Status",
			BitLength: 2,
			BitOffset: 28,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		14: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 30,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		15: { 
			Name: "Salinity",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		16: { 
			Name: "Product Water Temperature",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.01,
			},
		17: { 
			Name: "Pre-filter Pressure",
			BitLength: 16,
			BitOffset: 64,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:100,
			},
		18: { 
			Name: "Post-filter Pressure",
			BitLength: 16,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:100,
			},
		19: { 
			Name: "Feed Pressure",
			BitLength: 16,
			BitOffset: 96,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1000,
			},
		20: { 
			Name: "System High Pressure",
			BitLength: 16,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1000,
			},
		21: { 
			Name: "Product Water Flow",
			BitLength: 16,
			BitOffset: 128,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		22: { 
			Name: "Brine Water Flow",
			BitLength: 16,
			BitOffset: 144,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		23: { 
			Name: "Run Time",
			BitLength: 32,
			BitOffset: 160,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:1,
			},
		},
	},
	{
		Id: "VesselSpeedComponents",
		PGN: 130578,
		Description: "Vessel Speed Components",
		Fast: true,
		ManId: 0,
		Decoder: DecodeVesselSpeedComponents,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Longitudinal Speed, Water-referenced",
			BitLength: 16,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		2: { 
			Name: "Transverse Speed, Water-referenced",
			BitLength: 16,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		3: { 
			Name: "Longitudinal Speed, Ground-referenced",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		4: { 
			Name: "Transverse Speed, Ground-referenced",
			BitLength: 16,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		5: { 
			Name: "Stern Speed, Water-referenced",
			BitLength: 16,
			BitOffset: 64,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		6: { 
			Name: "Stern Speed, Ground-referenced",
			BitLength: 16,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.001,
			},
		},
	},
	{
		Id: "SonichubVolume",
		PGN: 130816,
		Description: "SonicHub: Volume",
		Fast: true,
		ManId: 275,
		Decoder: DecodeSonichubVolume,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Reserved",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		5: { 
			Name: "Proprietary ID",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		6: { 
			Name: "Control",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Zone",
			BitLength: 8,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		8: { 
			Name: "Level",
			BitLength: 8,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		},
	},
	{
		Id: "MaretronProprietaryTemperatureHighRange",
		PGN: 130823,
		Description: "Maretron: Proprietary Temperature High Range",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronProprietaryTemperatureHighRange,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "SID",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Source",
			BitLength: 8,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		7: { 
			Name: "Actual Temperature",
			BitLength: 16,
			BitOffset: 40,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		8: { 
			Name: "Set Temperature",
			BitLength: 16,
			BitOffset: 56,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:0.1,
			},
		},
	},
	{
		Id: "BGKeyValueData",
		PGN: 130824,
		Description: "B&G: key-value data",
		Fast: true,
		ManId: 381,
		Decoder: DecodeBGKeyValueData,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		},
	},
	{
		Id: "MaretronSwitchStatusCounter",
		PGN: 130836,
		Description: "Maretron: Switch Status Counter",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronSwitchStatusCounter,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Indicator Number",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Start Date",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		7: { 
			Name: "Start Time",
			BitLength: 32,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		8: { 
			Name: "OFF Counter",
			BitLength: 32,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		9: { 
			Name: "ON Counter",
			BitLength: 32,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		10: { 
			Name: "ERROR Counter",
			BitLength: 32,
			BitOffset: 144,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		11: { 
			Name: "Switch Status",
			BitLength: 2,
			BitOffset: 176,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 178,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
	{
		Id: "MaretronSwitchStatusTimer",
		PGN: 130837,
		Description: "Maretron: Switch Status Timer",
		Fast: true,
		ManId: 137,
		Decoder: DecodeMaretronSwitchStatusTimer,
		Fields: map[int]*FieldDescriptor{
		1: { 
			Name: "Manufacturer Code",
			BitLength: 11,
			BitOffset: 0,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		2: { 
			Name: "Reserved",
			BitLength: 2,
			BitOffset: 11,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		3: { 
			Name: "Industry Code",
			BitLength: 3,
			BitOffset: 13,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		4: { 
			Name: "Instance",
			BitLength: 8,
			BitOffset: 16,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		5: { 
			Name: "Indicator Number",
			BitLength: 8,
			BitOffset: 24,
			BitLengthVariable: false,
			CanboatType: "NUMBER",
			Resolution:1,
			},
		6: { 
			Name: "Start Date",
			BitLength: 16,
			BitOffset: 32,
			BitLengthVariable: false,
			CanboatType: "DATE",
			Resolution:1,
			},
		7: { 
			Name: "Start Time",
			BitLength: 32,
			BitOffset: 48,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:0.0001,
			},
		8: { 
			Name: "Accumulated OFF Period",
			BitLength: 32,
			BitOffset: 80,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:1,
			},
		9: { 
			Name: "Accumulated ON Period",
			BitLength: 32,
			BitOffset: 112,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:1,
			},
		10: { 
			Name: "Accumulated ERROR Period",
			BitLength: 32,
			BitOffset: 144,
			BitLengthVariable: false,
			CanboatType: "TIME",
			Resolution:1,
			},
		11: { 
			Name: "Switch Status",
			BitLength: 2,
			BitOffset: 176,
			BitLengthVariable: false,
			CanboatType: "LOOKUP",
			Resolution:1,
			},
		12: { 
			Name: "Reserved",
			BitLength: 6,
			BitOffset: 178,
			BitLengthVariable: false,
			CanboatType: "RESERVED",
			Resolution:1,
			},
		},
	},
}
// Build structs for each PGN
type IsoAcknowledgement struct {
	Info MessageInfo
	Control IsoControlConst
	GroupFunction *uint8
	Pgn *uint32
}
func (p IsoAcknowledgement ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoAcknowledgement\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoAcknowledgement ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.Control), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.GroupFunction, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(24, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoAcknowledgement(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoAcknowledgement
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAcknowledgement-Control: %w", err)
	} else {
		val.Control = IsoControlConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAcknowledgement-GroupFunction: %w", err)
	} else {
		val.GroupFunction = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAcknowledgement-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoRequest struct {
	Info MessageInfo
	Pgn *uint32
}
func (p IsoRequest ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoRequest\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoRequest ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint32(p.Pgn, 24, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoRequest(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoRequest
	val.Info = Info
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoRequest-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolDataTransfer struct {
	Info MessageInfo
	Sid *uint8
	Data []uint8
}
func (p IsoTransportProtocolDataTransfer ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoTransportProtocolDataTransfer\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoTransportProtocolDataTransfer ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.Data, 56, 8 )
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoTransportProtocolDataTransfer(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoTransportProtocolDataTransfer
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolDataTransfer-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(56); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolDataTransfer-Data: %w", err)
	} else {
		val.Data = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementRequestToSend struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	MessageSize *uint16
	Packets *uint8
	PacketsReply *uint8
	Pgn *uint32
}
func (p IsoTransportProtocolConnectionManagementRequestToSend ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoTransportProtocolConnectionManagementRequestToSend\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoTransportProtocolConnectionManagementRequestToSend ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.MessageSize, 16, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Packets, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.PacketsReply, 8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoTransportProtocolConnectionManagementRequestToSend(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoTransportProtocolConnectionManagementRequestToSend
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-GroupFunctionCode: %w", err)
	} else {
		if v != 16 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementRequestToSend-GroupFunctionCode: Expected %d != %d", 16, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-MessageSize: %w", err)
	} else {
		val.MessageSize = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-Packets: %w", err)
	} else {
		val.Packets = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-PacketsReply: %w", err)
	} else {
		val.PacketsReply = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementRequestToSend-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementClearToSend struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	MaxPackets *uint8
	NextSid *uint8
	Pgn *uint32
}
func (p IsoTransportProtocolConnectionManagementClearToSend ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoTransportProtocolConnectionManagementClearToSend\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoTransportProtocolConnectionManagementClearToSend ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.MaxPackets, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NextSid, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoTransportProtocolConnectionManagementClearToSend(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoTransportProtocolConnectionManagementClearToSend
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-GroupFunctionCode: %w", err)
	} else {
		if v != 17 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementClearToSend-GroupFunctionCode: Expected %d != %d", 17, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-MaxPackets: %w", err)
	} else {
		val.MaxPackets = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-NextSid: %w", err)
	} else {
		val.NextSid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementClearToSend-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementEndOfMessage struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	TotalMessageSize *uint16
	TotalNumberOfFramesReceived *uint8
	Pgn *uint32
}
func (p IsoTransportProtocolConnectionManagementEndOfMessage ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoTransportProtocolConnectionManagementEndOfMessage\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoTransportProtocolConnectionManagementEndOfMessage ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.TotalMessageSize, 16, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.TotalNumberOfFramesReceived, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoTransportProtocolConnectionManagementEndOfMessage(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoTransportProtocolConnectionManagementEndOfMessage
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-GroupFunctionCode: %w", err)
	} else {
		if v != 19 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementEndOfMessage-GroupFunctionCode: Expected %d != %d", 19, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-TotalMessageSize: %w", err)
	} else {
		val.TotalMessageSize = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-TotalNumberOfFramesReceived: %w", err)
	} else {
		val.TotalNumberOfFramesReceived = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementEndOfMessage-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementBroadcastAnnounce struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	MessageSize *uint16
	Packets *uint8
	Pgn *uint32
}
func (p IsoTransportProtocolConnectionManagementBroadcastAnnounce ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoTransportProtocolConnectionManagementBroadcastAnnounce\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoTransportProtocolConnectionManagementBroadcastAnnounce ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.MessageSize, 16, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Packets, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoTransportProtocolConnectionManagementBroadcastAnnounce(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoTransportProtocolConnectionManagementBroadcastAnnounce
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-GroupFunctionCode: %w", err)
	} else {
		if v != 32 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-GroupFunctionCode: Expected %d != %d", 32, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-MessageSize: %w", err)
	} else {
		val.MessageSize = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-Packets: %w", err)
	} else {
		val.Packets = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementBroadcastAnnounce-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoTransportProtocolConnectionManagementAbort struct {
	Info MessageInfo
	GroupFunctionCode IsoCommandConst
	Reason []uint8
	Pgn *uint32
}
func (p IsoTransportProtocolConnectionManagementAbort ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoTransportProtocolConnectionManagementAbort\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoTransportProtocolConnectionManagementAbort ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.GroupFunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.Reason, 8, 8 )
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(24, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoTransportProtocolConnectionManagementAbort(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoTransportProtocolConnectionManagementAbort
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-GroupFunctionCode: %w", err)
	} else {
		if v != 255 {
			return nil, fmt.Errorf("match failed for IsoTransportProtocolConnectionManagementAbort-GroupFunctionCode: Expected %d != %d", 255, v)
		}
		val.GroupFunctionCode = IsoCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-Reason: %w", err)
	} else {
		val.Reason = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for IsoTransportProtocolConnectionManagementAbort-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoAddressClaim struct {
	Info MessageInfo
	UniqueNumber *uint32
	ManufacturerCode ManufacturerCodeConst
	DeviceInstanceLower *uint8
	DeviceInstanceUpper *uint8
	DeviceFunction DeviceFunctionConst
	DeviceClass DeviceClassConst
	SystemInstance *uint8
	IndustryGroup IndustryCodeConst
	ArbitraryAddressCapable *uint8
}
func (p IsoAddressClaim ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoAddressClaim\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoAddressClaim ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint32(p.UniqueNumber, 21, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 21)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DeviceInstanceLower, 3, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DeviceInstanceUpper, 5, 35)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DeviceFunction), 8, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(1, 48)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DeviceClass), 7, 49)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SystemInstance, 4, 56)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryGroup), 3, 60)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.ArbitraryAddressCapable, 1, 63)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoAddressClaim(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoAddressClaim
	val.Info = Info
	if v, err := stream.readUInt32(21); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-UniqueNumber: %w", err)
	} else {
		val.UniqueNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(3); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceInstanceLower: %w", err)
	} else {
		val.DeviceInstanceLower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(5); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceInstanceUpper: %w", err)
	} else {
		val.DeviceInstanceUpper = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceFunction: %w", err)
	} else {
		val.DeviceFunction = DeviceFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(7); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-DeviceClass: %w", err)
	} else {
		val.DeviceClass = DeviceClassConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-SystemInstance: %w", err)
	} else {
		val.SystemInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-IndustryGroup: %w", err)
	} else {
		val.IndustryGroup = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(1); err != nil {
		return nil, fmt.Errorf("parse failed for IsoAddressClaim-ArbitraryAddressCapable: %w", err)
	} else {
		val.ArbitraryAddressCapable = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Bus1PhaseCBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
}
func (p Bus1PhaseCBasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Bus1PhaseCBasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Bus1PhaseCBasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeBus1PhaseCBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val Bus1PhaseCBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseCBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Bus1PhaseBBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
}
func (p Bus1PhaseBBasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Bus1PhaseBBasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Bus1PhaseBBasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeBus1PhaseBBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val Bus1PhaseBBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseBBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Bus1PhaseABasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
}
func (p Bus1PhaseABasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Bus1PhaseABasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Bus1PhaseABasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeBus1PhaseABasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val Bus1PhaseABasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Bus1PhaseABasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityPhaseCAcReactivePower struct {
	Info MessageInfo
	ReactivePower *uint16
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func (p UtilityPhaseCAcReactivePower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseCAcReactivePower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseCAcReactivePower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.ReactivePower, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(30, 34)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseCAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseCAcReactivePower
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(30)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityPhaseCAcPower struct {
	Info MessageInfo
	RealPower *float32
	ApparentPower *float32
}
func (p UtilityPhaseCAcPower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseCAcPower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseCAcPower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseCAcPower(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseCAcPower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseCBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func (p UtilityPhaseCBasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseCBasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseCBasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseCBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseCBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseCBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseBAcReactivePower struct {
	Info MessageInfo
	ReactivePower *uint16
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func (p UtilityPhaseBAcReactivePower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseBAcReactivePower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseBAcReactivePower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.ReactivePower, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(30, 34)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseBAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseBAcReactivePower
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(30)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityPhaseBAcPower struct {
	Info MessageInfo
	RealPower *float32
	ApparentPower *float32
}
func (p UtilityPhaseBAcPower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseBAcPower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseBAcPower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseBAcPower(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseBAcPower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseBBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func (p UtilityPhaseBBasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseBBasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseBBasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseBBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseBBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseBBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseAAcReactivePower struct {
	Info MessageInfo
	ReactivePower *float32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func (p UtilityPhaseAAcReactivePower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseAAcReactivePower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseAAcReactivePower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(14, 50)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseAAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseAAcReactivePower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityPhaseAAcPower struct {
	Info MessageInfo
	RealPower *float32
	ApparentPower *float32
}
func (p UtilityPhaseAAcPower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseAAcPower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseAAcPower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseAAcPower(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseAAcPower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseAAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityPhaseABasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func (p UtilityPhaseABasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityPhaseABasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityPhaseABasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityPhaseABasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityPhaseABasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityPhaseABasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityTotalAcReactivePower struct {
	Info MessageInfo
	ReactivePower *float32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func (p UtilityTotalAcReactivePower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityTotalAcReactivePower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityTotalAcReactivePower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(14, 50)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityTotalAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityTotalAcReactivePower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type UtilityTotalAcPower struct {
	Info MessageInfo
	RealPower *float32
	ApparentPower *float32
}
func (p UtilityTotalAcPower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityTotalAcPower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityTotalAcPower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityTotalAcPower(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityTotalAcPower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityTotalAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UtilityAverageBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func (p UtilityAverageBasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UtilityAverageBasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UtilityAverageBasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUtilityAverageBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val UtilityAverageBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for UtilityAverageBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseCAcReactivePower struct {
	Info MessageInfo
	ReactivePower *float32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func (p GeneratorPhaseCAcReactivePower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseCAcReactivePower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseCAcReactivePower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(14, 50)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseCAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseCAcReactivePower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GeneratorPhaseCAcPower struct {
	Info MessageInfo
	RealPower *float32
	ApparentPower *float32
}
func (p GeneratorPhaseCAcPower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseCAcPower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseCAcPower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseCAcPower(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseCAcPower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseCBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func (p GeneratorPhaseCBasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseCBasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseCBasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseCBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseCBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseCBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseBAcReactivePower struct {
	Info MessageInfo
	ReactivePower *float32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func (p GeneratorPhaseBAcReactivePower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseBAcReactivePower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseBAcReactivePower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(14, 50)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseBAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseBAcReactivePower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GeneratorPhaseBAcPower struct {
	Info MessageInfo
	RealPower *float32
	ApparentPower *float32
}
func (p GeneratorPhaseBAcPower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseBAcPower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseBAcPower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseBAcPower(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseBAcPower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseBBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func (p GeneratorPhaseBBasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseBBasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseBBasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseBBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseBBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseBBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseAAcReactivePower struct {
	Info MessageInfo
	ReactivePower *float32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func (p GeneratorPhaseAAcReactivePower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseAAcReactivePower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseAAcReactivePower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(14, 50)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseAAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseAAcReactivePower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GeneratorPhaseAAcPower struct {
	Info MessageInfo
	RealPower *float32
	ApparentPower *float32
}
func (p GeneratorPhaseAAcPower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseAAcPower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseAAcPower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseAAcPower(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseAAcPower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseAAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorPhaseABasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func (p GeneratorPhaseABasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorPhaseABasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorPhaseABasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorPhaseABasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorPhaseABasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorPhaseABasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorTotalAcReactivePower struct {
	Info MessageInfo
	ReactivePower *float32
	PowerFactor *float32
	PowerFactorLagging PowerFactorConst
}
func (p GeneratorTotalAcReactivePower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorTotalAcReactivePower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorTotalAcReactivePower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.ReactivePower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PowerFactor, 16, 6.10352e-05, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerFactorLagging), 2, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(14, 50)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorTotalAcReactivePower(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorTotalAcReactivePower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-ReactivePower: %w", err)
	} else {
		val.ReactivePower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 6.10352e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-PowerFactor: %w", err)
	} else {
		val.PowerFactor = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcReactivePower-PowerFactorLagging: %w", err)
	} else {
		val.PowerFactorLagging = PowerFactorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(14)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GeneratorTotalAcPower struct {
	Info MessageInfo
	RealPower *float32
	ApparentPower *float32
}
func (p GeneratorTotalAcPower ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorTotalAcPower\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorTotalAcPower ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution32(p.RealPower, 32, 1, 0, -2000000000)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ApparentPower, 32, 1, 32, -2000000000)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorTotalAcPower(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorTotalAcPower
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcPower-RealPower: %w", err)
	} else {
		val.RealPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 1, -2000000000); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorTotalAcPower-ApparentPower: %w", err)
	} else {
		val.ApparentPower = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GeneratorAverageBasicAcQuantities struct {
	Info MessageInfo
	LineLineAcRmsVoltage *uint16
	LineNeutralAcRmsVoltage *uint16
	AcFrequency *float32
	AcRmsCurrent *uint16
}
func (p GeneratorAverageBasicAcQuantities ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GeneratorAverageBasicAcQuantities\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GeneratorAverageBasicAcQuantities ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.LineLineAcRmsVoltage, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.LineNeutralAcRmsVoltage, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcFrequency, 16, 0.0078125, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AcRmsCurrent, 16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGeneratorAverageBasicAcQuantities(Info MessageInfo, stream *DataStream) (any, error) {
	var val GeneratorAverageBasicAcQuantities
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-LineLineAcRmsVoltage: %w", err)
	} else {
		val.LineLineAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-LineNeutralAcRmsVoltage: %w", err)
	} else {
		val.LineNeutralAcRmsVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0078125, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-AcFrequency: %w", err)
	} else {
		val.AcFrequency = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GeneratorAverageBasicAcQuantities-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type IsoCommandedAddress struct {
	Info MessageInfo
	UniqueNumber []uint8
	ManufacturerCode ManufacturerCodeConst
	DeviceInstanceLower *uint8
	DeviceInstanceUpper *uint8
	DeviceFunction DeviceFunctionConst
	DeviceClass DeviceClassConst
	SystemInstance *uint8
	IndustryCode IndustryCodeConst
	NewSourceAddress *uint8
}
func (p IsoCommandedAddress ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"IsoCommandedAddress\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p IsoCommandedAddress ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeBinary(p.UniqueNumber, 21, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 21)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DeviceInstanceLower, 3, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DeviceInstanceUpper, 5, 35)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DeviceFunction), 8, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(1, 48)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DeviceClass), 7, 49)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SystemInstance, 4, 56)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 60)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(1, 63)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NewSourceAddress, 8, 64)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeIsoCommandedAddress(Info MessageInfo, stream *DataStream) (any, error) {
	var val IsoCommandedAddress
	val.Info = Info
	if v, err := stream.readBinaryData(21); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-UniqueNumber: %w", err)
	} else {
		val.UniqueNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(3); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceInstanceLower: %w", err)
	} else {
		val.DeviceInstanceLower = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(5); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceInstanceUpper: %w", err)
	} else {
		val.DeviceInstanceUpper = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceFunction: %w", err)
	} else {
		val.DeviceFunction = DeviceFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(7); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-DeviceClass: %w", err)
	} else {
		val.DeviceClass = DeviceClassConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-SystemInstance: %w", err)
	} else {
		val.SystemInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for IsoCommandedAddress-NewSourceAddress: %w", err)
	} else {
		val.NewSourceAddress = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MaretronProprietaryDcBreakerCurrent struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	BankInstance *uint8
	IndicatorNumber *uint8
	BreakerCurrent *float32
}
func (p MaretronProprietaryDcBreakerCurrent ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"MaretronProprietaryDcBreakerCurrent\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p MaretronProprietaryDcBreakerCurrent ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.BankInstance, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.IndicatorNumber, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.BreakerCurrent, 16, 0.1, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeMaretronProprietaryDcBreakerCurrent(Info MessageInfo, stream *DataStream) (any, error) {
	var val MaretronProprietaryDcBreakerCurrent
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronProprietaryDcBreakerCurrent-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronProprietaryDcBreakerCurrent-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-BankInstance: %w", err)
	} else {
		val.BankInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-IndicatorNumber: %w", err)
	} else {
		val.IndicatorNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryDcBreakerCurrent-BreakerCurrent: %w", err)
	} else {
		val.BreakerCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarBootStateAcknowledgment struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	BootState BootStateConst
}
func (p AirmarBootStateAcknowledgment ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarBootStateAcknowledgment\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarBootStateAcknowledgment ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.BootState), 3, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(45, 19)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarBootStateAcknowledgment(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarBootStateAcknowledgment
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarBootStateAcknowledgment-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarBootStateAcknowledgment-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateAcknowledgment-BootState: %w", err)
	} else {
		val.BootState = BootStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(45)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LowranceTemperature struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	TemperatureSource TemperatureSourceConst
	ActualTemperature *units.Temperature
}
func (p LowranceTemperature ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"LowranceTemperature\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p LowranceTemperature ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TemperatureSource), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.ActualTemperature, 16, 0.010000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeLowranceTemperature(Info MessageInfo, stream *DataStream) (any, error) {
	var val LowranceTemperature
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceTemperature-ManufacturerCode: %w", err)
	} else {
		if v != 140 {
			return nil, fmt.Errorf("match failed for LowranceTemperature-ManufacturerCode: Expected %d != %d", 140, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceTemperature-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for LowranceTemperature-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceTemperature-TemperatureSource: %w", err)
	} else {
		val.TemperatureSource = TemperatureSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for LowranceTemperature-ActualTemperature: %w", err)
	} else {
		val.ActualTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarBootStateRequest struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
}
func (p AirmarBootStateRequest ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarBootStateRequest\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarBootStateRequest ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(48, 16)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarBootStateRequest(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarBootStateRequest
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateRequest-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarBootStateRequest-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarBootStateRequest-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarBootStateRequest-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(48)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarAccessLevel struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	FormatCode *uint8
	AccessLevel AccessLevelConst
	AccessSeedKey *uint32
}
func (p AirmarAccessLevel ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarAccessLevel\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarAccessLevel ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.FormatCode, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AccessLevel), 3, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(5, 27)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.AccessSeedKey, 32, 32)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarAccessLevel(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarAccessLevel
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarAccessLevel-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarAccessLevel-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-FormatCode: %w", err)
	} else {
		val.FormatCode = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-AccessLevel: %w", err)
	} else {
		val.AccessLevel = AccessLevelConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAccessLevel-AccessSeedKey: %w", err)
	} else {
		val.AccessSeedKey = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SimnetDeviceStatus struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Model SimnetDeviceModelConst
	Report SimnetDeviceReportConst
	Status SimnetApStatusConst
}
func (p SimnetDeviceStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SimnetDeviceStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SimnetDeviceStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Model), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Report), 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Status), 8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSimnetDeviceStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val SimnetDeviceStatus
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetDeviceStatus-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetDeviceStatus-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-Model: %w", err)
	} else {
		val.Model = SimnetDeviceModelConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-Report: %w", err)
	} else {
		if v != 2 {
			return nil, fmt.Errorf("match failed for SimnetDeviceStatus-Report: Expected %d != %d", 2, v)
		}
		val.Report = SimnetDeviceReportConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatus-Status: %w", err)
	} else {
		val.Status = SimnetApStatusConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetDeviceStatusRequest struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Model SimnetDeviceModelConst
	Report SimnetDeviceReportConst
}
func (p SimnetDeviceStatusRequest ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SimnetDeviceStatusRequest\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SimnetDeviceStatusRequest ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Model), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Report), 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(32, 32)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSimnetDeviceStatusRequest(Info MessageInfo, stream *DataStream) (any, error) {
	var val SimnetDeviceStatusRequest
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatusRequest-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetDeviceStatusRequest-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatusRequest-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetDeviceStatusRequest-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatusRequest-Model: %w", err)
	} else {
		val.Model = SimnetDeviceModelConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceStatusRequest-Report: %w", err)
	} else {
		if v != 3 {
			return nil, fmt.Errorf("match failed for SimnetDeviceStatusRequest-Report: Expected %d != %d", 3, v)
		}
		val.Report = SimnetDeviceReportConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetPilotMode struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Model SimnetDeviceModelConst
	Report SimnetDeviceReportConst
	Mode SimnetApModeBitfieldConst
}
func (p SimnetPilotMode ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SimnetPilotMode\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SimnetPilotMode ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Model), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Report), 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Mode), 16, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSimnetPilotMode(Info MessageInfo, stream *DataStream) (any, error) {
	var val SimnetPilotMode
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPilotMode-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetPilotMode-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPilotMode-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetPilotMode-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPilotMode-Model: %w", err)
	} else {
		val.Model = SimnetDeviceModelConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPilotMode-Report: %w", err)
	} else {
		if v != 10 {
			return nil, fmt.Errorf("match failed for SimnetPilotMode-Report: Expected %d != %d", 10, v)
		}
		val.Report = SimnetDeviceReportConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(16); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetPilotMode-Mode: %w", err)
	} else {
		val.Mode = SimnetApModeBitfieldConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SimnetDeviceModeRequest struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Model SimnetDeviceModelConst
	Report SimnetDeviceReportConst
}
func (p SimnetDeviceModeRequest ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SimnetDeviceModeRequest\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SimnetDeviceModeRequest ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Model), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Report), 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(32, 32)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSimnetDeviceModeRequest(Info MessageInfo, stream *DataStream) (any, error) {
	var val SimnetDeviceModeRequest
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceModeRequest-ManufacturerCode: %w", err)
	} else {
		if v != 1857 {
			return nil, fmt.Errorf("match failed for SimnetDeviceModeRequest-ManufacturerCode: Expected %d != %d", 1857, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceModeRequest-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SimnetDeviceModeRequest-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceModeRequest-Model: %w", err)
	} else {
		val.Model = SimnetDeviceModelConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SimnetDeviceModeRequest-Report: %w", err)
	} else {
		if v != 11 {
			return nil, fmt.Errorf("match failed for SimnetDeviceModeRequest-Report: Expected %d != %d", 11, v)
		}
		val.Report = SimnetDeviceReportConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkPilotLockedHeading struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid []uint8
	TargetHeadingTrue *float32
	TargetHeadingMagnetic *float32
}
func (p SeatalkPilotLockedHeading ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SeatalkPilotLockedHeading\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SeatalkPilotLockedHeading ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.Sid, 8, 16 )
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.TargetHeadingTrue, 16, 0.0001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.TargetHeadingMagnetic, 16, 0.0001, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSeatalkPilotLockedHeading(Info MessageInfo, stream *DataStream) (any, error) {
	var val SeatalkPilotLockedHeading
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkPilotLockedHeading-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkPilotLockedHeading-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-TargetHeadingTrue: %w", err)
	} else {
		val.TargetHeadingTrue = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkPilotLockedHeading-TargetHeadingMagnetic: %w", err)
	} else {
		val.TargetHeadingMagnetic = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SeatalkSilenceAlarm struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	AlarmId SeatalkAlarmIdConst
	AlarmGroup SeatalkAlarmGroupConst
}
func (p SeatalkSilenceAlarm ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SeatalkSilenceAlarm\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SeatalkSilenceAlarm ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AlarmId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AlarmGroup), 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(32, 32)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSeatalkSilenceAlarm(Info MessageInfo, stream *DataStream) (any, error) {
	var val SeatalkSilenceAlarm
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-ManufacturerCode: %w", err)
	} else {
		if v != 1851 {
			return nil, fmt.Errorf("match failed for SeatalkSilenceAlarm-ManufacturerCode: Expected %d != %d", 1851, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SeatalkSilenceAlarm-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-AlarmId: %w", err)
	} else {
		val.AlarmId = SeatalkAlarmIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SeatalkSilenceAlarm-AlarmGroup: %w", err)
	} else {
		val.AlarmGroup = SeatalkAlarmGroupConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarSpeedPulseCount struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid *uint8
	DurationOfInterval *float32
	NumberOfPulsesReceived *uint16
}
func (p AirmarSpeedPulseCount ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarSpeedPulseCount\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarSpeedPulseCount ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Sid, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.DurationOfInterval, 16, 0.001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.NumberOfPulsesReceived, 16, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarSpeedPulseCount(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarSpeedPulseCount
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarSpeedPulseCount-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarSpeedPulseCount-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-DurationOfInterval: %w", err)
	} else {
		val.DurationOfInterval = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedPulseCount-NumberOfPulsesReceived: %w", err)
	} else {
		val.NumberOfPulsesReceived = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type NmeaRequestGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	TransmissionInterval *float32
	TransmissionIntervalOffset *float32
	NumberOfParameters *uint8
	Repeating1 []NmeaRequestGroupFunctionRepeating1
}
type NmeaRequestGroupFunctionRepeating1 struct {
	Parameter *uint8
	Value []uint8
}
func (p NmeaRequestGroupFunction ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint8(p.Repeating1[index].Parameter, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating1[index].Value, 0, 0 )
	if err != nil {
		return err
	}
	}
	return nil
}
func (p NmeaRequestGroupFunction ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"NmeaRequestGroupFunction\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p NmeaRequestGroupFunction ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.TransmissionInterval, 32, 0.001, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.TransmissionIntervalOffset, 16, 0.01, 64, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfParameters, 8, 80)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeNmeaRequestGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
	var val NmeaRequestGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var fieldIndex uint8
		var manufacturer ManufacturerCodeConst
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 0 {
			return nil, fmt.Errorf("match failed for NmeaRequestGroupFunction-FunctionCode: Expected %d != %d", 0, v)
		}
		val.FunctionCode = GroupFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-TransmissionInterval: %w", err)
	} else {
		val.TransmissionInterval = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-TransmissionIntervalOffset: %w", err)
	} else {
		val.TransmissionIntervalOffset = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaRequestGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaRequestGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, manufacturer, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaRequestGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaCommandGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	Priority PriorityConst
	NumberOfParameters *uint8
	Repeating1 []NmeaCommandGroupFunctionRepeating1
}
type NmeaCommandGroupFunctionRepeating1 struct {
	Parameter *uint8
	Value []uint8
}
func (p NmeaCommandGroupFunction ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint8(p.Repeating1[index].Parameter, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating1[index].Value, 0, 0 )
	if err != nil {
		return err
	}
	}
	return nil
}
func (p NmeaCommandGroupFunction ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"NmeaCommandGroupFunction\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p NmeaCommandGroupFunction ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Priority), 4, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 36)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfParameters, 8, 40)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeNmeaCommandGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
	var val NmeaCommandGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var fieldIndex uint8
		var manufacturer ManufacturerCodeConst
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 1 {
			return nil, fmt.Errorf("match failed for NmeaCommandGroupFunction-FunctionCode: Expected %d != %d", 1, v)
		}
		val.FunctionCode = GroupFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Priority: %w", err)
	} else {
		val.Priority = PriorityConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaCommandGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaCommandGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, manufacturer, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaCommandGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaAcknowledgeGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	PgnErrorCode PgnErrorCodeConst
	TransmissionIntervalPriorityErrorCode TransmissionIntervalConst
	NumberOfParameters *uint8
	Repeating1 []NmeaAcknowledgeGroupFunctionRepeating1
}
type NmeaAcknowledgeGroupFunctionRepeating1 struct {
	Parameter ParameterFieldConst
}
func (p NmeaAcknowledgeGroupFunction ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.putNumberRaw(uint64(p.Repeating1[index].Parameter), 4, 0)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p NmeaAcknowledgeGroupFunction ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"NmeaAcknowledgeGroupFunction\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p NmeaAcknowledgeGroupFunction ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PgnErrorCode), 4, 32)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TransmissionIntervalPriorityErrorCode), 4, 36)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfParameters, 8, 40)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeNmeaAcknowledgeGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
	var val NmeaAcknowledgeGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 2 {
			return nil, fmt.Errorf("match failed for NmeaAcknowledgeGroupFunction-FunctionCode: Expected %d != %d", 2, v)
		}
		val.FunctionCode = GroupFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-PgnErrorCode: %w", err)
	} else {
		val.PgnErrorCode = PgnErrorCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-TransmissionIntervalPriorityErrorCode: %w", err)
	} else {
		val.TransmissionIntervalPriorityErrorCode = TransmissionIntervalConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaAcknowledgeGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaAcknowledgeGroupFunctionRepeating1
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaAcknowledgeGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = ParameterFieldConst(v)
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaReadFieldsReplyGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	UniqueId *uint8
	NumberOfSelectionPairs *uint8
	NumberOfParameters *uint8
	Repeating1 []NmeaReadFieldsReplyGroupFunctionRepeating1
	Repeating2 []NmeaReadFieldsReplyGroupFunctionRepeating2
}
type NmeaReadFieldsReplyGroupFunctionRepeating1 struct {
	SelectionParameter *uint8
	SelectionValue []uint8
}
func (p NmeaReadFieldsReplyGroupFunction ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint8(p.Repeating1[index].SelectionParameter, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating1[index].SelectionValue, 0, 0 )
	if err != nil {
		return err
	}
	}
	return nil
}
type NmeaReadFieldsReplyGroupFunctionRepeating2 struct {
	Parameter *uint8
	Value []uint8
}

func (p NmeaReadFieldsReplyGroupFunction ) encodeRepeating2(stream *DataStream) error {
	var err error
	for index := range p.Repeating2 {
	err = stream.writeUint8(p.Repeating2[index].Parameter, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating2[index].Value, 0, 0 )
	if err != nil {
		return err
	}
	}
	return nil
}
func (p NmeaReadFieldsReplyGroupFunction ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"NmeaReadFieldsReplyGroupFunction\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p NmeaReadFieldsReplyGroupFunction ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 8)
	if err != nil {
		return nil, err
	}	
	if (p.Pgn != nil) && IsProprietaryPGN(*p.Pgn) {
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 0)
	if err != nil {
		return nil, err
	}
	}
	err = stream.writeUint8(p.UniqueId, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfSelectionPairs, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfParameters, 8, 0)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	err = p.encodeRepeating2(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeNmeaReadFieldsReplyGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
	var val NmeaReadFieldsReplyGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var repeat2Count uint16
		var fieldIndex uint8
		var manufacturer ManufacturerCodeConst
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for NmeaReadFieldsReplyGroupFunction-FunctionCode: Expected %d != %d", 4, v)
		}
		val.FunctionCode = GroupFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if (val.Pgn != nil) && IsProprietaryPGN( *val.Pgn) {
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-UniqueId: %w", err)
	} else {
		val.UniqueId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-NumberOfSelectionPairs: %w", err)
	} else {
		val.NumberOfSelectionPairs = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat2Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaReadFieldsReplyGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaReadFieldsReplyGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-SelectionParameter: %w", err)
		} else {
			rep.SelectionParameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, manufacturer, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-SelectionValue: %w", err)
		} else {
			rep.SelectionValue = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaReadFieldsReplyGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaReadFieldsReplyGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, manufacturer, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaReadFieldsReplyGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaWriteFieldsGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	UniqueId *uint8
	NumberOfSelectionPairs *uint8
	NumberOfParameters *uint8
	Repeating1 []NmeaWriteFieldsGroupFunctionRepeating1
	Repeating2 []NmeaWriteFieldsGroupFunctionRepeating2
}
type NmeaWriteFieldsGroupFunctionRepeating1 struct {
	SelectionParameter *uint8
	SelectionValue []uint8
}
func (p NmeaWriteFieldsGroupFunction ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint8(p.Repeating1[index].SelectionParameter, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating1[index].SelectionValue, 0, 0 )
	if err != nil {
		return err
	}
	}
	return nil
}
type NmeaWriteFieldsGroupFunctionRepeating2 struct {
	Parameter *uint8
	Value []uint8
}

func (p NmeaWriteFieldsGroupFunction ) encodeRepeating2(stream *DataStream) error {
	var err error
	for index := range p.Repeating2 {
	err = stream.writeUint8(p.Repeating2[index].Parameter, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating2[index].Value, 0, 0 )
	if err != nil {
		return err
	}
	}
	return nil
}
func (p NmeaWriteFieldsGroupFunction ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"NmeaWriteFieldsGroupFunction\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p NmeaWriteFieldsGroupFunction ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 8)
	if err != nil {
		return nil, err
	}	
	if (p.Pgn != nil) && IsProprietaryPGN(*p.Pgn) {
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 0)
	if err != nil {
		return nil, err
	}
	}
	err = stream.writeUint8(p.UniqueId, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfSelectionPairs, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfParameters, 8, 0)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	err = p.encodeRepeating2(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeNmeaWriteFieldsGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
	var val NmeaWriteFieldsGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var repeat2Count uint16
		var fieldIndex uint8
		var manufacturer ManufacturerCodeConst
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 5 {
			return nil, fmt.Errorf("match failed for NmeaWriteFieldsGroupFunction-FunctionCode: Expected %d != %d", 5, v)
		}
		val.FunctionCode = GroupFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if (val.Pgn != nil) && IsProprietaryPGN( *val.Pgn) {
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-UniqueId: %w", err)
	} else {
		val.UniqueId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-NumberOfSelectionPairs: %w", err)
	} else {
		val.NumberOfSelectionPairs = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat2Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaWriteFieldsGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaWriteFieldsGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-SelectionParameter: %w", err)
		} else {
			rep.SelectionParameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, manufacturer, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-SelectionValue: %w", err)
		} else {
			rep.SelectionValue = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaWriteFieldsGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaWriteFieldsGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, manufacturer, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type NmeaWriteFieldsReplyGroupFunction struct {
	Info MessageInfo
	FunctionCode GroupFunctionConst
	Pgn *uint32
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	UniqueId *uint8
	NumberOfSelectionPairs *uint8
	NumberOfParameters *uint8
	Repeating1 []NmeaWriteFieldsReplyGroupFunctionRepeating1
	Repeating2 []NmeaWriteFieldsReplyGroupFunctionRepeating2
}
type NmeaWriteFieldsReplyGroupFunctionRepeating1 struct {
	SelectionParameter *uint8
	SelectionValue []uint8
}
func (p NmeaWriteFieldsReplyGroupFunction ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint8(p.Repeating1[index].SelectionParameter, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating1[index].SelectionValue, 0, 0 )
	if err != nil {
		return err
	}
	}
	return nil
}
type NmeaWriteFieldsReplyGroupFunctionRepeating2 struct {
	Parameter *uint8
	Value []uint8
}

func (p NmeaWriteFieldsReplyGroupFunction ) encodeRepeating2(stream *DataStream) error {
	var err error
	for index := range p.Repeating2 {
	err = stream.writeUint8(p.Repeating2[index].Parameter, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating2[index].Value, 0, 0 )
	if err != nil {
		return err
	}
	}
	return nil
}
func (p NmeaWriteFieldsReplyGroupFunction ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"NmeaWriteFieldsReplyGroupFunction\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p NmeaWriteFieldsReplyGroupFunction ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.Pgn, 24, 8)
	if err != nil {
		return nil, err
	}	
	if (p.Pgn != nil) && IsProprietaryPGN(*p.Pgn) {
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 0)
	if err != nil {
		return nil, err
	}
	}
	err = stream.writeUint8(p.UniqueId, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfSelectionPairs, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfParameters, 8, 0)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	err = p.encodeRepeating2(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeNmeaWriteFieldsReplyGroupFunction(Info MessageInfo, stream *DataStream) (any, error) {
	var val NmeaWriteFieldsReplyGroupFunction
	val.Info = Info
		var repeat1Count uint16 = 0
		var repeat2Count uint16
		var fieldIndex uint8
		var manufacturer ManufacturerCodeConst
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-FunctionCode: %w", err)
	} else {
		if v != 6 {
			return nil, fmt.Errorf("match failed for NmeaWriteFieldsReplyGroupFunction-FunctionCode: Expected %d != %d", 6, v)
		}
		val.FunctionCode = GroupFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(24); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Pgn: %w", err)
	} else {
		val.Pgn = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if (val.Pgn != nil) && IsProprietaryPGN( *val.Pgn) {
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-ManufacturerCode: %w", err)
	} else {
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-IndustryCode: %w", err)
	} else {
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-UniqueId: %w", err)
	} else {
		val.UniqueId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-NumberOfSelectionPairs: %w", err)
	} else {
		val.NumberOfSelectionPairs = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-NumberOfParameters: %w", err)
	} else {
		val.NumberOfParameters = v
		if v != nil {
			repeat2Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NmeaWriteFieldsReplyGroupFunctionRepeating1, 0)
	i := 0 
	for {
		var rep NmeaWriteFieldsReplyGroupFunctionRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-SelectionParameter: %w", err)
		} else {
			rep.SelectionParameter = v
			if v != nil {
				fieldIndex = *v
			}
		}
		if v, err := stream.readVariableData(*val.Pgn, manufacturer, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-SelectionValue: %w", err)
		} else {
			rep.SelectionValue = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}
		if repeat2Count == 0 {
			return val, nil
		}	
	val.Repeating2 = make([]NmeaWriteFieldsReplyGroupFunctionRepeating2, 0)
	i = 0
	for {
		var rep NmeaWriteFieldsReplyGroupFunctionRepeating2
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Parameter: %w", err)
		} else {
			rep.Parameter = v
		}
		if v, err := stream.readVariableData(*val.Pgn, manufacturer, fieldIndex); err != nil {
			return nil, fmt.Errorf("parse failed for NmeaWriteFieldsReplyGroupFunction-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type PgnListTransmitAndReceive struct {
	Info MessageInfo
	FunctionCode PgnListFunctionConst
	Repeating1 []PgnListTransmitAndReceiveRepeating1
}
type PgnListTransmitAndReceiveRepeating1 struct {
	Pgn *uint32
}
func (p PgnListTransmitAndReceive ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint32(p.Repeating1[index].Pgn, 24, 0)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p PgnListTransmitAndReceive ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"PgnListTransmitAndReceive\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p PgnListTransmitAndReceive ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.FunctionCode), 8, 0)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodePgnListTransmitAndReceive(Info MessageInfo, stream *DataStream) (any, error) {
	var val PgnListTransmitAndReceive
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for PgnListTransmitAndReceive-FunctionCode: %w", err)
	} else {
		val.FunctionCode = PgnListFunctionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	val.Repeating1 = make([]PgnListTransmitAndReceiveRepeating1, 0)
	i := 0 
	for {
		var rep PgnListTransmitAndReceiveRepeating1
		if v, err := stream.readUInt32(24); err != nil {
			return nil, fmt.Errorf("parse failed for PgnListTransmitAndReceive-Pgn: %w", err)
		} else {
			rep.Pgn = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AirmarAttitudeOffset struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	AzimuthOffset *float32
	PitchOffset *float32
	RollOffset *float32
}
func (p AirmarAttitudeOffset ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarAttitudeOffset\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarAttitudeOffset ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.AzimuthOffset, 16, 0.0001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.PitchOffset, 16, 0.0001, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.RollOffset, 16, 0.0001, 56, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarAttitudeOffset(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarAttitudeOffset
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-ProprietaryId: %w", err)
	} else {
		if v != 32 {
			return nil, fmt.Errorf("match failed for AirmarAttitudeOffset-ProprietaryId: Expected %d != %d", 32, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-AzimuthOffset: %w", err)
	} else {
		val.AzimuthOffset = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-PitchOffset: %w", err)
	} else {
		val.PitchOffset = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarAttitudeOffset-RollOffset: %w", err)
	} else {
		val.RollOffset = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarSimulateMode struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	SimulateMode OffOnConst
}
func (p AirmarSimulateMode ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarSimulateMode\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarSimulateMode ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SimulateMode), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(22, 26)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarSimulateMode(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarSimulateMode
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSimulateMode-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarSimulateMode-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSimulateMode-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarSimulateMode-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSimulateMode-ProprietaryId: %w", err)
	} else {
		if v != 35 {
			return nil, fmt.Errorf("match failed for AirmarSimulateMode-ProprietaryId: Expected %d != %d", 35, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSimulateMode-SimulateMode: %w", err)
	} else {
		val.SimulateMode = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(22)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarCalibrateDepth struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	SpeedOfSoundMode *units.Velocity
}
func (p AirmarCalibrateDepth ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarCalibrateDepth\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarCalibrateDepth ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SpeedOfSoundMode, 16, 0.100000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarCalibrateDepth(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarCalibrateDepth
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-ProprietaryId: %w", err)
	} else {
		if v != 40 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateDepth-ProprietaryId: Expected %d != %d", 40, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateDepth-SpeedOfSoundMode: %w", err)
	} else {
		val.SpeedOfSoundMode = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AirmarCalibrateSpeed struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	NumberOfPairsOfDataPoints *uint8
	Repeating1 []AirmarCalibrateSpeedRepeating1
}
type AirmarCalibrateSpeedRepeating1 struct {
	InputFrequency *float32
	OutputSpeed *units.Velocity
}
func (p AirmarCalibrateSpeed ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUnsignedResolution32(p.Repeating1[index].InputFrequency, 16, 0.1, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnit(p.Repeating1[index].OutputSpeed, 16, 0.010000, 0, 0, false)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p AirmarCalibrateSpeed ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarCalibrateSpeed\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarCalibrateSpeed ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfPairsOfDataPoints, 8, 24)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeAirmarCalibrateSpeed(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarCalibrateSpeed
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-ProprietaryId: %w", err)
	} else {
		if v != 41 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateSpeed-ProprietaryId: Expected %d != %d", 41, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-NumberOfPairsOfDataPoints: %w", err)
	} else {
		val.NumberOfPairsOfDataPoints = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AirmarCalibrateSpeedRepeating1, 0)
	i := 0 
	for {
		var rep AirmarCalibrateSpeedRepeating1
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-InputFrequency: %w", err)
		} else {
			rep.InputFrequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AirmarCalibrateSpeed-OutputSpeed: %w", err)
		} else {
			rep.OutputSpeed = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AirmarCalibrateTemperature struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	TemperatureInstance AirmarTemperatureInstanceConst
	TemperatureOffset *units.Temperature
}
func (p AirmarCalibrateTemperature ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarCalibrateTemperature\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarCalibrateTemperature ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TemperatureInstance), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 26)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.TemperatureOffset, 16, 0.001000, 32, 0, true)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarCalibrateTemperature(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarCalibrateTemperature
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-ProprietaryId: %w", err)
	} else {
		if v != 42 {
			return nil, fmt.Errorf("match failed for AirmarCalibrateTemperature-ProprietaryId: Expected %d != %d", 42, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-TemperatureInstance: %w", err)
	} else {
		val.TemperatureInstance = AirmarTemperatureInstanceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarCalibrateTemperature-TemperatureOffset: %w", err)
	} else {
		val.TemperatureOffset = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarSpeedFilterNone struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	FilterType *uint8
	SampleInterval *float32
}
func (p AirmarSpeedFilterNone ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarSpeedFilterNone\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarSpeedFilterNone ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.FilterType, 4, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 28)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.SampleInterval, 16, 0.01, 32, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarSpeedFilterNone(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarSpeedFilterNone
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-ProprietaryId: %w", err)
	} else {
		if v != 43 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-ProprietaryId: Expected %d != %d", 43, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-FilterType: %w", err)
	} else {
		if v != nil && *v != 0 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterNone-FilterType: Expected %d != %d", 0, *v)
		}
		val.FilterType = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterNone-SampleInterval: %w", err)
	} else {
		val.SampleInterval = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarSpeedFilterIir struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	FilterType *uint8
	SampleInterval *float32
	FilterDuration *float32
}
func (p AirmarSpeedFilterIir ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarSpeedFilterIir\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarSpeedFilterIir ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.FilterType, 4, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 28)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.SampleInterval, 16, 0.01, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.FilterDuration, 16, 0.01, 48, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarSpeedFilterIir(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarSpeedFilterIir
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-ProprietaryId: %w", err)
	} else {
		if v != 43 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-ProprietaryId: Expected %d != %d", 43, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-FilterType: %w", err)
	} else {
		if v != nil && *v != 1 {
			return nil, fmt.Errorf("match failed for AirmarSpeedFilterIir-FilterType: Expected %d != %d", 1, *v)
		}
		val.FilterType = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-SampleInterval: %w", err)
	} else {
		val.SampleInterval = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarSpeedFilterIir-FilterDuration: %w", err)
	} else {
		val.FilterDuration = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarTemperatureFilterNone struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	FilterType *uint8
	SampleInterval *float32
}
func (p AirmarTemperatureFilterNone ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarTemperatureFilterNone\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarTemperatureFilterNone ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.FilterType, 4, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 28)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.SampleInterval, 16, 0.01, 32, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarTemperatureFilterNone(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarTemperatureFilterNone
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-ProprietaryId: %w", err)
	} else {
		if v != 44 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-ProprietaryId: Expected %d != %d", 44, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-FilterType: %w", err)
	} else {
		if v != nil && *v != 0 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterNone-FilterType: Expected %d != %d", 0, *v)
		}
		val.FilterType = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterNone-SampleInterval: %w", err)
	} else {
		val.SampleInterval = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarTemperatureFilterIir struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	FilterType *uint8
	SampleInterval *float32
	FilterDuration *float32
}
func (p AirmarTemperatureFilterIir ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarTemperatureFilterIir\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarTemperatureFilterIir ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.FilterType, 4, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 28)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.SampleInterval, 16, 0.01, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.FilterDuration, 16, 0.01, 48, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarTemperatureFilterIir(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarTemperatureFilterIir
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-ProprietaryId: %w", err)
	} else {
		if v != 44 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-ProprietaryId: Expected %d != %d", 44, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-FilterType: %w", err)
	} else {
		if v != nil && *v != 1 {
			return nil, fmt.Errorf("match failed for AirmarTemperatureFilterIir-FilterType: Expected %d != %d", 1, *v)
		}
		val.FilterType = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-SampleInterval: %w", err)
	} else {
		val.SampleInterval = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarTemperatureFilterIir-FilterDuration: %w", err)
	} else {
		val.FilterDuration = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AirmarNmea2000Options struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId AirmarCommandConst
	TransmissionInterval AirmarTransmissionIntervalConst
}
func (p AirmarNmea2000Options ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AirmarNmea2000Options\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AirmarNmea2000Options ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TransmissionInterval), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(22, 26)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAirmarNmea2000Options(Info MessageInfo, stream *DataStream) (any, error) {
	var val AirmarNmea2000Options
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-ManufacturerCode: %w", err)
	} else {
		if v != 135 {
			return nil, fmt.Errorf("match failed for AirmarNmea2000Options-ManufacturerCode: Expected %d != %d", 135, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for AirmarNmea2000Options-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-ProprietaryId: %w", err)
	} else {
		if v != 46 {
			return nil, fmt.Errorf("match failed for AirmarNmea2000Options-ProprietaryId: Expected %d != %d", 46, v)
		}
		val.ProprietaryId = AirmarCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AirmarNmea2000Options-TransmissionInterval: %w", err)
	} else {
		val.TransmissionInterval = AirmarTransmissionIntervalConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(22)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type MaretronSlaveResponse struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProductCode *uint16
	SoftwareCode *uint16
	Command *uint8
	Status *uint8
}
func (p MaretronSlaveResponse ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"MaretronSlaveResponse\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p MaretronSlaveResponse ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.ProductCode, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.SoftwareCode, 16, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Command, 8, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Status, 8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeMaretronSlaveResponse(Info MessageInfo, stream *DataStream) (any, error) {
	var val MaretronSlaveResponse
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronSlaveResponse-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronSlaveResponse-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-ProductCode: %w", err)
	} else {
		val.ProductCode = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-SoftwareCode: %w", err)
	} else {
		val.SoftwareCode = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-Command: %w", err)
	} else {
		val.Command = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSlaveResponse-Status: %w", err)
	} else {
		val.Status = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Alert struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	TemporarySilenceStatus YesNoConst
	AcknowledgeStatus YesNoConst
	EscalationStatus YesNoConst
	TemporarySilenceSupport YesNoConst
	AcknowledgeSupport YesNoConst
	EscalationSupport YesNoConst
	AcknowledgeSourceNetworkIdName *uint64
	TriggerCondition AlertTriggerConditionConst
	ThresholdStatus AlertThresholdStatusConst
	AlertPriority *uint8
	AlertState AlertStateConst
}
func (p Alert ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Alert\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Alert ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.AlertType), 4, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AlertCategory), 4, 4)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertSystem, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertSubSystem, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AlertId, 16, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint64(p.DataSourceNetworkIdName, 64, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DataSourceInstance, 8, 104)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DataSourceIndexSource, 8, 112)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertOccurrenceNumber, 8, 120)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TemporarySilenceStatus), 1, 128)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AcknowledgeStatus), 1, 129)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.EscalationStatus), 1, 130)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TemporarySilenceSupport), 1, 131)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AcknowledgeSupport), 1, 132)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.EscalationSupport), 1, 133)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 134)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint64(p.AcknowledgeSourceNetworkIdName, 64, 136)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TriggerCondition), 4, 200)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ThresholdStatus), 4, 204)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertPriority, 8, 208)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AlertState), 8, 216)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAlert(Info MessageInfo, stream *DataStream) (any, error) {
	var val Alert
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertId: %w", err)
	} else {
		val.AlertId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-TemporarySilenceStatus: %w", err)
	} else {
		val.TemporarySilenceStatus = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AcknowledgeStatus: %w", err)
	} else {
		val.AcknowledgeStatus = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-EscalationStatus: %w", err)
	} else {
		val.EscalationStatus = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-TemporarySilenceSupport: %w", err)
	} else {
		val.TemporarySilenceSupport = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AcknowledgeSupport: %w", err)
	} else {
		val.AcknowledgeSupport = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-EscalationSupport: %w", err)
	} else {
		val.EscalationSupport = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AcknowledgeSourceNetworkIdName: %w", err)
	} else {
		val.AcknowledgeSourceNetworkIdName = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-TriggerCondition: %w", err)
	} else {
		val.TriggerCondition = AlertTriggerConditionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-ThresholdStatus: %w", err)
	} else {
		val.ThresholdStatus = AlertThresholdStatusConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertPriority: %w", err)
	} else {
		val.AlertPriority = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Alert-AlertState: %w", err)
	} else {
		val.AlertState = AlertStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AlertResponse struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	AcknowledgeSourceNetworkIdName *uint64
	ResponseCommand AlertResponseCommandConst
}
func (p AlertResponse ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AlertResponse\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AlertResponse ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.AlertType), 4, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AlertCategory), 4, 4)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertSystem, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertSubSystem, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AlertId, 16, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint64(p.DataSourceNetworkIdName, 64, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DataSourceInstance, 8, 104)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DataSourceIndexSource, 8, 112)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertOccurrenceNumber, 8, 120)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint64(p.AcknowledgeSourceNetworkIdName, 64, 128)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ResponseCommand), 2, 192)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 194)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAlertResponse(Info MessageInfo, stream *DataStream) (any, error) {
	var val AlertResponse
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertId: %w", err)
	} else {
		val.AlertId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-AcknowledgeSourceNetworkIdName: %w", err)
	} else {
		val.AcknowledgeSourceNetworkIdName = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AlertResponse-ResponseCommand: %w", err)
	} else {
		val.ResponseCommand = AlertResponseCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AlertText struct {
	Info MessageInfo
	AlertType AlertTypeConst
	AlertCategory AlertCategoryConst
	AlertSystem *uint8
	AlertSubSystem *uint8
	AlertId *uint16
	DataSourceNetworkIdName *uint64
	DataSourceInstance *uint8
	DataSourceIndexSource *uint8
	AlertOccurrenceNumber *uint8
	LanguageId AlertLanguageIdConst
	AlertTextDescription string
	AlertLocationTextDescription string
}
func (p AlertText ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AlertText\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AlertText ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.AlertType), 4, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AlertCategory), 4, 4)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertSystem, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertSubSystem, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AlertId, 16, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint64(p.DataSourceNetworkIdName, 64, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DataSourceInstance, 8, 104)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DataSourceIndexSource, 8, 112)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AlertOccurrenceNumber, 8, 120)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.LanguageId), 8, 128)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringLau(p.AlertTextDescription, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringLau(p.AlertLocationTextDescription, 0 )
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAlertText(Info MessageInfo, stream *DataStream) (any, error) {
	var val AlertText
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertType: %w", err)
	} else {
		val.AlertType = AlertTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertCategory: %w", err)
	} else {
		val.AlertCategory = AlertCategoryConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertSystem: %w", err)
	} else {
		val.AlertSystem = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertSubSystem: %w", err)
	} else {
		val.AlertSubSystem = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertId: %w", err)
	} else {
		val.AlertId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt64(64); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-DataSourceNetworkIdName: %w", err)
	} else {
		val.DataSourceNetworkIdName = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-DataSourceInstance: %w", err)
	} else {
		val.DataSourceInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-DataSourceIndexSource: %w", err)
	} else {
		val.DataSourceIndexSource = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertOccurrenceNumber: %w", err)
	} else {
		val.AlertOccurrenceNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-LanguageId: %w", err)
	} else {
		val.LanguageId = AlertLanguageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertTextDescription: %w", err)
	} else {
		val.AlertTextDescription = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for AlertText-AlertLocationTextDescription: %w", err)
	} else {
		val.AlertLocationTextDescription = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SystemTime struct {
	Info MessageInfo
	Sid *uint8
	Source SystemTimeConst
	Date *uint16
	Time *float32
}
func (p SystemTime ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SystemTime\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SystemTime ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Source), 4, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 12)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.Date, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Time, 32, 0.0001, 32, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSystemTime(Info MessageInfo, stream *DataStream) (any, error) {
	var val SystemTime
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SystemTime-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for SystemTime-Source: %w", err)
	} else {
		val.Source = SystemTimeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for SystemTime-Date: %w", err)
	} else {
		val.Date = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for SystemTime-Time: %w", err)
	} else {
		val.Time = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Heartbeat struct {
	Info MessageInfo
	DataTransmitOffset *float32
	SequenceCounter *uint8
	Controller1State ControllerStateConst
	Controller2State ControllerStateConst
	EquipmentStatus EquipmentStatusConst
}
func (p Heartbeat ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Heartbeat\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Heartbeat ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUnsignedResolution32(p.DataTransmitOffset, 16, 0.001, 0, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SequenceCounter, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Controller1State), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Controller2State), 2, 26)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.EquipmentStatus), 2, 28)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(34, 30)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeHeartbeat(Info MessageInfo, stream *DataStream) (any, error) {
	var val Heartbeat
	val.Info = Info
	if v, err := stream.readUnsignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-DataTransmitOffset: %w", err)
	} else {
		val.DataTransmitOffset = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-SequenceCounter: %w", err)
	} else {
		val.SequenceCounter = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-Controller1State: %w", err)
	} else {
		val.Controller1State = ControllerStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-Controller2State: %w", err)
	} else {
		val.Controller2State = ControllerStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for Heartbeat-EquipmentStatus: %w", err)
	} else {
		val.EquipmentStatus = EquipmentStatusConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(34)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ProductInformation struct {
	Info MessageInfo
	Nmea2000Version *float32
	ProductCode *uint16
	ModelId string
	SoftwareVersionCode string
	ModelVersion string
	ModelSerialCode string
	CertificationLevel *uint8
	LoadEquivalency *uint8
}
func (p ProductInformation ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ProductInformation\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ProductInformation ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUnsignedResolution32(p.Nmea2000Version, 16, 0.001, 0, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.ProductCode, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.ModelId), 256, 32 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.SoftwareVersionCode), 256, 288 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.ModelVersion), 256, 544 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.ModelSerialCode), 256, 800 )
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.CertificationLevel, 8, 1056)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.LoadEquivalency, 8, 1064)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeProductInformation(Info MessageInfo, stream *DataStream) (any, error) {
	var val ProductInformation
	val.Info = Info
	if v, err := stream.readUnsignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-Nmea2000Version: %w", err)
	} else {
		val.Nmea2000Version = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-ProductCode: %w", err)
	} else {
		val.ProductCode = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-ModelId: %w", err)
	} else {
		val.ModelId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-SoftwareVersionCode: %w", err)
	} else {
		val.SoftwareVersionCode = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-ModelVersion: %w", err)
	} else {
		val.ModelVersion = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-ModelSerialCode: %w", err)
	} else {
		val.ModelSerialCode = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-CertificationLevel: %w", err)
	} else {
		val.CertificationLevel = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ProductInformation-LoadEquivalency: %w", err)
	} else {
		val.LoadEquivalency = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ConfigurationInformation struct {
	Info MessageInfo
	InstallationDescription1 string
	InstallationDescription2 string
	ManufacturerInformation string
}
func (p ConfigurationInformation ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ConfigurationInformation\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ConfigurationInformation ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeStringLau(p.InstallationDescription1, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringLau(p.InstallationDescription2, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringLau(p.ManufacturerInformation, 0 )
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeConfigurationInformation(Info MessageInfo, stream *DataStream) (any, error) {
	var val ConfigurationInformation
	val.Info = Info
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for ConfigurationInformation-InstallationDescription1: %w", err)
	} else {
		val.InstallationDescription1 = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for ConfigurationInformation-InstallationDescription2: %w", err)
	} else {
		val.InstallationDescription2 = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for ConfigurationInformation-ManufacturerInformation: %w", err)
	} else {
		val.ManufacturerInformation = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ManOverboardNotification struct {
	Info MessageInfo
	Sid *uint8
	MobEmitterId *uint32
	ManOverboardStatus MobStatusConst
	ActivationTime *float32
	PositionSource MobPositionSourceConst
	PositionDate *uint16
	PositionTime *float32
	Latitude *float64
	Longitude *float64
	CogReference DirectionReferenceConst
	Cog *float32
	Sog *units.Velocity
	MmsiOfVesselOfOrigin *uint32
	MobEmitterBatteryLowStatus LowBatteryConst
}
func (p ManOverboardNotification ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ManOverboardNotification\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ManOverboardNotification ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.MobEmitterId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ManOverboardStatus), 3, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(5, 43)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.ActivationTime, 32, 0.0001, 48, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PositionSource), 3, 80)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(5, 83)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.PositionDate, 16, 88)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.PositionTime, 32, 0.0001, 104, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 136, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 168, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.CogReference), 2, 200)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 202)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Cog, 16, 0.0001, 208, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Sog, 16, 0.010000, 224, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.MmsiOfVesselOfOrigin, 32, 240)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.MobEmitterBatteryLowStatus), 3, 272)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(5, 275)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeManOverboardNotification(Info MessageInfo, stream *DataStream) (any, error) {
	var val ManOverboardNotification
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-MobEmitterId: %w", err)
	} else {
		val.MobEmitterId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-ManOverboardStatus: %w", err)
	} else {
		val.ManOverboardStatus = MobStatusConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-ActivationTime: %w", err)
	} else {
		val.ActivationTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionSource: %w", err)
	} else {
		val.PositionSource = MobPositionSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionDate: %w", err)
	} else {
		val.PositionDate = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-PositionTime: %w", err)
	} else {
		val.PositionTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Latitude: %w", err)
	} else {
		val.Latitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Longitude: %w", err)
	} else {
		val.Longitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-CogReference: %w", err)
	} else {
		val.CogReference = DirectionReferenceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Cog: %w", err)
	} else {
		val.Cog = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-Sog: %w", err)
	} else {
		val.Sog = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-MmsiOfVesselOfOrigin: %w", err)
	} else {
		val.MmsiOfVesselOfOrigin = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for ManOverboardNotification-MobEmitterBatteryLowStatus: %w", err)
	} else {
		val.MobEmitterBatteryLowStatus = LowBatteryConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type HeadingTrackControl struct {
	Info MessageInfo
	RudderLimitExceeded YesNoConst
	OffHeadingLimitExceeded YesNoConst
	OffTrackLimitExceeded YesNoConst
	Override YesNoConst
	SteeringMode SteeringModeConst
	TurnMode TurnModeConst
	HeadingReference DirectionReferenceConst
	CommandedRudderDirection DirectionRudderConst
	CommandedRudderAngle *float32
	HeadingToSteerCourse *float32
	Track *float32
	RudderLimit *float32
	OffHeadingLimit *float32
	RadiusOfTurnOrder *float32
	RateOfTurnOrder *float32
	OffTrackLimit *units.Distance
	VesselHeading *float32
}
func (p HeadingTrackControl ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"HeadingTrackControl\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p HeadingTrackControl ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.RudderLimitExceeded), 2, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.OffHeadingLimitExceeded), 2, 2)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.OffTrackLimitExceeded), 2, 4)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Override), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SteeringMode), 3, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TurnMode), 3, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.HeadingReference), 2, 14)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(5, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.CommandedRudderDirection), 3, 21)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.CommandedRudderAngle, 16, 0.0001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.HeadingToSteerCourse, 16, 0.0001, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Track, 16, 0.0001, 56, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.RudderLimit, 16, 0.0001, 72, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.OffHeadingLimit, 16, 0.0001, 88, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.RadiusOfTurnOrder, 16, 0.0001, 104, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.RateOfTurnOrder, 16, 3.125e-05, 120, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.OffTrackLimit, 16, 1.000000, 136, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.VesselHeading, 16, 0.0001, 152, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeHeadingTrackControl(Info MessageInfo, stream *DataStream) (any, error) {
	var val HeadingTrackControl
	val.Info = Info
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-RudderLimitExceeded: %w", err)
	} else {
		val.RudderLimitExceeded = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffHeadingLimitExceeded: %w", err)
	} else {
		val.OffHeadingLimitExceeded = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffTrackLimitExceeded: %w", err)
	} else {
		val.OffTrackLimitExceeded = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-Override: %w", err)
	} else {
		val.Override = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-SteeringMode: %w", err)
	} else {
		val.SteeringMode = SteeringModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-TurnMode: %w", err)
	} else {
		val.TurnMode = TurnModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-HeadingReference: %w", err)
	} else {
		val.HeadingReference = DirectionReferenceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-CommandedRudderDirection: %w", err)
	} else {
		val.CommandedRudderDirection = DirectionRudderConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-CommandedRudderAngle: %w", err)
	} else {
		val.CommandedRudderAngle = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-HeadingToSteerCourse: %w", err)
	} else {
		val.HeadingToSteerCourse = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-Track: %w", err)
	} else {
		val.Track = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-RudderLimit: %w", err)
	} else {
		val.RudderLimit = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffHeadingLimit: %w", err)
	} else {
		val.OffHeadingLimit = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-RadiusOfTurnOrder: %w", err)
	} else {
		val.RadiusOfTurnOrder = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 3.125e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-RateOfTurnOrder: %w", err)
	} else {
		val.RateOfTurnOrder = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-OffTrackLimit: %w", err)
	} else {
		val.OffTrackLimit = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for HeadingTrackControl-VesselHeading: %w", err)
	} else {
		val.VesselHeading = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Rudder struct {
	Info MessageInfo
	Instance *uint8
	DirectionOrder DirectionRudderConst
	AngleOrder *float32
	Position *float32
}
func (p Rudder ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Rudder\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Rudder ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DirectionOrder), 3, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(5, 11)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.AngleOrder, 16, 0.0001, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Position, 16, 0.0001, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeRudder(Info MessageInfo, stream *DataStream) (any, error) {
	var val Rudder
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Rudder-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for Rudder-DirectionOrder: %w", err)
	} else {
		val.DirectionOrder = DirectionRudderConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Rudder-AngleOrder: %w", err)
	} else {
		val.AngleOrder = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Rudder-Position: %w", err)
	} else {
		val.Position = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type VesselHeading struct {
	Info MessageInfo
	Sid *uint8
	Heading *float32
	Deviation *float32
	Variation *float32
	Reference DirectionReferenceConst
}
func (p VesselHeading ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"VesselHeading\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p VesselHeading ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Heading, 16, 0.0001, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Deviation, 16, 0.0001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Variation, 16, 0.0001, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Reference), 2, 56)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 58)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeVesselHeading(Info MessageInfo, stream *DataStream) (any, error) {
	var val VesselHeading
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Heading: %w", err)
	} else {
		val.Heading = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Deviation: %w", err)
	} else {
		val.Deviation = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Variation: %w", err)
	} else {
		val.Variation = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for VesselHeading-Reference: %w", err)
	} else {
		val.Reference = DirectionReferenceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type RateOfTurn struct {
	Info MessageInfo
	Sid *uint8
	Rate *float64
}
func (p RateOfTurn ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"RateOfTurn\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p RateOfTurn ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Rate, 32, 3.125e-08, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(24, 40)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeRateOfTurn(Info MessageInfo, stream *DataStream) (any, error) {
	var val RateOfTurn
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for RateOfTurn-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 3.125e-08); err != nil {
		return nil, fmt.Errorf("parse failed for RateOfTurn-Rate: %w", err)
	} else {
		val.Rate = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(24)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Attitude struct {
	Info MessageInfo
	Sid *uint8
	Yaw *float32
	Pitch *float32
	Roll *float32
}
func (p Attitude ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Attitude\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Attitude ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Yaw, 16, 0.0001, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Pitch, 16, 0.0001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Roll, 16, 0.0001, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAttitude(Info MessageInfo, stream *DataStream) (any, error) {
	var val Attitude
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Attitude-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Attitude-Yaw: %w", err)
	} else {
		val.Yaw = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Attitude-Pitch: %w", err)
	} else {
		val.Pitch = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Attitude-Roll: %w", err)
	} else {
		val.Roll = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type MagneticVariation struct {
	Info MessageInfo
	Sid *uint8
	Source MagneticVariationConst
	AgeOfService *uint16
	Variation *float32
}
func (p MagneticVariation ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"MagneticVariation\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p MagneticVariation ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Source), 4, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 12)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.AgeOfService, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Variation, 16, 0.0001, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeMagneticVariation(Info MessageInfo, stream *DataStream) (any, error) {
	var val MagneticVariation
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MagneticVariation-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for MagneticVariation-Source: %w", err)
	} else {
		val.Source = MagneticVariationConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MagneticVariation-AgeOfService: %w", err)
	} else {
		val.AgeOfService = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for MagneticVariation-Variation: %w", err)
	} else {
		val.Variation = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type EngineParametersRapidUpdate struct {
	Info MessageInfo
	Instance EngineInstanceConst
	Speed *float32
	BoostPressure *units.Pressure
	TiltTrim *int8
}
func (p EngineParametersRapidUpdate ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"EngineParametersRapidUpdate\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p EngineParametersRapidUpdate ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Speed, 16, 0.25, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.BoostPressure, 16, 100.000000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeInt8(p.TiltTrim, 8, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeEngineParametersRapidUpdate(Info MessageInfo, stream *DataStream) (any, error) {
	var val EngineParametersRapidUpdate
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.25, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-Speed: %w", err)
	} else {
		val.Speed = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-BoostPressure: %w", err)
	} else {
		val.BoostPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersRapidUpdate-TiltTrim: %w", err)
	} else {
		val.TiltTrim = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type EngineParametersDynamic struct {
	Info MessageInfo
	Instance EngineInstanceConst
	OilPressure *units.Pressure
	OilTemperature *units.Temperature
	Temperature *units.Temperature
	AlternatorPotential *float32
	FuelRate *units.Flow
	TotalEngineHours *uint32
	CoolantPressure *units.Pressure
	FuelPressure *units.Pressure
	DiscreteStatus1 EngineStatus1Const
	DiscreteStatus2 EngineStatus2Const
	EngineLoad *int8
	EngineTorque *int8
}
func (p EngineParametersDynamic ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"EngineParametersDynamic\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p EngineParametersDynamic ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.OilPressure, 16, 100.000000, 8, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.OilTemperature, 16, 0.100000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Temperature, 16, 0.010000, 40, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.AlternatorPotential, 16, 0.01, 56, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.FuelRate, 16, 0.100000, 72, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.TotalEngineHours, 32, 88)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.CoolantPressure, 16, 100.000000, 120, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.FuelPressure, 16, 1000.000000, 136, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 152)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DiscreteStatus1), 16, 160)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DiscreteStatus2), 16, 176)
	if err != nil {
		return nil, err
	}
	err = stream.writeInt8(p.EngineLoad, 8, 192)
	if err != nil {
		return nil, err
	}
	err = stream.writeInt8(p.EngineTorque, 8, 200)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeEngineParametersDynamic(Info MessageInfo, stream *DataStream) (any, error) {
	var val EngineParametersDynamic
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-OilPressure: %w", err)
	} else {
		val.OilPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-OilTemperature: %w", err)
	} else {
		val.OilTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-Temperature: %w", err)
	} else {
		val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-AlternatorPotential: %w", err)
	} else {
		val.AlternatorPotential = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-FuelRate: %w", err)
	} else {
		val.FuelRate = nullableUnit(units.LitersPerHour, v, units.NewFlow)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-TotalEngineHours: %w", err)
	} else {
		val.TotalEngineHours = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-CoolantPressure: %w", err)
	} else {
		val.CoolantPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 1000, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-FuelPressure: %w", err)
	} else {
		val.FuelPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(16); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-DiscreteStatus1: %w", err)
	} else {
		val.DiscreteStatus1 = EngineStatus1Const(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(16); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-DiscreteStatus2: %w", err)
	} else {
		val.DiscreteStatus2 = EngineStatus2Const(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-EngineLoad: %w", err)
	} else {
		val.EngineLoad = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersDynamic-EngineTorque: %w", err)
	} else {
		val.EngineTorque = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type TransmissionParametersDynamic struct {
	Info MessageInfo
	Instance EngineInstanceConst
	TransmissionGear GearStatusConst
	OilPressure *units.Pressure
	OilTemperature *units.Temperature
	DiscreteStatus1 *uint8
}
func (p TransmissionParametersDynamic ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"TransmissionParametersDynamic\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p TransmissionParametersDynamic ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TransmissionGear), 2, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 10)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.OilPressure, 16, 100.000000, 16, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.OilTemperature, 16, 0.100000, 32, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DiscreteStatus1, 8, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeTransmissionParametersDynamic(Info MessageInfo, stream *DataStream) (any, error) {
	var val TransmissionParametersDynamic
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-TransmissionGear: %w", err)
	} else {
		val.TransmissionGear = GearStatusConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-OilPressure: %w", err)
	} else {
		val.OilPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-OilTemperature: %w", err)
	} else {
		val.OilTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for TransmissionParametersDynamic-DiscreteStatus1: %w", err)
	} else {
		val.DiscreteStatus1 = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type TripParametersVessel struct {
	Info MessageInfo
	TimeToEmpty *float32
	DistanceToEmpty *units.Distance
	EstimatedFuelRemaining *units.Volume
	TripRunTime *float32
}
func (p TripParametersVessel ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"TripParametersVessel\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p TripParametersVessel ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUnsignedResolution32(p.TimeToEmpty, 32, 0.001, 0, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.DistanceToEmpty, 32, 0.010000, 32, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.EstimatedFuelRemaining, 16, 1.000000, 64, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.TripRunTime, 32, 0.001, 80, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeTripParametersVessel(Info MessageInfo, stream *DataStream) (any, error) {
	var val TripParametersVessel
	val.Info = Info
	if v, err := stream.readUnsignedResolution(32, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersVessel-TimeToEmpty: %w", err)
	} else {
		val.TimeToEmpty = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersVessel-DistanceToEmpty: %w", err)
	} else {
		val.DistanceToEmpty = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersVessel-EstimatedFuelRemaining: %w", err)
	} else {
		val.EstimatedFuelRemaining = nullableUnit(units.Liter, v, units.NewVolume)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersVessel-TripRunTime: %w", err)
	} else {
		val.TripRunTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type TripParametersEngine struct {
	Info MessageInfo
	Instance EngineInstanceConst
	TripFuelUsed *units.Volume
	FuelRateAverage *units.Flow
	FuelRateEconomy *units.Flow
	InstantaneousFuelEconomy *units.Flow
}
func (p TripParametersEngine ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"TripParametersEngine\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p TripParametersEngine ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.TripFuelUsed, 16, 1.000000, 8, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.FuelRateAverage, 16, 0.100000, 24, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.FuelRateEconomy, 16, 0.100000, 40, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.InstantaneousFuelEconomy, 16, 0.100000, 56, 0, true)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeTripParametersEngine(Info MessageInfo, stream *DataStream) (any, error) {
	var val TripParametersEngine
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-TripFuelUsed: %w", err)
	} else {
		val.TripFuelUsed = nullableUnit(units.Liter, v, units.NewVolume)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-FuelRateAverage: %w", err)
	} else {
		val.FuelRateAverage = nullableUnit(units.LitersPerHour, v, units.NewFlow)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-FuelRateEconomy: %w", err)
	} else {
		val.FuelRateEconomy = nullableUnit(units.LitersPerHour, v, units.NewFlow)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TripParametersEngine-InstantaneousFuelEconomy: %w", err)
	} else {
		val.InstantaneousFuelEconomy = nullableUnit(units.LitersPerHour, v, units.NewFlow)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type EngineParametersStatic struct {
	Info MessageInfo
	Instance EngineInstanceConst
	RatedEngineSpeed *float32
	Vin string
	SoftwareId string
}
func (p EngineParametersStatic ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"EngineParametersStatic\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p EngineParametersStatic ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.Instance), 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.RatedEngineSpeed, 16, 0.25, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.Vin), 136, 24 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.SoftwareId), 256, 160 )
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeEngineParametersStatic(Info MessageInfo, stream *DataStream) (any, error) {
	var val EngineParametersStatic
	val.Info = Info
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersStatic-Instance: %w", err)
	} else {
		val.Instance = EngineInstanceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.25, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersStatic-RatedEngineSpeed: %w", err)
	} else {
		val.RatedEngineSpeed = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(136); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersStatic-Vin: %w", err)
	} else {
		val.Vin = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(256); err != nil {
		return nil, fmt.Errorf("parse failed for EngineParametersStatic-SoftwareId: %w", err)
	} else {
		val.SoftwareId = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type LoadControllerConnectionStateControl struct {
	Info MessageInfo
	SequenceId *uint8
	ConnectionId *uint8
	State *uint8
	Status *uint8
	OperationalStatusControl *uint8
	PwmDutyCycle *uint8
	Timeon *uint8
	Timeoff *uint8
}
func (p LoadControllerConnectionStateControl ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"LoadControllerConnectionStateControl\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p LoadControllerConnectionStateControl ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.SequenceId, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.ConnectionId, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.State, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Status, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.OperationalStatusControl, 8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.PwmDutyCycle, 8, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Timeon, 8, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Timeoff, 8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeLoadControllerConnectionStateControl(Info MessageInfo, stream *DataStream) (any, error) {
	var val LoadControllerConnectionStateControl
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-SequenceId: %w", err)
	} else {
		val.SequenceId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-ConnectionId: %w", err)
	} else {
		val.ConnectionId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-State: %w", err)
	} else {
		val.State = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Status: %w", err)
	} else {
		val.Status = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-OperationalStatusControl: %w", err)
	} else {
		val.OperationalStatusControl = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-PwmDutyCycle: %w", err)
	} else {
		val.PwmDutyCycle = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Timeon: %w", err)
	} else {
		val.Timeon = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LoadControllerConnectionStateControl-Timeoff: %w", err)
	} else {
		val.Timeoff = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type BinarySwitchBankStatus struct {
	Info MessageInfo
	Instance *uint8
	Indicator1 OffOnConst
	Indicator2 OffOnConst
	Indicator3 OffOnConst
	Indicator4 OffOnConst
	Indicator5 OffOnConst
	Indicator6 OffOnConst
	Indicator7 OffOnConst
	Indicator8 OffOnConst
	Indicator9 OffOnConst
	Indicator10 OffOnConst
	Indicator11 OffOnConst
	Indicator12 OffOnConst
	Indicator13 OffOnConst
	Indicator14 OffOnConst
	Indicator15 OffOnConst
	Indicator16 OffOnConst
	Indicator17 OffOnConst
	Indicator18 OffOnConst
	Indicator19 OffOnConst
	Indicator20 OffOnConst
	Indicator21 OffOnConst
	Indicator22 OffOnConst
	Indicator23 OffOnConst
	Indicator24 OffOnConst
	Indicator25 OffOnConst
	Indicator26 OffOnConst
	Indicator27 OffOnConst
	Indicator28 OffOnConst
}
func (p BinarySwitchBankStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"BinarySwitchBankStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p BinarySwitchBankStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator1), 2, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator2), 2, 10)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator3), 2, 12)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator4), 2, 14)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator5), 2, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator6), 2, 18)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator7), 2, 20)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator8), 2, 22)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator9), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator10), 2, 26)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator11), 2, 28)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator12), 2, 30)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator13), 2, 32)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator14), 2, 34)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator15), 2, 36)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator16), 2, 38)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator17), 2, 40)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator18), 2, 42)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator19), 2, 44)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator20), 2, 46)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator21), 2, 48)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator22), 2, 50)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator23), 2, 52)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator24), 2, 54)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator25), 2, 56)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator26), 2, 58)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator27), 2, 60)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Indicator28), 2, 62)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeBinarySwitchBankStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val BinarySwitchBankStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator1: %w", err)
	} else {
		val.Indicator1 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator2: %w", err)
	} else {
		val.Indicator2 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator3: %w", err)
	} else {
		val.Indicator3 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator4: %w", err)
	} else {
		val.Indicator4 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator5: %w", err)
	} else {
		val.Indicator5 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator6: %w", err)
	} else {
		val.Indicator6 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator7: %w", err)
	} else {
		val.Indicator7 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator8: %w", err)
	} else {
		val.Indicator8 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator9: %w", err)
	} else {
		val.Indicator9 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator10: %w", err)
	} else {
		val.Indicator10 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator11: %w", err)
	} else {
		val.Indicator11 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator12: %w", err)
	} else {
		val.Indicator12 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator13: %w", err)
	} else {
		val.Indicator13 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator14: %w", err)
	} else {
		val.Indicator14 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator15: %w", err)
	} else {
		val.Indicator15 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator16: %w", err)
	} else {
		val.Indicator16 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator17: %w", err)
	} else {
		val.Indicator17 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator18: %w", err)
	} else {
		val.Indicator18 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator19: %w", err)
	} else {
		val.Indicator19 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator20: %w", err)
	} else {
		val.Indicator20 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator21: %w", err)
	} else {
		val.Indicator21 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator22: %w", err)
	} else {
		val.Indicator22 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator23: %w", err)
	} else {
		val.Indicator23 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator24: %w", err)
	} else {
		val.Indicator24 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator25: %w", err)
	} else {
		val.Indicator25 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator26: %w", err)
	} else {
		val.Indicator26 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator27: %w", err)
	} else {
		val.Indicator27 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for BinarySwitchBankStatus-Indicator28: %w", err)
	} else {
		val.Indicator28 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SwitchBankControl struct {
	Info MessageInfo
	Instance *uint8
	Switch1 OffOnConst
	Switch2 OffOnConst
	Switch3 OffOnConst
	Switch4 OffOnConst
	Switch5 OffOnConst
	Switch6 OffOnConst
	Switch7 OffOnConst
	Switch8 OffOnConst
	Switch9 OffOnConst
	Switch10 OffOnConst
	Switch11 OffOnConst
	Switch12 OffOnConst
	Switch13 OffOnConst
	Switch14 OffOnConst
	Switch15 OffOnConst
	Switch16 OffOnConst
	Switch17 OffOnConst
	Switch18 OffOnConst
	Switch19 OffOnConst
	Switch20 OffOnConst
	Switch21 OffOnConst
	Switch22 OffOnConst
	Switch23 OffOnConst
	Switch24 OffOnConst
	Switch25 OffOnConst
	Switch26 OffOnConst
	Switch27 OffOnConst
	Switch28 OffOnConst
}
func (p SwitchBankControl ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SwitchBankControl\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SwitchBankControl ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch1), 2, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch2), 2, 10)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch3), 2, 12)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch4), 2, 14)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch5), 2, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch6), 2, 18)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch7), 2, 20)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch8), 2, 22)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch9), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch10), 2, 26)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch11), 2, 28)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch12), 2, 30)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch13), 2, 32)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch14), 2, 34)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch15), 2, 36)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch16), 2, 38)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch17), 2, 40)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch18), 2, 42)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch19), 2, 44)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch20), 2, 46)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch21), 2, 48)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch22), 2, 50)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch23), 2, 52)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch24), 2, 54)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch25), 2, 56)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch26), 2, 58)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch27), 2, 60)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Switch28), 2, 62)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSwitchBankControl(Info MessageInfo, stream *DataStream) (any, error) {
	var val SwitchBankControl
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch1: %w", err)
	} else {
		val.Switch1 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch2: %w", err)
	} else {
		val.Switch2 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch3: %w", err)
	} else {
		val.Switch3 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch4: %w", err)
	} else {
		val.Switch4 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch5: %w", err)
	} else {
		val.Switch5 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch6: %w", err)
	} else {
		val.Switch6 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch7: %w", err)
	} else {
		val.Switch7 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch8: %w", err)
	} else {
		val.Switch8 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch9: %w", err)
	} else {
		val.Switch9 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch10: %w", err)
	} else {
		val.Switch10 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch11: %w", err)
	} else {
		val.Switch11 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch12: %w", err)
	} else {
		val.Switch12 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch13: %w", err)
	} else {
		val.Switch13 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch14: %w", err)
	} else {
		val.Switch14 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch15: %w", err)
	} else {
		val.Switch15 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch16: %w", err)
	} else {
		val.Switch16 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch17: %w", err)
	} else {
		val.Switch17 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch18: %w", err)
	} else {
		val.Switch18 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch19: %w", err)
	} else {
		val.Switch19 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch20: %w", err)
	} else {
		val.Switch20 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch21: %w", err)
	} else {
		val.Switch21 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch22: %w", err)
	} else {
		val.Switch22 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch23: %w", err)
	} else {
		val.Switch23 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch24: %w", err)
	} else {
		val.Switch24 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch25: %w", err)
	} else {
		val.Switch25 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch26: %w", err)
	} else {
		val.Switch26 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch27: %w", err)
	} else {
		val.Switch27 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for SwitchBankControl-Switch28: %w", err)
	} else {
		val.Switch28 = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AcInputStatus struct {
	Info MessageInfo
	Instance *uint8
	NumberOfLines *uint8
	Repeating1 []AcInputStatusRepeating1
}
type AcInputStatusRepeating1 struct {
	Line *uint8
	Acceptability AcceptabilityConst
	Voltage *float32
	Current *float32
	Frequency *float32
	BreakerSize *float32
	RealPower *uint32
	ReactivePower *uint32
	PowerFactor *float32
}
func (p AcInputStatus ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint8(p.Repeating1[index].Line, 2, 0)
	if err != nil {
		return err
	}
	err = stream.putNumberRaw(uint64(p.Repeating1[index].Acceptability), 2, 0)
	if err != nil {
		return err
	}
	err = stream.writeReserved(4, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].Voltage, 16, 0.01, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].Current, 16, 0.1, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].Frequency, 16, 0.01, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].BreakerSize, 16, 0.1, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUint32(p.Repeating1[index].RealPower, 32, 0)
	if err != nil {
		return err
	}
	err = stream.writeUint32(p.Repeating1[index].ReactivePower, 32, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].PowerFactor, 8, 0.01, 0, 0)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p AcInputStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AcInputStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AcInputStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfLines, 8, 8)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeAcInputStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val AcInputStatus
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcInputStatus-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcInputStatus-NumberOfLines: %w", err)
	} else {
		val.NumberOfLines = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AcInputStatusRepeating1, 0)
	i := 0 
	for {
		var rep AcInputStatusRepeating1
		if v, err := stream.readUInt8(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Line: %w", err)
		} else {
			rep.Line = v
		}
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Acceptability: %w", err)
		} else {
			rep.Acceptability = AcceptabilityConst(v)
		}
		stream.skipBits(4)
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Voltage: %w", err)
		} else {
			rep.Voltage = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Current: %w", err)
		} else {
			rep.Current = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-Frequency: %w", err)
		} else {
			rep.Frequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-BreakerSize: %w", err)
		} else {
			rep.BreakerSize = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-RealPower: %w", err)
		} else {
			rep.RealPower = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-ReactivePower: %w", err)
		} else {
			rep.ReactivePower = v
		}
		if v, err := stream.readUnsignedResolution(8, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcInputStatus-PowerFactor: %w", err)
		} else {
			rep.PowerFactor = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AcOutputStatus struct {
	Info MessageInfo
	Instance *uint8
	NumberOfLines *uint8
	Repeating1 []AcOutputStatusRepeating1
}
type AcOutputStatusRepeating1 struct {
	Line LineConst
	Waveform WaveformConst
	Voltage *float32
	Current *float32
	Frequency *float32
	BreakerSize *float32
	RealPower *uint32
	ReactivePower *uint32
	PowerFactor *float32
}
func (p AcOutputStatus ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.putNumberRaw(uint64(p.Repeating1[index].Line), 2, 0)
	if err != nil {
		return err
	}
	err = stream.putNumberRaw(uint64(p.Repeating1[index].Waveform), 3, 0)
	if err != nil {
		return err
	}
	err = stream.writeReserved(3, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].Voltage, 16, 0.01, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].Current, 16, 0.1, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].Frequency, 16, 0.01, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].BreakerSize, 16, 0.1, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUint32(p.Repeating1[index].RealPower, 32, 0)
	if err != nil {
		return err
	}
	err = stream.writeUint32(p.Repeating1[index].ReactivePower, 32, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].PowerFactor, 8, 0.01, 0, 0)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p AcOutputStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AcOutputStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AcOutputStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfLines, 8, 8)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeAcOutputStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val AcOutputStatus
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcOutputStatus-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcOutputStatus-NumberOfLines: %w", err)
	} else {
		val.NumberOfLines = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]AcOutputStatusRepeating1, 0)
	i := 0 
	for {
		var rep AcOutputStatusRepeating1
		if v, err := stream.readLookupField(2); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Line: %w", err)
		} else {
			rep.Line = LineConst(v)
		}
		if v, err := stream.readLookupField(3); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Waveform: %w", err)
		} else {
			rep.Waveform = WaveformConst(v)
		}
		stream.skipBits(3)
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Voltage: %w", err)
		} else {
			rep.Voltage = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Current: %w", err)
		} else {
			rep.Current = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-Frequency: %w", err)
		} else {
			rep.Frequency = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-BreakerSize: %w", err)
		} else {
			rep.BreakerSize = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-RealPower: %w", err)
		} else {
			rep.RealPower = v
		}
		if v, err := stream.readUInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-ReactivePower: %w", err)
		} else {
			rep.ReactivePower = v
		}
		if v, err := stream.readUnsignedResolution(8, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for AcOutputStatus-PowerFactor: %w", err)
		} else {
			rep.PowerFactor = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type FluidLevel struct {
	Info MessageInfo
	Instance *uint8
	Type TankTypeConst
	Level *float32
	Capacity *units.Volume
}
func (p FluidLevel ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"FluidLevel\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p FluidLevel ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 4, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Type), 4, 4)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Level, 16, 0.004, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Capacity, 32, 0.100000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeFluidLevel(Info MessageInfo, stream *DataStream) (any, error) {
	var val FluidLevel
	val.Info = Info
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for FluidLevel-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for FluidLevel-Type: %w", err)
	} else {
		val.Type = TankTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.004, 0); err != nil {
		return nil, fmt.Errorf("parse failed for FluidLevel-Level: %w", err)
	} else {
		val.Level = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for FluidLevel-Capacity: %w", err)
	} else {
		val.Capacity = nullableUnit(units.Liter, v, units.NewVolume)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type DcDetailedStatus struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	DcType DcSourceConst
	StateOfCharge *uint8
	StateOfHealth *uint8
	TimeRemaining *float32
	RippleVoltage *float32
	RemainingCapacity *uint16
}
func (p DcDetailedStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"DcDetailedStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p DcDetailedStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DcType), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.StateOfCharge, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.StateOfHealth, 8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.TimeRemaining, 16, 60, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.RippleVoltage, 16, 0.01, 56, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.RemainingCapacity, 16, 72)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeDcDetailedStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val DcDetailedStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-DcType: %w", err)
	} else {
		val.DcType = DcSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-StateOfCharge: %w", err)
	} else {
		val.StateOfCharge = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-StateOfHealth: %w", err)
	} else {
		val.StateOfHealth = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 60, 0); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-TimeRemaining: %w", err)
	} else {
		val.TimeRemaining = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-RippleVoltage: %w", err)
	} else {
		val.RippleVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DcDetailedStatus-RemainingCapacity: %w", err)
	} else {
		val.RemainingCapacity = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ChargerStatus struct {
	Info MessageInfo
	Instance *uint8
	BatteryInstance *uint8
	OperatingState ChargerStateConst
	ChargeMode ChargerModeConst
	Enabled OffOnConst
	EqualizationPending OffOnConst
	EqualizationTimeRemaining *float32
}
func (p ChargerStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ChargerStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ChargerStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.BatteryInstance, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.OperatingState), 4, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ChargeMode), 4, 20)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Enabled), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.EqualizationPending), 2, 26)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 28)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.EqualizationTimeRemaining, 16, 60, 32, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeChargerStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val ChargerStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-BatteryInstance: %w", err)
	} else {
		val.BatteryInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-OperatingState: %w", err)
	} else {
		val.OperatingState = ChargerStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-ChargeMode: %w", err)
	} else {
		val.ChargeMode = ChargerModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-Enabled: %w", err)
	} else {
		val.Enabled = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-EqualizationPending: %w", err)
	} else {
		val.EqualizationPending = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 60, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ChargerStatus-EqualizationTimeRemaining: %w", err)
	} else {
		val.EqualizationTimeRemaining = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type BatteryStatus struct {
	Info MessageInfo
	Instance *uint8
	Voltage *float32
	Current *float32
	Temperature *units.Temperature
	Sid *uint8
}
func (p BatteryStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"BatteryStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p BatteryStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Voltage, 16, 0.01, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Current, 16, 0.1, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Temperature, 16, 0.010000, 40, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Sid, 8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeBatteryStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val BatteryStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Voltage: %w", err)
	} else {
		val.Voltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Current: %w", err)
	} else {
		val.Current = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Temperature: %w", err)
	} else {
		val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for BatteryStatus-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type InverterStatus struct {
	Info MessageInfo
	Instance *uint8
	AcInstance *uint8
	DcInstance *uint8
	OperatingState InverterStateConst
	InverterEnable OffOnConst
}
func (p InverterStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"InverterStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p InverterStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Instance, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.AcInstance, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.DcInstance, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.OperatingState), 4, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.InverterEnable), 2, 28)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 30)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeInverterStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val InverterStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-AcInstance: %w", err)
	} else {
		val.AcInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-DcInstance: %w", err)
	} else {
		val.DcInstance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-OperatingState: %w", err)
	} else {
		val.OperatingState = InverterStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for InverterStatus-InverterEnable: %w", err)
	} else {
		val.InverterEnable = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AcPowerCurrentPhaseA struct {
	Info MessageInfo
	Sid *uint8
	ConnectionNumber *uint8
	AcRmsCurrent *float32
	Power *int32
}
func (p AcPowerCurrentPhaseA ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AcPowerCurrentPhaseA\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AcPowerCurrentPhaseA ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.ConnectionNumber, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcRmsCurrent, 16, 0.1, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeInt32(p.Power, 32, 32)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAcPowerCurrentPhaseA(Info MessageInfo, stream *DataStream) (any, error) {
	var val AcPowerCurrentPhaseA
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseA-Power: %w", err)
	} else {
		val.Power = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AcPowerCurrentPhaseB struct {
	Info MessageInfo
	Sid *uint8
	ConnectionNumber *uint8
	AcRmsCurrent *float32
	Power *int32
}
func (p AcPowerCurrentPhaseB ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AcPowerCurrentPhaseB\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AcPowerCurrentPhaseB ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.ConnectionNumber, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcRmsCurrent, 16, 0.1, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeInt32(p.Power, 32, 32)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAcPowerCurrentPhaseB(Info MessageInfo, stream *DataStream) (any, error) {
	var val AcPowerCurrentPhaseB
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseB-Power: %w", err)
	} else {
		val.Power = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AcPowerCurrentPhaseC struct {
	Info MessageInfo
	Sid *uint8
	ConnectionNumber *uint8
	AcRmsCurrent *float32
	Power *int32
}
func (p AcPowerCurrentPhaseC ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AcPowerCurrentPhaseC\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AcPowerCurrentPhaseC ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.ConnectionNumber, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AcRmsCurrent, 16, 0.1, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeInt32(p.Power, 32, 32)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAcPowerCurrentPhaseC(Info MessageInfo, stream *DataStream) (any, error) {
	var val AcPowerCurrentPhaseC
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-AcRmsCurrent: %w", err)
	} else {
		val.AcRmsCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AcPowerCurrentPhaseC-Power: %w", err)
	} else {
		val.Power = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ConverterStatus struct {
	Info MessageInfo
	Sid []uint8
	ConnectionNumber *uint8
	OperatingState ConverterStateConst
	TemperatureState GoodWarningErrorConst
	OverloadState GoodWarningErrorConst
	LowDcVoltageState GoodWarningErrorConst
	RippleState GoodWarningErrorConst
}
func (p ConverterStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ConverterStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ConverterStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeBinary(p.Sid, 8, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.ConnectionNumber, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.OperatingState), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TemperatureState), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.OverloadState), 2, 26)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.LowDcVoltageState), 2, 28)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RippleState), 2, 30)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(32, 32)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeConverterStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val ConverterStatus
	val.Info = Info
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-OperatingState: %w", err)
	} else {
		val.OperatingState = ConverterStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-TemperatureState: %w", err)
	} else {
		val.TemperatureState = GoodWarningErrorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-OverloadState: %w", err)
	} else {
		val.OverloadState = GoodWarningErrorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-LowDcVoltageState: %w", err)
	} else {
		val.LowDcVoltageState = GoodWarningErrorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ConverterStatus-RippleState: %w", err)
	} else {
		val.RippleState = GoodWarningErrorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(32)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type DcVoltageCurrent struct {
	Info MessageInfo
	Sid []uint8
	ConnectionNumber *uint8
	DcVoltage *float32
	DcCurrent *float32
}
func (p DcVoltageCurrent ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"DcVoltageCurrent\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p DcVoltageCurrent ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeBinary(p.Sid, 8, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.ConnectionNumber, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.DcVoltage, 16, 0.1, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.DcCurrent, 24, 0.01, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeDcVoltageCurrent(Info MessageInfo, stream *DataStream) (any, error) {
	var val DcVoltageCurrent
	val.Info = Info
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcVoltageCurrent-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for DcVoltageCurrent-ConnectionNumber: %w", err)
	} else {
		val.ConnectionNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for DcVoltageCurrent-DcVoltage: %w", err)
	} else {
		val.DcVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(24, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for DcVoltageCurrent-DcCurrent: %w", err)
	} else {
		val.DcCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type LeewayAngle struct {
	Info MessageInfo
	Sid *uint8
	LeewayAngle *float32
}
func (p LeewayAngle ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"LeewayAngle\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p LeewayAngle ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.LeewayAngle, 16, 0.0001, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(40, 24)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeLeewayAngle(Info MessageInfo, stream *DataStream) (any, error) {
	var val LeewayAngle
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for LeewayAngle-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for LeewayAngle-LeewayAngle: %w", err)
	} else {
		val.LeewayAngle = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(40)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ThrusterControlStatus struct {
	Info MessageInfo
	Sid *uint8
	Identifier *uint8
	DirectionControl ThrusterDirectionControlConst
	PowerEnabled OffOnConst
	RetractControl ThrusterRetractControlConst
	SpeedControl *uint8
	ControlEvents ThrusterControlEventsConst
	CommandTimeout *float32
	AzimuthControl *float32
}
func (p ThrusterControlStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ThrusterControlStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ThrusterControlStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Identifier, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DirectionControl), 4, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerEnabled), 2, 20)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RetractControl), 2, 22)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SpeedControl, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ControlEvents), 8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.CommandTimeout, 8, 0.005, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.AzimuthControl, 16, 0.0001, 48, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeThrusterControlStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val ThrusterControlStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-Identifier: %w", err)
	} else {
		val.Identifier = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-DirectionControl: %w", err)
	} else {
		val.DirectionControl = ThrusterDirectionControlConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-PowerEnabled: %w", err)
	} else {
		val.PowerEnabled = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-RetractControl: %w", err)
	} else {
		val.RetractControl = ThrusterRetractControlConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-SpeedControl: %w", err)
	} else {
		val.SpeedControl = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-ControlEvents: %w", err)
	} else {
		val.ControlEvents = ThrusterControlEventsConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 0.005, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-CommandTimeout: %w", err)
	} else {
		val.CommandTimeout = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterControlStatus-AzimuthControl: %w", err)
	} else {
		val.AzimuthControl = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ThrusterInformation struct {
	Info MessageInfo
	Identifier *uint8
	MotorType ThrusterMotorTypeConst
	PowerRating *uint16
	MaximumTemperatureRating *units.Temperature
	MaximumRotationalSpeed *float32
}
func (p ThrusterInformation ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ThrusterInformation\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ThrusterInformation ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Identifier, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.MotorType), 4, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(4, 12)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.PowerRating, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.MaximumTemperatureRating, 16, 0.010000, 32, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.MaximumRotationalSpeed, 16, 0.25, 48, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeThrusterInformation(Info MessageInfo, stream *DataStream) (any, error) {
	var val ThrusterInformation
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-Identifier: %w", err)
	} else {
		val.Identifier = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-MotorType: %w", err)
	} else {
		val.MotorType = ThrusterMotorTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(4)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-PowerRating: %w", err)
	} else {
		val.PowerRating = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-MaximumTemperatureRating: %w", err)
	} else {
		val.MaximumTemperatureRating = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.25, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterInformation-MaximumRotationalSpeed: %w", err)
	} else {
		val.MaximumRotationalSpeed = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type ThrusterMotorStatus struct {
	Info MessageInfo
	Sid *uint8
	Identifier *uint8
	MotorEvents ThrusterMotorEventsConst
	Current *uint8
	Temperature *units.Temperature
	OperatingTime *float32
}
func (p ThrusterMotorStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ThrusterMotorStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ThrusterMotorStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Identifier, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.MotorEvents), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Current, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Temperature, 16, 0.010000, 32, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.OperatingTime, 16, 60, 48, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeThrusterMotorStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val ThrusterMotorStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Identifier: %w", err)
	} else {
		val.Identifier = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-MotorEvents: %w", err)
	} else {
		val.MotorEvents = ThrusterMotorEventsConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Current: %w", err)
	} else {
		val.Current = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-Temperature: %w", err)
	} else {
		val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 60, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ThrusterMotorStatus-OperatingTime: %w", err)
	} else {
		val.OperatingTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Speed struct {
	Info MessageInfo
	Sid *uint8
	SpeedWaterReferenced *units.Velocity
	SpeedGroundReferenced *units.Velocity
	SpeedWaterReferencedType WaterReferenceConst
	SpeedDirection *uint8
}
func (p Speed ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Speed\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Speed ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SpeedWaterReferenced, 16, 0.010000, 8, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SpeedGroundReferenced, 16, 0.010000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SpeedWaterReferencedType), 8, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SpeedDirection, 4, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(12, 52)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSpeed(Info MessageInfo, stream *DataStream) (any, error) {
	var val Speed
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-SpeedWaterReferenced: %w", err)
	} else {
		val.SpeedWaterReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-SpeedGroundReferenced: %w", err)
	} else {
		val.SpeedGroundReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-SpeedWaterReferencedType: %w", err)
	} else {
		val.SpeedWaterReferencedType = WaterReferenceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(4); err != nil {
		return nil, fmt.Errorf("parse failed for Speed-SpeedDirection: %w", err)
	} else {
		val.SpeedDirection = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(12)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type WaterDepth struct {
	Info MessageInfo
	Sid *uint8
	Depth *units.Distance
	Offset *units.Distance
	Range *units.Distance
}
func (p WaterDepth ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"WaterDepth\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p WaterDepth ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Depth, 32, 0.010000, 8, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Offset, 16, 0.001000, 40, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Range, 8, 10.000000, 56, 0, false)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeWaterDepth(Info MessageInfo, stream *DataStream) (any, error) {
	var val WaterDepth
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for WaterDepth-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WaterDepth-Depth: %w", err)
	} else {
		val.Depth = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WaterDepth-Offset: %w", err)
	} else {
		val.Offset = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 10, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WaterDepth-Range: %w", err)
	} else {
		val.Range = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type DistanceLog struct {
	Info MessageInfo
	Date *uint16
	Time *float32
	Log *units.Distance
	TripLog *units.Distance
}
func (p DistanceLog ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"DistanceLog\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p DistanceLog ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.Date, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Time, 32, 0.0001, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Log, 32, 1.000000, 48, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.TripLog, 32, 1.000000, 80, 0, false)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeDistanceLog(Info MessageInfo, stream *DataStream) (any, error) {
	var val DistanceLog
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for DistanceLog-Date: %w", err)
	} else {
		val.Date = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for DistanceLog-Time: %w", err)
	} else {
		val.Time = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for DistanceLog-Log: %w", err)
	} else {
		val.Log = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for DistanceLog-TripLog: %w", err)
	} else {
		val.TripLog = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type WindlassControlStatus struct {
	Info MessageInfo
	Sid *uint8
	WindlassId *uint8
	WindlassDirectionControl WindlassDirectionConst
	AnchorDockingControl OffOnConst
	SpeedControlType SpeedTypeConst
	SpeedControl []uint8
	PowerEnable OffOnConst
	MechanicalLock OffOnConst
	DeckAndAnchorWash OffOnConst
	AnchorLight OffOnConst
	CommandTimeout *float32
	WindlassControlEvents WindlassControlConst
}
func (p WindlassControlStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"WindlassControlStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p WindlassControlStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.WindlassId, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.WindlassDirectionControl), 2, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AnchorDockingControl), 2, 18)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SpeedControlType), 2, 20)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 22)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.SpeedControl, 8, 24 )
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PowerEnable), 2, 32)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.MechanicalLock), 2, 34)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DeckAndAnchorWash), 2, 36)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AnchorLight), 2, 38)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.CommandTimeout, 8, 0.005, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.WindlassControlEvents), 4, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(12, 52)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeWindlassControlStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val WindlassControlStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassId: %w", err)
	} else {
		val.WindlassId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassDirectionControl: %w", err)
	} else {
		val.WindlassDirectionControl = WindlassDirectionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-AnchorDockingControl: %w", err)
	} else {
		val.AnchorDockingControl = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-SpeedControlType: %w", err)
	} else {
		val.SpeedControlType = SpeedTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-SpeedControl: %w", err)
	} else {
		val.SpeedControl = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-PowerEnable: %w", err)
	} else {
		val.PowerEnable = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-MechanicalLock: %w", err)
	} else {
		val.MechanicalLock = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-DeckAndAnchorWash: %w", err)
	} else {
		val.DeckAndAnchorWash = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-AnchorLight: %w", err)
	} else {
		val.AnchorLight = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 0.005, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-CommandTimeout: %w", err)
	} else {
		val.CommandTimeout = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for WindlassControlStatus-WindlassControlEvents: %w", err)
	} else {
		val.WindlassControlEvents = WindlassControlConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(12)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AnchorWindlassOperatingStatus struct {
	Info MessageInfo
	Sid *uint8
	WindlassId *uint8
	WindlassDirectionControl WindlassDirectionConst
	WindlassMotionStatus WindlassMotionConst
	RodeTypeStatus RodeTypeConst
	RodeCounterValue *units.Distance
	WindlassLineSpeed *units.Velocity
	AnchorDockingStatus DockingStatusConst
	WindlassOperatingEvents WindlassOperationConst
}
func (p AnchorWindlassOperatingStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AnchorWindlassOperatingStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AnchorWindlassOperatingStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.WindlassId, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.WindlassDirectionControl), 2, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.WindlassMotionStatus), 2, 18)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RodeTypeStatus), 2, 20)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 22)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.RodeCounterValue, 16, 0.100000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.WindlassLineSpeed, 16, 0.010000, 40, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AnchorDockingStatus), 2, 56)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.WindlassOperatingEvents), 6, 58)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAnchorWindlassOperatingStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val AnchorWindlassOperatingStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassId: %w", err)
	} else {
		val.WindlassId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassDirectionControl: %w", err)
	} else {
		val.WindlassDirectionControl = WindlassDirectionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassMotionStatus: %w", err)
	} else {
		val.WindlassMotionStatus = WindlassMotionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-RodeTypeStatus: %w", err)
	} else {
		val.RodeTypeStatus = RodeTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-RodeCounterValue: %w", err)
	} else {
		val.RodeCounterValue = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassLineSpeed: %w", err)
	} else {
		val.WindlassLineSpeed = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-AnchorDockingStatus: %w", err)
	} else {
		val.AnchorDockingStatus = DockingStatusConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassOperatingStatus-WindlassOperatingEvents: %w", err)
	} else {
		val.WindlassOperatingEvents = WindlassOperationConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AnchorWindlassMonitoringStatus struct {
	Info MessageInfo
	Sid *uint8
	WindlassId *uint8
	WindlassMonitoringEvents WindlassMonitoringConst
	ControllerVoltage *float32
	MotorCurrent *uint8
	TotalMotorTime *float32
}
func (p AnchorWindlassMonitoringStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AnchorWindlassMonitoringStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AnchorWindlassMonitoringStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.WindlassId, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.WindlassMonitoringEvents), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.ControllerVoltage, 8, 0.2, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.MotorCurrent, 8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.TotalMotorTime, 16, 60, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAnchorWindlassMonitoringStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val AnchorWindlassMonitoringStatus
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-WindlassId: %w", err)
	} else {
		val.WindlassId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-WindlassMonitoringEvents: %w", err)
	} else {
		val.WindlassMonitoringEvents = WindlassMonitoringConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(8, 0.2, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-ControllerVoltage: %w", err)
	} else {
		val.ControllerVoltage = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-MotorCurrent: %w", err)
	} else {
		val.MotorCurrent = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 60, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AnchorWindlassMonitoringStatus-TotalMotorTime: %w", err)
	} else {
		val.TotalMotorTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type PositionRapidUpdate struct {
	Info MessageInfo
	Latitude *float64
	Longitude *float64
}
func (p PositionRapidUpdate ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"PositionRapidUpdate\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p PositionRapidUpdate ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 0, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 32, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodePositionRapidUpdate(Info MessageInfo, stream *DataStream) (any, error) {
	var val PositionRapidUpdate
	val.Info = Info
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for PositionRapidUpdate-Latitude: %w", err)
	} else {
		val.Latitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for PositionRapidUpdate-Longitude: %w", err)
	} else {
		val.Longitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type CogSogRapidUpdate struct {
	Info MessageInfo
	Sid *uint8
	CogReference DirectionReferenceConst
	Cog *float32
	Sog *units.Velocity
}
func (p CogSogRapidUpdate ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"CogSogRapidUpdate\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p CogSogRapidUpdate ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.CogReference), 2, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 10)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Cog, 16, 0.0001, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Sog, 16, 0.010000, 32, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeCogSogRapidUpdate(Info MessageInfo, stream *DataStream) (any, error) {
	var val CogSogRapidUpdate
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-CogReference: %w", err)
	} else {
		val.CogReference = DirectionReferenceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Cog: %w", err)
	} else {
		val.Cog = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for CogSogRapidUpdate-Sog: %w", err)
	} else {
		val.Sog = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type GnssPositionData struct {
	Info MessageInfo
	Sid *uint8
	Date *uint16
	Time *float32
	Latitude *float64
	Longitude *float64
	Altitude *units.Distance
	GnssType GnsConst
	Method GnsMethodConst
	Integrity GnsIntegrityConst
	NumberOfSvs *uint8
	Hdop *float32
	Pdop *float32
	GeoidalSeparation *units.Distance
	ReferenceStations *uint8
	Repeating1 []GnssPositionDataRepeating1
}
type GnssPositionDataRepeating1 struct {
	ReferenceStationType GnsConst
	ReferenceStationId *uint16
	AgeOfDgnssCorrections *float32
}
func (p GnssPositionData ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.putNumberRaw(uint64(p.Repeating1[index].ReferenceStationType), 4, 0)
	if err != nil {
		return err
	}
	err = stream.writeUint16(p.Repeating1[index].ReferenceStationId, 12, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].AgeOfDgnssCorrections, 16, 0.01, 0, 0)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p GnssPositionData ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GnssPositionData\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GnssPositionData ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.Date, 16, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Time, 32, 0.0001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Latitude, 64, 1e-16, 56, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Longitude, 64, 1e-16, 120, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Altitude, 64, 0.000001, 184, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.GnssType), 4, 248)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Method), 4, 252)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Integrity), 2, 256)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 258)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.NumberOfSvs, 8, 264)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Hdop, 16, 0.01, 272, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Pdop, 16, 0.01, 288, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.GeoidalSeparation, 32, 0.010000, 304, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.ReferenceStations, 8, 336)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeGnssPositionData(Info MessageInfo, stream *DataStream) (any, error) {
	var val GnssPositionData
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Date: %w", err)
	} else {
		val.Date = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Time: %w", err)
	} else {
		val.Time = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(64, 1e-16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Latitude: %w", err)
	} else {
		val.Latitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(64, 1e-16); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Longitude: %w", err)
	} else {
		val.Longitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(64, 1e-06, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Altitude: %w", err)
	} else {
		val.Altitude = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-GnssType: %w", err)
	} else {
		val.GnssType = GnsConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Method: %w", err)
	} else {
		val.Method = GnsMethodConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Integrity: %w", err)
	} else {
		val.Integrity = GnsIntegrityConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-NumberOfSvs: %w", err)
	} else {
		val.NumberOfSvs = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Hdop: %w", err)
	} else {
		val.Hdop = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-Pdop: %w", err)
	} else {
		val.Pdop = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-GeoidalSeparation: %w", err)
	} else {
		val.GeoidalSeparation = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStations: %w", err)
	} else {
		val.ReferenceStations = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]GnssPositionDataRepeating1, 0)
	i := 0 
	for {
		var rep GnssPositionDataRepeating1
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStationType: %w", err)
		} else {
			rep.ReferenceStationType = GnsConst(v)
		}
		if v, err := stream.readUInt16(12); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-ReferenceStationId: %w", err)
		} else {
			rep.ReferenceStationId = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for GnssPositionData-AgeOfDgnssCorrections: %w", err)
		} else {
			rep.AgeOfDgnssCorrections = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type TimeDate struct {
	Info MessageInfo
	Date *uint16
	Time *float32
	LocalOffset *float32
}
func (p TimeDate ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"TimeDate\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p TimeDate ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.Date, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Time, 32, 0.0001, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.LocalOffset, 16, 60, 48, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeTimeDate(Info MessageInfo, stream *DataStream) (any, error) {
	var val TimeDate
	val.Info = Info
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for TimeDate-Date: %w", err)
	} else {
		val.Date = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TimeDate-Time: %w", err)
	} else {
		val.Time = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 60, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TimeDate-LocalOffset: %w", err)
	} else {
		val.LocalOffset = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisClassAPositionReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float64
	Latitude *float64
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	TimeStamp TimeStampConst
	Cog *float32
	Sog *units.Velocity
	CommunicationState []uint8
	AisTransceiverInformation AisTransceiverConst
	Heading *float32
	RateOfTurn *float32
	NavStatus NavStatusConst
	SpecialManeuverIndicator AisSpecialManeuverConst
	SequenceId *uint8
}
func (p AisClassAPositionReport ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisClassAPositionReport\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisClassAPositionReport ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.UserId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 72, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PositionAccuracy), 1, 104)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Raim), 1, 105)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TimeStamp), 6, 106)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Cog, 16, 0.0001, 112, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Sog, 16, 0.010000, 128, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.CommunicationState, 19, 144 )
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 163)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Heading, 16, 0.0001, 168, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.RateOfTurn, 16, 3.125e-05, 184, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.NavStatus), 4, 200)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SpecialManeuverIndicator), 2, 204)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 206)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(3, 208)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(5, 211)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SequenceId, 8, 216)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisClassAPositionReport(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisClassAPositionReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-UserId: %w", err)
	} else {
		val.UserId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Longitude: %w", err)
	} else {
		val.Longitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Latitude: %w", err)
	} else {
		val.Latitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-TimeStamp: %w", err)
	} else {
		val.TimeStamp = TimeStampConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Cog: %w", err)
	} else {
		val.Cog = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Sog: %w", err)
	} else {
		val.Sog = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(19); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-CommunicationState: %w", err)
	} else {
		val.CommunicationState = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-Heading: %w", err)
	} else {
		val.Heading = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 3.125e-05, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-RateOfTurn: %w", err)
	} else {
		val.RateOfTurn = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-NavStatus: %w", err)
	} else {
		val.NavStatus = NavStatusConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-SpecialManeuverIndicator: %w", err)
	} else {
		val.SpecialManeuverIndicator = AisSpecialManeuverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(5)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAPositionReport-SequenceId: %w", err)
	} else {
		val.SequenceId = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisClassBPositionReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float64
	Latitude *float64
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	TimeStamp TimeStampConst
	Cog *float32
	Sog *units.Velocity
	CommunicationState []uint8
	AisTransceiverInformation AisTransceiverConst
	Heading *float32
	UnitType AisTypeConst
	IntegratedDisplay YesNoConst
	Dsc YesNoConst
	Band AisBandConst
	CanHandleMsg22 YesNoConst
	AisMode AisModeConst
	AisCommunicationState AisCommunicationStateConst
}
func (p AisClassBPositionReport ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisClassBPositionReport\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisClassBPositionReport ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.UserId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 72, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PositionAccuracy), 1, 104)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Raim), 1, 105)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TimeStamp), 6, 106)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Cog, 16, 0.0001, 112, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Sog, 16, 0.010000, 128, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.CommunicationState, 19, 144 )
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 163)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.Heading, 16, 0.0001, 168, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(8, 184)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(2, 192)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.UnitType), 1, 194)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IntegratedDisplay), 1, 195)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Dsc), 1, 196)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Band), 1, 197)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.CanHandleMsg22), 1, 198)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisMode), 1, 199)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisCommunicationState), 1, 200)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(15, 201)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisClassBPositionReport(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisClassBPositionReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-UserId: %w", err)
	} else {
		val.UserId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Longitude: %w", err)
	} else {
		val.Longitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Latitude: %w", err)
	} else {
		val.Latitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-TimeStamp: %w", err)
	} else {
		val.TimeStamp = TimeStampConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Cog: %w", err)
	} else {
		val.Cog = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Sog: %w", err)
	} else {
		val.Sog = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(19); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-CommunicationState: %w", err)
	} else {
		val.CommunicationState = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Heading: %w", err)
	} else {
		val.Heading = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-UnitType: %w", err)
	} else {
		val.UnitType = AisTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-IntegratedDisplay: %w", err)
	} else {
		val.IntegratedDisplay = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Dsc: %w", err)
	} else {
		val.Dsc = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-Band: %w", err)
	} else {
		val.Band = AisBandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-CanHandleMsg22: %w", err)
	} else {
		val.CanHandleMsg22 = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisMode: %w", err)
	} else {
		val.AisMode = AisModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBPositionReport-AisCommunicationState: %w", err)
	} else {
		val.AisCommunicationState = AisCommunicationStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(15)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AisAidsToNavigationAtonReport struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Longitude *float64
	Latitude *float64
	PositionAccuracy PositionAccuracyConst
	Raim RaimFlagConst
	TimeStamp TimeStampConst
	LengthDiameter *units.Distance
	BeamDiameter *units.Distance
	PositionReferenceFromStarboardEdge *units.Distance
	PositionReferenceFromTrueNorthFacingEdge *units.Distance
	AtonType AtonTypeConst
	OffPositionIndicator YesNoConst
	VirtualAtonFlag YesNoConst
	AssignedModeFlag AisAssignedModeConst
	PositionFixingDeviceType PositionFixDeviceConst
	AtonStatus []uint8
	AisTransceiverInformation AisTransceiverConst
	AtonName string
}
func (p AisAidsToNavigationAtonReport ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisAidsToNavigationAtonReport\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisAidsToNavigationAtonReport ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.UserId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Longitude, 32, 1e-07, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.Latitude, 32, 1e-07, 72, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PositionAccuracy), 1, 104)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Raim), 1, 105)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TimeStamp), 6, 106)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.LengthDiameter, 16, 0.100000, 112, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.BeamDiameter, 16, 0.100000, 128, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.PositionReferenceFromStarboardEdge, 16, 0.100000, 144, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.PositionReferenceFromTrueNorthFacingEdge, 16, 0.100000, 160, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AtonType), 5, 176)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.OffPositionIndicator), 1, 181)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.VirtualAtonFlag), 1, 182)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AssignedModeFlag), 1, 183)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(1, 184)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PositionFixingDeviceType), 4, 185)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(3, 189)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.AtonStatus, 8, 192 )
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 200)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(3, 205)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringLau(p.AtonName, 0 )
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisAidsToNavigationAtonReport(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisAidsToNavigationAtonReport
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-UserId: %w", err)
	} else {
		val.UserId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Longitude: %w", err)
	} else {
		val.Longitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Latitude: %w", err)
	} else {
		val.Latitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionAccuracy: %w", err)
	} else {
		val.PositionAccuracy = PositionAccuracyConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-Raim: %w", err)
	} else {
		val.Raim = RaimFlagConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-TimeStamp: %w", err)
	} else {
		val.TimeStamp = TimeStampConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-LengthDiameter: %w", err)
	} else {
		val.LengthDiameter = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-BeamDiameter: %w", err)
	} else {
		val.BeamDiameter = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionReferenceFromStarboardEdge: %w", err)
	} else {
		val.PositionReferenceFromStarboardEdge = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionReferenceFromTrueNorthFacingEdge: %w", err)
	} else {
		val.PositionReferenceFromTrueNorthFacingEdge = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonType: %w", err)
	} else {
		val.AtonType = AtonTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-OffPositionIndicator: %w", err)
	} else {
		val.OffPositionIndicator = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-VirtualAtonFlag: %w", err)
	} else {
		val.VirtualAtonFlag = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AssignedModeFlag: %w", err)
	} else {
		val.AssignedModeFlag = AisAssignedModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-PositionFixingDeviceType: %w", err)
	} else {
		val.PositionFixingDeviceType = PositionFixDeviceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readBinaryData(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonStatus: %w", err)
	} else {
		val.AtonStatus = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for AisAidsToNavigationAtonReport-AtonName: %w", err)
	} else {
		val.AtonName = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Datum struct {
	Info MessageInfo
	LocalDatum string
	DeltaLatitude *float64
	DeltaLongitude *float64
	DeltaAltitude *units.Distance
	ReferenceDatum string
}
func (p Datum ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Datum\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Datum ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeStringFix([]uint8(p.LocalDatum), 32, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.DeltaLatitude, 32, 1e-07, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.DeltaLongitude, 32, 1e-07, 64, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.DeltaAltitude, 32, 0.010000, 96, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.ReferenceDatum), 32, 128 )
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeDatum(Info MessageInfo, stream *DataStream) (any, error) {
	var val Datum
	val.Info = Info
	if v, err := stream.readFixedString(32); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-LocalDatum: %w", err)
	} else {
		val.LocalDatum = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-DeltaLatitude: %w", err)
	} else {
		val.DeltaLatitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-DeltaLongitude: %w", err)
	} else {
		val.DeltaLongitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-DeltaAltitude: %w", err)
	} else {
		val.DeltaAltitude = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(32); err != nil {
		return nil, fmt.Errorf("parse failed for Datum-ReferenceDatum: %w", err)
	} else {
		val.ReferenceDatum = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type UserDatum struct {
	Info MessageInfo
	DeltaX *units.Distance
	DeltaY *units.Distance
	DeltaZ *units.Distance
	RotationInX *float32
	RotationInY *float32
	RotationInZ *float32
	Scale *float32
	EllipsoidSemiMajorAxis *units.Distance
	EllipsoidFlatteningInverse *float32
	DatumName string
}
func (p UserDatum ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"UserDatum\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p UserDatum ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUnit(p.DeltaX, 32, 0.010000, 0, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.DeltaY, 32, 0.010000, 32, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.DeltaZ, 32, 0.010000, 64, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeFloat32(p.RotationInX, 32, 96)
	if err != nil {
		return nil, err
	}
	err = stream.writeFloat32(p.RotationInY, 32, 128)
	if err != nil {
		return nil, err
	}
	err = stream.writeFloat32(p.RotationInZ, 32, 160)
	if err != nil {
		return nil, err
	}
	err = stream.writeFloat32(p.Scale, 32, 192)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.EllipsoidSemiMajorAxis, 32, 0.010000, 224, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeFloat32(p.EllipsoidFlatteningInverse, 32, 256)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.DatumName), 32, 288 )
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeUserDatum(Info MessageInfo, stream *DataStream) (any, error) {
	var val UserDatum
	val.Info = Info
	if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-DeltaX: %w", err)
	} else {
		val.DeltaX = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-DeltaY: %w", err)
	} else {
		val.DeltaY = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-DeltaZ: %w", err)
	} else {
		val.DeltaZ = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-RotationInX: %w", err)
	} else {
		val.RotationInX = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-RotationInY: %w", err)
	} else {
		val.RotationInY = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-RotationInZ: %w", err)
	} else {
		val.RotationInZ = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-Scale: %w", err)
	} else {
		val.Scale = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-EllipsoidSemiMajorAxis: %w", err)
	} else {
		val.EllipsoidSemiMajorAxis = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFloat32(); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-EllipsoidFlatteningInverse: %w", err)
	} else {
		val.EllipsoidFlatteningInverse = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(32); err != nil {
		return nil, fmt.Errorf("parse failed for UserDatum-DatumName: %w", err)
	} else {
		val.DatumName = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type CrossTrackError struct {
	Info MessageInfo
	Sid *uint8
	XteMode ResidualModeConst
	NavigationTerminated YesNoConst
	Xte *units.Distance
}
func (p CrossTrackError ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"CrossTrackError\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p CrossTrackError ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.XteMode), 4, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 12)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.NavigationTerminated), 2, 14)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Xte, 32, 0.010000, 16, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(16, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeCrossTrackError(Info MessageInfo, stream *DataStream) (any, error) {
	var val CrossTrackError
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for CrossTrackError-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for CrossTrackError-XteMode: %w", err)
	} else {
		val.XteMode = ResidualModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for CrossTrackError-NavigationTerminated: %w", err)
	} else {
		val.NavigationTerminated = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for CrossTrackError-Xte: %w", err)
	} else {
		val.Xte = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(16)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type NavigationData struct {
	Info MessageInfo
	Sid *uint8
	DistanceToWaypoint *units.Distance
	CourseBearingReference DirectionReferenceConst
	PerpendicularCrossed YesNoConst
	ArrivalCircleEntered YesNoConst
	CalculationType BearingModeConst
	EtaTime *float32
	EtaDate *uint16
	BearingOriginToDestinationWaypoint *float32
	BearingPositionToDestinationWaypoint *float32
	OriginWaypointNumber *uint32
	DestinationWaypointNumber *uint32
	DestinationLatitude *float64
	DestinationLongitude *float64
	WaypointClosingVelocity *units.Velocity
}
func (p NavigationData ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"NavigationData\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p NavigationData ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.DistanceToWaypoint, 32, 0.010000, 8, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.CourseBearingReference), 2, 40)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.PerpendicularCrossed), 2, 42)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ArrivalCircleEntered), 2, 44)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.CalculationType), 2, 46)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.EtaTime, 32, 0.0001, 48, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.EtaDate, 16, 80)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.BearingOriginToDestinationWaypoint, 16, 0.0001, 96, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.BearingPositionToDestinationWaypoint, 16, 0.0001, 112, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.OriginWaypointNumber, 32, 128)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.DestinationWaypointNumber, 32, 160)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.DestinationLatitude, 32, 1e-07, 192, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.DestinationLongitude, 32, 1e-07, 224, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.WaypointClosingVelocity, 16, 0.010000, 256, 0, true)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeNavigationData(Info MessageInfo, stream *DataStream) (any, error) {
	var val NavigationData
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-DistanceToWaypoint: %w", err)
	} else {
		val.DistanceToWaypoint = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-CourseBearingReference: %w", err)
	} else {
		val.CourseBearingReference = DirectionReferenceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-PerpendicularCrossed: %w", err)
	} else {
		val.PerpendicularCrossed = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-ArrivalCircleEntered: %w", err)
	} else {
		val.ArrivalCircleEntered = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-CalculationType: %w", err)
	} else {
		val.CalculationType = BearingModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-EtaTime: %w", err)
	} else {
		val.EtaTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-EtaDate: %w", err)
	} else {
		val.EtaDate = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-BearingOriginToDestinationWaypoint: %w", err)
	} else {
		val.BearingOriginToDestinationWaypoint = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-BearingPositionToDestinationWaypoint: %w", err)
	} else {
		val.BearingPositionToDestinationWaypoint = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-OriginWaypointNumber: %w", err)
	} else {
		val.OriginWaypointNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-DestinationWaypointNumber: %w", err)
	} else {
		val.DestinationWaypointNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-DestinationLatitude: %w", err)
	} else {
		val.DestinationLatitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-DestinationLongitude: %w", err)
	} else {
		val.DestinationLongitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationData-WaypointClosingVelocity: %w", err)
	} else {
		val.WaypointClosingVelocity = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type NavigationRouteWpInformation struct {
	Info MessageInfo
	StartRps *uint16
	Nitems *uint16
	DatabaseId *uint16
	RouteId *uint16
	NavigationDirectionInRoute DirectionConst
	SupplementaryRouteWpDataAvailable OffOnConst
	RouteName string
	Repeating1 []NavigationRouteWpInformationRepeating1
}
type NavigationRouteWpInformationRepeating1 struct {
	WpId *uint16
	WpName string
	WpLatitude *float64
	WpLongitude *float64
}
func (p NavigationRouteWpInformation ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint16(p.Repeating1[index].WpId, 16, 0)
	if err != nil {
		return err
	}
	err = stream.writeStringLau(p.Repeating1[index].WpName, 0 )
	if err != nil {
		return err
	}
	err = stream.writeSignedResolution64(p.Repeating1[index].WpLatitude, 32, 1e-07, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeSignedResolution64(p.Repeating1[index].WpLongitude, 32, 1e-07, 0, 0)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p NavigationRouteWpInformation ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"NavigationRouteWpInformation\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p NavigationRouteWpInformation ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint16(p.StartRps, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.Nitems, 16, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.DatabaseId, 16, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.RouteId, 16, 48)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.NavigationDirectionInRoute), 3, 64)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SupplementaryRouteWpDataAvailable), 2, 67)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(3, 69)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringLau(p.RouteName, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 0)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeNavigationRouteWpInformation(Info MessageInfo, stream *DataStream) (any, error) {
	var val NavigationRouteWpInformation
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-StartRps: %w", err)
	} else {
		val.StartRps = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-Nitems: %w", err)
	} else {
		val.Nitems = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-DatabaseId: %w", err)
	} else {
		val.DatabaseId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-RouteId: %w", err)
	} else {
		val.RouteId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-NavigationDirectionInRoute: %w", err)
	} else {
		val.NavigationDirectionInRoute = DirectionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-SupplementaryRouteWpDataAvailable: %w", err)
	} else {
		val.SupplementaryRouteWpDataAvailable = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-RouteName: %w", err)
	} else {
		val.RouteName = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]NavigationRouteWpInformationRepeating1, 0)
	i := 0 
	for {
		var rep NavigationRouteWpInformationRepeating1
		if v, err := stream.readUInt16(16); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpId: %w", err)
		} else {
			rep.WpId = v
		}
		if v, err := stream.readStringWithLengthAndControl(); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpName: %w", err)
		} else {
			rep.WpName = v
		}
		if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpLatitude: %w", err)
		} else {
			rep.WpLatitude = v
		}
		if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
			return nil, fmt.Errorf("parse failed for NavigationRouteWpInformation-WpLongitude: %w", err)
		} else {
			rep.WpLongitude = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type GnssDops struct {
	Info MessageInfo
	Sid *uint8
	DesiredMode GnssModeConst
	ActualMode GnssModeConst
	Hdop *float32
	Vdop *float32
	Tdop *float32
}
func (p GnssDops ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GnssDops\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GnssDops ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.DesiredMode), 3, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ActualMode), 3, 11)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 14)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Hdop, 16, 0.01, 16, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Vdop, 16, 0.01, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Tdop, 16, 0.01, 48, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeGnssDops(Info MessageInfo, stream *DataStream) (any, error) {
	var val GnssDops
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-DesiredMode: %w", err)
	} else {
		val.DesiredMode = GnssModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-ActualMode: %w", err)
	} else {
		val.ActualMode = GnssModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-Hdop: %w", err)
	} else {
		val.Hdop = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-Vdop: %w", err)
	} else {
		val.Vdop = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for GnssDops-Tdop: %w", err)
	} else {
		val.Tdop = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type GnssSatsInView struct {
	Info MessageInfo
	Sid *uint8
	RangeResidualMode RangeResidualModeConst
	SatsInView *uint8
	Repeating1 []GnssSatsInViewRepeating1
}
type GnssSatsInViewRepeating1 struct {
	Prn *uint8
	Elevation *float32
	Azimuth *float32
	Snr *float32
	RangeResiduals *int32
	Status SatelliteStatusConst
}
func (p GnssSatsInView ) encodeRepeating1(stream *DataStream) error {
	var err error
	for index := range p.Repeating1 {
	err = stream.writeUint8(p.Repeating1[index].Prn, 8, 0)
	if err != nil {
		return err
	}
	err = stream.writeSignedResolution32(p.Repeating1[index].Elevation, 16, 0.0001, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].Azimuth, 16, 0.0001, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeUnsignedResolution32(p.Repeating1[index].Snr, 16, 0.01, 0, 0)
	if err != nil {
		return err
	}
	err = stream.writeInt32(p.Repeating1[index].RangeResiduals, 32, 0)
	if err != nil {
		return err
	}
	err = stream.putNumberRaw(uint64(p.Repeating1[index].Status), 4, 0)
	if err != nil {
		return err
	}
	err = stream.writeReserved(4, 0)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p GnssSatsInView ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"GnssSatsInView\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p GnssSatsInView ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RangeResidualMode), 2, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 10)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SatsInView, 8, 16)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeGnssSatsInView(Info MessageInfo, stream *DataStream) (any, error) {
	var val GnssSatsInView
	val.Info = Info
		var repeat1Count uint16 = 0
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssSatsInView-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for GnssSatsInView-RangeResidualMode: %w", err)
	} else {
		val.RangeResidualMode = RangeResidualModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for GnssSatsInView-SatsInView: %w", err)
	} else {
		val.SatsInView = v
		if v != nil {
			repeat1Count = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
		if repeat1Count == 0 {
			return val, nil
		}
	val.Repeating1 = make([]GnssSatsInViewRepeating1, 0)
	i := 0 
	for {
		var rep GnssSatsInViewRepeating1
		if v, err := stream.readUInt8(8); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Prn: %w", err)
		} else {
			rep.Prn = v
		}
		if v, err := stream.readSignedResolution(16, 0.0001, 0); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Elevation: %w", err)
		} else {
			rep.Elevation = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Azimuth: %w", err)
		} else {
			rep.Azimuth = v
		}
		if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Snr: %w", err)
		} else {
			rep.Snr = v
		}
		if v, err := stream.readInt32(32); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-RangeResiduals: %w", err)
		} else {
			rep.RangeResiduals = v
		}
		if v, err := stream.readLookupField(4); err != nil {
			return nil, fmt.Errorf("parse failed for GnssSatsInView-Status: %w", err)
		} else {
			rep.Status = SatelliteStatusConst(v)
		}
		stream.skipBits(4)
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type AisClassAStaticAndVoyageRelatedData struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	ImoNumber *uint32
	Callsign string
	Name string
	TypeOfShip ShipTypeConst
	Length *units.Distance
	Beam *units.Distance
	PositionReferenceFromStarboard *units.Distance
	PositionReferenceFromBow *units.Distance
	EtaDate *uint16
	EtaTime *float32
	Draft *units.Distance
	Destination string
	AisVersionIndicator AisVersionConst
	GnssType PositionFixDeviceConst
	Dte AvailableConst
	AisTransceiverInformation AisTransceiverConst
}
func (p AisClassAStaticAndVoyageRelatedData ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisClassAStaticAndVoyageRelatedData\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisClassAStaticAndVoyageRelatedData ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.UserId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.ImoNumber, 32, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.Callsign), 56, 72 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.Name), 160, 128 )
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TypeOfShip), 8, 288)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Length, 16, 0.100000, 296, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Beam, 16, 0.100000, 312, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.PositionReferenceFromStarboard, 16, 0.100000, 328, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.PositionReferenceFromBow, 16, 0.100000, 344, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.EtaDate, 16, 360)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.EtaTime, 32, 0.0001, 376, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Draft, 16, 0.010000, 408, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.Destination), 160, 424 )
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisVersionIndicator), 2, 584)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.GnssType), 4, 586)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Dte), 1, 590)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(1, 591)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 592)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(3, 597)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisClassAStaticAndVoyageRelatedData(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisClassAStaticAndVoyageRelatedData
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-UserId: %w", err)
	} else {
		val.UserId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-ImoNumber: %w", err)
	} else {
		val.ImoNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(56); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Callsign: %w", err)
	} else {
		val.Callsign = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(160); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Name: %w", err)
	} else {
		val.Name = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-TypeOfShip: %w", err)
	} else {
		val.TypeOfShip = ShipTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Length: %w", err)
	} else {
		val.Length = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Beam: %w", err)
	} else {
		val.Beam = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-PositionReferenceFromStarboard: %w", err)
	} else {
		val.PositionReferenceFromStarboard = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-PositionReferenceFromBow: %w", err)
	} else {
		val.PositionReferenceFromBow = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-EtaDate: %w", err)
	} else {
		val.EtaDate = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-EtaTime: %w", err)
	} else {
		val.EtaTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Draft: %w", err)
	} else {
		val.Draft = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(160); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Destination: %w", err)
	} else {
		val.Destination = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-AisVersionIndicator: %w", err)
	} else {
		val.AisVersionIndicator = AisVersionConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-GnssType: %w", err)
	} else {
		val.GnssType = PositionFixDeviceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-Dte: %w", err)
	} else {
		val.Dte = AvailableConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassAStaticAndVoyageRelatedData-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AisAddressedBinaryMessage struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	SequenceNumber *uint8
	DestinationId *uint32
	RetransmitFlag *uint8
	NumberOfBitsInBinaryDataField *uint16
	BinaryData []uint8
}
func (p AisAddressedBinaryMessage ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisAddressedBinaryMessage\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisAddressedBinaryMessage ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
		var binaryLength uint16
		if p.NumberOfBitsInBinaryDataField != nil {
			binaryLength = *p.NumberOfBitsInBinaryDataField
		}
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.SourceId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(1, 40)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 41)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SequenceNumber, 2, 46)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.DestinationId, 32, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 80)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.RetransmitFlag, 1, 86)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(1, 87)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.NumberOfBitsInBinaryDataField, 16, 88)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.BinaryData,binaryLength, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisAddressedBinaryMessage(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisAddressedBinaryMessage
	val.Info = Info
		var binaryLength uint16 = 0
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-SourceId: %w", err)
	} else {
		val.SourceId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-SequenceNumber: %w", err)
	} else {
		val.SequenceNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-DestinationId: %w", err)
	} else {
		val.DestinationId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(1); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-RetransmitFlag: %w", err)
	} else {
		val.RetransmitFlag = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-NumberOfBitsInBinaryDataField: %w", err)
	} else {
		val.NumberOfBitsInBinaryDataField = v
		if v != nil {
			binaryLength = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(binaryLength); err != nil {
		return nil, fmt.Errorf("parse failed for AisAddressedBinaryMessage-BinaryData: %w", err)
	} else {
		val.BinaryData = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisAcknowledge struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	DestinationId1 *uint32
	SequenceNumberForId1 []uint8
	SequenceNumberForIdN []uint8
}
func (p AisAcknowledge ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisAcknowledge\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisAcknowledge ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.SourceId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(1, 40)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 41)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 46)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.DestinationId1, 32, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.SequenceNumberForId1, 2, 80 )
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 82)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.SequenceNumberForIdN, 2, 88 )
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 90)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisAcknowledge(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisAcknowledge
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-SourceId: %w", err)
	} else {
		val.SourceId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-DestinationId1: %w", err)
	} else {
		val.DestinationId1 = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-SequenceNumberForId1: %w", err)
	} else {
		val.SequenceNumberForId1 = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readBinaryData(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisAcknowledge-SequenceNumberForIdN: %w", err)
	} else {
		val.SequenceNumberForIdN = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type AisBinaryBroadcastMessage struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	SourceId *uint32
	AisTransceiverInformation AisTransceiverConst
	NumberOfBitsInBinaryDataField *uint16
	BinaryData []uint8
}
func (p AisBinaryBroadcastMessage ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisBinaryBroadcastMessage\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisBinaryBroadcastMessage ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
		var binaryLength uint16
		if p.NumberOfBitsInBinaryDataField != nil {
			binaryLength = *p.NumberOfBitsInBinaryDataField
		}
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.SourceId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(1, 40)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 41)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 46)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.NumberOfBitsInBinaryDataField, 16, 48)
	if err != nil {
		return nil, err
	}
	err = stream.writeBinary(p.BinaryData,binaryLength, 0)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisBinaryBroadcastMessage(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisBinaryBroadcastMessage
	val.Info = Info
		var binaryLength uint16 = 0
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-SourceId: %w", err)
	} else {
		val.SourceId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(1)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-NumberOfBitsInBinaryDataField: %w", err)
	} else {
		val.NumberOfBitsInBinaryDataField = v
		if v != nil {
			binaryLength = uint16(*v)
		}

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readBinaryData(binaryLength); err != nil {
		return nil, fmt.Errorf("parse failed for AisBinaryBroadcastMessage-BinaryData: %w", err)
	} else {
		val.BinaryData = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisClassBStaticDataMsg24PartA struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	Name string
	AisTransceiverInformation AisTransceiverConst
	SequenceId *uint8
}
func (p AisClassBStaticDataMsg24PartA ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisClassBStaticDataMsg24PartA\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisClassBStaticDataMsg24PartA ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.UserId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.Name), 160, 40 )
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 200)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(3, 205)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SequenceId, 8, 208)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisClassBStaticDataMsg24PartA(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisClassBStaticDataMsg24PartA
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-UserId: %w", err)
	} else {
		val.UserId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(160); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-Name: %w", err)
	} else {
		val.Name = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartA-SequenceId: %w", err)
	} else {
		val.SequenceId = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type AisClassBStaticDataMsg24PartB struct {
	Info MessageInfo
	MessageId AisMessageIdConst
	RepeatIndicator RepeatIndicatorConst
	UserId *uint32
	TypeOfShip ShipTypeConst
	VendorId string
	Callsign string
	Length *units.Distance
	Beam *units.Distance
	PositionReferenceFromStarboard *units.Distance
	PositionReferenceFromBow *units.Distance
	MothershipUserId *uint32
	GnssType PositionFixDeviceConst
	AisTransceiverInformation AisTransceiverConst
	SequenceId *uint8
}
func (p AisClassBStaticDataMsg24PartB ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"AisClassBStaticDataMsg24PartB\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p AisClassBStaticDataMsg24PartB ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.MessageId), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RepeatIndicator), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.UserId, 32, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TypeOfShip), 8, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.VendorId), 56, 48 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringFix([]uint8(p.Callsign), 56, 104 )
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Length, 16, 0.100000, 160, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Beam, 16, 0.100000, 176, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.PositionReferenceFromStarboard, 16, 0.100000, 192, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.PositionReferenceFromBow, 16, 0.100000, 208, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.MothershipUserId, 32, 224)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 256)
	if err != nil {
		return nil, err
	}
	err = stream.writeSpare(2, 258)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.GnssType), 4, 260)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.AisTransceiverInformation), 5, 264)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(3, 269)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.SequenceId, 8, 272)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeAisClassBStaticDataMsg24PartB(Info MessageInfo, stream *DataStream) (any, error) {
	var val AisClassBStaticDataMsg24PartB
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-MessageId: %w", err)
	} else {
		val.MessageId = AisMessageIdConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-RepeatIndicator: %w", err)
	} else {
		val.RepeatIndicator = RepeatIndicatorConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-UserId: %w", err)
	} else {
		val.UserId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-TypeOfShip: %w", err)
	} else {
		val.TypeOfShip = ShipTypeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(56); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-VendorId: %w", err)
	} else {
		val.VendorId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readFixedString(56); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Callsign: %w", err)
	} else {
		val.Callsign = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Length: %w", err)
	} else {
		val.Length = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-Beam: %w", err)
	} else {
		val.Beam = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-PositionReferenceFromStarboard: %w", err)
	} else {
		val.PositionReferenceFromStarboard = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-PositionReferenceFromBow: %w", err)
	} else {
		val.PositionReferenceFromBow = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-MothershipUserId: %w", err)
	} else {
		val.MothershipUserId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-GnssType: %w", err)
	} else {
		val.GnssType = PositionFixDeviceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(5); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-AisTransceiverInformation: %w", err)
	} else {
		val.AisTransceiverInformation = AisTransceiverConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(3)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for AisClassBStaticDataMsg24PartB-SequenceId: %w", err)
	} else {
		val.SequenceId = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type WindData struct {
	Info MessageInfo
	Sid *uint8
	WindSpeed *units.Velocity
	WindAngle *float32
	Reference WindReferenceConst
}
func (p WindData ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"WindData\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p WindData ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.WindSpeed, 16, 0.010000, 8, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.WindAngle, 16, 0.0001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Reference), 3, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(21, 43)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeWindData(Info MessageInfo, stream *DataStream) (any, error) {
	var val WindData
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for WindData-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WindData-WindSpeed: %w", err)
	} else {
		val.WindSpeed = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WindData-WindAngle: %w", err)
	} else {
		val.WindAngle = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for WindData-Reference: %w", err)
	} else {
		val.Reference = WindReferenceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(21)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type EnvironmentalParametersObsolete struct {
	Info MessageInfo
	Sid *uint8
	WaterTemperature *units.Temperature
	OutsideAmbientAirTemperature *units.Temperature
	AtmosphericPressure *units.Pressure
}
func (p EnvironmentalParametersObsolete ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"EnvironmentalParametersObsolete\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p EnvironmentalParametersObsolete ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.WaterTemperature, 16, 0.010000, 8, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.OutsideAmbientAirTemperature, 16, 0.010000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.AtmosphericPressure, 16, 100.000000, 40, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeEnvironmentalParametersObsolete(Info MessageInfo, stream *DataStream) (any, error) {
	var val EnvironmentalParametersObsolete
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-WaterTemperature: %w", err)
	} else {
		val.WaterTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-OutsideAmbientAirTemperature: %w", err)
	} else {
		val.OutsideAmbientAirTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParametersObsolete-AtmosphericPressure: %w", err)
	} else {
		val.AtmosphericPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type EnvironmentalParameters struct {
	Info MessageInfo
	Sid *uint8
	TemperatureSource TemperatureSourceConst
	HumiditySource HumiditySourceConst
	Temperature *units.Temperature
	Humidity *float32
	AtmosphericPressure *units.Pressure
}
func (p EnvironmentalParameters ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"EnvironmentalParameters\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p EnvironmentalParameters ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TemperatureSource), 6, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.HumiditySource), 2, 14)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Temperature, 16, 0.010000, 16, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.Humidity, 16, 0.004, 32, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.AtmosphericPressure, 16, 100.000000, 48, 0, false)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeEnvironmentalParameters(Info MessageInfo, stream *DataStream) (any, error) {
	var val EnvironmentalParameters
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-TemperatureSource: %w", err)
	} else {
		val.TemperatureSource = TemperatureSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-HumiditySource: %w", err)
	} else {
		val.HumiditySource = HumiditySourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Temperature: %w", err)
	} else {
		val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.004, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-Humidity: %w", err)
	} else {
		val.Humidity = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
		return nil, fmt.Errorf("parse failed for EnvironmentalParameters-AtmosphericPressure: %w", err)
	} else {
		val.AtmosphericPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type Temperature struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source TemperatureSourceConst
	ActualTemperature *units.Temperature
	SetTemperature *units.Temperature
}
func (p Temperature ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Temperature\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Temperature ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Source), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.ActualTemperature, 16, 0.010000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SetTemperature, 16, 0.010000, 40, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeTemperature(Info MessageInfo, stream *DataStream) (any, error) {
	var val Temperature
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-Source: %w", err)
	} else {
		val.Source = TemperatureSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-ActualTemperature: %w", err)
	} else {
		val.ActualTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Temperature-SetTemperature: %w", err)
	} else {
		val.SetTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type Humidity struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source HumiditySourceConst
	ActualHumidity *float32
	SetHumidity *float32
}
func (p Humidity ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"Humidity\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p Humidity ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Source), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.ActualHumidity, 16, 0.004, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution32(p.SetHumidity, 16, 0.004, 40, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeHumidity(Info MessageInfo, stream *DataStream) (any, error) {
	var val Humidity
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-Source: %w", err)
	} else {
		val.Source = HumiditySourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.004, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-ActualHumidity: %w", err)
	} else {
		val.ActualHumidity = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.004, 0); err != nil {
		return nil, fmt.Errorf("parse failed for Humidity-SetHumidity: %w", err)
	} else {
		val.SetHumidity = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type ActualPressure struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source PressureSourceConst
	Pressure *units.Pressure
}
func (p ActualPressure ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"ActualPressure\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p ActualPressure ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Source), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Pressure, 32, 0.100000, 24, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeActualPressure(Info MessageInfo, stream *DataStream) (any, error) {
	var val ActualPressure
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ActualPressure-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for ActualPressure-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for ActualPressure-Source: %w", err)
	} else {
		val.Source = PressureSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(32, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for ActualPressure-Pressure: %w", err)
	} else {
		val.Pressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type SetPressure struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source PressureSourceConst
	Pressure *units.Pressure
}
func (p SetPressure ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SetPressure\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SetPressure ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Source), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Pressure, 32, 0.100000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 56)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSetPressure(Info MessageInfo, stream *DataStream) (any, error) {
	var val SetPressure
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SetPressure-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SetPressure-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SetPressure-Source: %w", err)
	} else {
		val.Source = PressureSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for SetPressure-Pressure: %w", err)
	} else {
		val.Pressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type TemperatureExtendedRange struct {
	Info MessageInfo
	Sid *uint8
	Instance *uint8
	Source TemperatureSourceConst
	Temperature *units.Temperature
	SetTemperature *units.Temperature
}
func (p TemperatureExtendedRange ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"TemperatureExtendedRange\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p TemperatureExtendedRange ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUint8(p.Sid, 8, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Source), 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.Temperature, 24, 0.001000, 24, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SetTemperature, 16, 0.100000, 48, 0, false)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeTemperatureExtendedRange(Info MessageInfo, stream *DataStream) (any, error) {
	var val TemperatureExtendedRange
	val.Info = Info
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Source: %w", err)
	} else {
		val.Source = TemperatureSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(24, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-Temperature: %w", err)
	} else {
		val.Temperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TemperatureExtendedRange-SetTemperature: %w", err)
	} else {
		val.SetTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type TideStationData struct {
	Info MessageInfo
	Mode ResidualModeConst
	TideTendency TideConst
	MeasurementDate *uint16
	MeasurementTime *float32
	StationLatitude *float64
	StationLongitude *float64
	TideLevel *units.Distance
	TideLevelStandardDeviation *units.Distance
	StationId string
	StationName string
}
func (p TideStationData ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"TideStationData\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p TideStationData ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.Mode), 4, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.TideTendency), 2, 4)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.MeasurementDate, 16, 8)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.MeasurementTime, 32, 0.0001, 24, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.StationLatitude, 32, 1e-07, 56, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeSignedResolution64(p.StationLongitude, 32, 1e-07, 88, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.TideLevel, 16, 0.001000, 120, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.TideLevelStandardDeviation, 16, 0.010000, 136, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeStringLau(p.StationId, 0 )
	if err != nil {
		return nil, err
	}
	err = stream.writeStringLau(p.StationName, 0 )
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeTideStationData(Info MessageInfo, stream *DataStream) (any, error) {
	var val TideStationData
	val.Info = Info
	if v, err := stream.readLookupField(4); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-Mode: %w", err)
	} else {
		val.Mode = ResidualModeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-TideTendency: %w", err)
	} else {
		val.TideTendency = TideConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-MeasurementDate: %w", err)
	} else {
		val.MeasurementDate = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-MeasurementTime: %w", err)
	} else {
		val.MeasurementTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-StationLatitude: %w", err)
	} else {
		val.StationLatitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution64Override(32, 1e-07); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-StationLongitude: %w", err)
	} else {
		val.StationLongitude = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-TideLevel: %w", err)
	} else {
		val.TideLevel = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-TideLevelStandardDeviation: %w", err)
	} else {
		val.TideLevelStandardDeviation = nullableUnit(units.Meter, v, units.NewDistance)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-StationId: %w", err)
	} else {
		val.StationId = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readStringWithLengthAndControl(); err != nil {
		return nil, fmt.Errorf("parse failed for TideStationData-StationName: %w", err)
	} else {
		val.StationName = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type WatermakerInputSettingAndStatus struct {
	Info MessageInfo
	WatermakerOperatingState WatermakerStateConst
	ProductionStartStop YesNoConst
	RinseStartStop YesNoConst
	LowPressurePumpStatus YesNoConst
	HighPressurePumpStatus YesNoConst
	EmergencyStop YesNoConst
	ProductSolenoidValveStatus OkWarningConst
	FlushModeStatus YesNoConst
	SalinityStatus OkWarningConst
	SensorStatus OkWarningConst
	OilChangeIndicatorStatus OkWarningConst
	FilterStatus OkWarningConst
	SystemStatus OkWarningConst
	Salinity *uint16
	ProductWaterTemperature *units.Temperature
	PreFilterPressure *units.Pressure
	PostFilterPressure *units.Pressure
	FeedPressure *units.Pressure
	SystemHighPressure *units.Pressure
	ProductWaterFlow *units.Flow
	BrineWaterFlow *units.Flow
	RunTime *uint32
}
func (p WatermakerInputSettingAndStatus ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"WatermakerInputSettingAndStatus\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p WatermakerInputSettingAndStatus ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.WatermakerOperatingState), 6, 0)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProductionStartStop), 2, 6)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.RinseStartStop), 2, 8)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.LowPressurePumpStatus), 2, 10)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.HighPressurePumpStatus), 2, 12)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.EmergencyStop), 2, 14)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProductSolenoidValveStatus), 2, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.FlushModeStatus), 2, 18)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SalinityStatus), 2, 20)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SensorStatus), 2, 22)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.OilChangeIndicatorStatus), 2, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.FilterStatus), 2, 26)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SystemStatus), 2, 28)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 30)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.Salinity, 16, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.ProductWaterTemperature, 16, 0.010000, 48, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.PreFilterPressure, 16, 100.000000, 64, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.PostFilterPressure, 16, 100.000000, 80, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.FeedPressure, 16, 1000.000000, 96, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SystemHighPressure, 16, 1000.000000, 112, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.ProductWaterFlow, 16, 0.100000, 128, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.BrineWaterFlow, 16, 0.100000, 144, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.RunTime, 32, 160)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeWatermakerInputSettingAndStatus(Info MessageInfo, stream *DataStream) (any, error) {
	var val WatermakerInputSettingAndStatus
	val.Info = Info
	if v, err := stream.readLookupField(6); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-WatermakerOperatingState: %w", err)
	} else {
		val.WatermakerOperatingState = WatermakerStateConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductionStartStop: %w", err)
	} else {
		val.ProductionStartStop = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-RinseStartStop: %w", err)
	} else {
		val.RinseStartStop = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-LowPressurePumpStatus: %w", err)
	} else {
		val.LowPressurePumpStatus = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-HighPressurePumpStatus: %w", err)
	} else {
		val.HighPressurePumpStatus = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-EmergencyStop: %w", err)
	} else {
		val.EmergencyStop = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductSolenoidValveStatus: %w", err)
	} else {
		val.ProductSolenoidValveStatus = OkWarningConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FlushModeStatus: %w", err)
	} else {
		val.FlushModeStatus = YesNoConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SalinityStatus: %w", err)
	} else {
		val.SalinityStatus = OkWarningConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SensorStatus: %w", err)
	} else {
		val.SensorStatus = OkWarningConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-OilChangeIndicatorStatus: %w", err)
	} else {
		val.OilChangeIndicatorStatus = OkWarningConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FilterStatus: %w", err)
	} else {
		val.FilterStatus = OkWarningConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SystemStatus: %w", err)
	} else {
		val.SystemStatus = OkWarningConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-Salinity: %w", err)
	} else {
		val.Salinity = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.01, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductWaterTemperature: %w", err)
	} else {
		val.ProductWaterTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-PreFilterPressure: %w", err)
	} else {
		val.PreFilterPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 100, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-PostFilterPressure: %w", err)
	} else {
		val.PostFilterPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 1000, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-FeedPressure: %w", err)
	} else {
		val.FeedPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 1000, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-SystemHighPressure: %w", err)
	} else {
		val.SystemHighPressure = nullableUnit(units.Pa, v, units.NewPressure)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-ProductWaterFlow: %w", err)
	} else {
		val.ProductWaterFlow = nullableUnit(units.LitersPerHour, v, units.NewFlow)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-BrineWaterFlow: %w", err)
	} else {
		val.BrineWaterFlow = nullableUnit(units.LitersPerHour, v, units.NewFlow)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for WatermakerInputSettingAndStatus-RunTime: %w", err)
	} else {
		val.RunTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type VesselSpeedComponents struct {
	Info MessageInfo
	LongitudinalSpeedWaterReferenced *units.Velocity
	TransverseSpeedWaterReferenced *units.Velocity
	LongitudinalSpeedGroundReferenced *units.Velocity
	TransverseSpeedGroundReferenced *units.Velocity
	SternSpeedWaterReferenced *units.Velocity
	SternSpeedGroundReferenced *units.Velocity
}
func (p VesselSpeedComponents ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"VesselSpeedComponents\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p VesselSpeedComponents ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.writeUnit(p.LongitudinalSpeedWaterReferenced, 16, 0.001000, 0, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.TransverseSpeedWaterReferenced, 16, 0.001000, 16, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.LongitudinalSpeedGroundReferenced, 16, 0.001000, 32, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.TransverseSpeedGroundReferenced, 16, 0.001000, 48, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SternSpeedWaterReferenced, 16, 0.001000, 64, 0, true)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SternSpeedGroundReferenced, 16, 0.001000, 80, 0, true)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeVesselSpeedComponents(Info MessageInfo, stream *DataStream) (any, error) {
	var val VesselSpeedComponents
	val.Info = Info
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-LongitudinalSpeedWaterReferenced: %w", err)
	} else {
		val.LongitudinalSpeedWaterReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-TransverseSpeedWaterReferenced: %w", err)
	} else {
		val.TransverseSpeedWaterReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-LongitudinalSpeedGroundReferenced: %w", err)
	} else {
		val.LongitudinalSpeedGroundReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-TransverseSpeedGroundReferenced: %w", err)
	} else {
		val.TransverseSpeedGroundReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-SternSpeedWaterReferenced: %w", err)
	} else {
		val.SternSpeedWaterReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readSignedResolution(16, 0.001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for VesselSpeedComponents-SternSpeedGroundReferenced: %w", err)
	} else {
		val.SternSpeedGroundReferenced = nullableUnit(units.MetersPerSecond, v, units.NewVelocity)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type SonichubVolume struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	ProprietaryId SonichubCommandConst
	Control SonichubControlConst
	Zone *uint8
	Level *uint8
}
func (p SonichubVolume ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"SonichubVolume\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p SonichubVolume ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.ProprietaryId), 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Control), 8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Zone, 8, 40)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Level, 8, 48)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeSonichubVolume(Info MessageInfo, stream *DataStream) (any, error) {
	var val SonichubVolume
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-ManufacturerCode: %w", err)
	} else {
		if v != 275 {
			return nil, fmt.Errorf("match failed for SonichubVolume-ManufacturerCode: Expected %d != %d", 275, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for SonichubVolume-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(8)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-ProprietaryId: %w", err)
	} else {
		if v != 24 {
			return nil, fmt.Errorf("match failed for SonichubVolume-ProprietaryId: Expected %d != %d", 24, v)
		}
		val.ProprietaryId = SonichubCommandConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-Control: %w", err)
	} else {
		val.Control = SonichubControlConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-Zone: %w", err)
	} else {
		val.Zone = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for SonichubVolume-Level: %w", err)
	} else {
		val.Level = v

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type MaretronProprietaryTemperatureHighRange struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Sid *uint8
	Instance *uint8
	Source TemperatureSourceConst
	ActualTemperature *units.Temperature
	SetTemperature *units.Temperature
}
func (p MaretronProprietaryTemperatureHighRange ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"MaretronProprietaryTemperatureHighRange\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p MaretronProprietaryTemperatureHighRange ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Sid, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.Source), 8, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.ActualTemperature, 16, 0.100000, 40, 0, false)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnit(p.SetTemperature, 16, 0.100000, 56, 0, false)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeMaretronProprietaryTemperatureHighRange(Info MessageInfo, stream *DataStream) (any, error) {
	var val MaretronProprietaryTemperatureHighRange
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronProprietaryTemperatureHighRange-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronProprietaryTemperatureHighRange-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Sid: %w", err)
	} else {
		val.Sid = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-Source: %w", err)
	} else {
		val.Source = TemperatureSourceConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-ActualTemperature: %w", err)
	} else {
		val.ActualTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(16, 0.1, 0); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronProprietaryTemperatureHighRange-SetTemperature: %w", err)
	} else {
		val.SetTemperature = nullableUnit(units.Kelvin, v, units.NewTemperature)

		if stream.isEOF() {
			return val, nil
		} 
	}	
	return val, nil
}
type BGKeyValueData struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Repeating1 []BGKeyValueDataRepeating1
}
type BGKeyValueDataRepeating1 struct {
	Key BandgKeyValueConst
	Length *uint8
	Value []uint8
}
func (p BGKeyValueData ) encodeRepeating1(stream *DataStream) error {
		var valueLength uint16
	var err error
	for index := range p.Repeating1 {
	err = stream.putNumberRaw(uint64(p.Repeating1[index].Key), 12, 0)
	if err != nil {
		return err
	}
	if p.Repeating1[index].Length != nil {
		valueLength = uint16(*p.Repeating1[index].Length) * 8
	}
	err = stream.writeUint8(p.Repeating1[index].Length, 4, 0)
	if err != nil {
		return err
	}
	err = stream.writeBinary(p.Repeating1[index].Value, valueLength, 0)
	if err != nil {
		return err
	}
	}
	return nil
}
func (p BGKeyValueData ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"BGKeyValueData\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p BGKeyValueData ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = p.encodeRepeating1(stream)
	if err != nil {
		return nil, err
		}
	return &p.Info, err
}
func DecodeBGKeyValueData(Info MessageInfo, stream *DataStream) (any, error) {
	var val BGKeyValueData
	val.Info = Info
		var repeat1Count uint16 = 0
		var valueLength uint16
	
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for BGKeyValueData-ManufacturerCode: %w", err)
	} else {
		if v != 381 {
			return nil, fmt.Errorf("match failed for BGKeyValueData-ManufacturerCode: Expected %d != %d", 381, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for BGKeyValueData-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for BGKeyValueData-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	val.Repeating1 = make([]BGKeyValueDataRepeating1, 0)
	i := 0 
	for {
		var rep BGKeyValueDataRepeating1
		if v, err := stream.readLookupField(12); err != nil {
			return nil, fmt.Errorf("parse failed for BGKeyValueData-Key: %w", err)
		} else {
			rep.Key = BandgKeyValueConst(v)
		}
		if v, err := stream.readUInt8(4); err != nil {
			return nil, fmt.Errorf("parse failed for BGKeyValueData-Length: %w", err)
		} else {
			rep.Length = v
			if v != nil {
				valueLength = uint16(*v) * 8
			}
		
		}
		if v, err := stream.readBinaryData(valueLength); err != nil {
			return nil, fmt.Errorf("parse failed for BGKeyValueData-Value: %w", err)
		} else {
			rep.Value = v
		}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	}	
	return val, nil
}
type MaretronSwitchStatusCounter struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Instance *uint8
	IndicatorNumber *uint8
	StartDate *uint16
	StartTime *float32
	OffCounter *uint32
	OnCounter *uint32
	ErrorCounter *uint32
	SwitchStatus OffOnConst
}
func (p MaretronSwitchStatusCounter ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"MaretronSwitchStatusCounter\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p MaretronSwitchStatusCounter ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.IndicatorNumber, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.StartDate, 16, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.StartTime, 32, 0.0001, 48, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.OffCounter, 32, 80)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.OnCounter, 32, 112)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.ErrorCounter, 32, 144)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SwitchStatus), 2, 176)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 178)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeMaretronSwitchStatusCounter(Info MessageInfo, stream *DataStream) (any, error) {
	var val MaretronSwitchStatusCounter
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronSwitchStatusCounter-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronSwitchStatusCounter-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-IndicatorNumber: %w", err)
	} else {
		val.IndicatorNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-StartDate: %w", err)
	} else {
		val.StartDate = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-StartTime: %w", err)
	} else {
		val.StartTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-OffCounter: %w", err)
	} else {
		val.OffCounter = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-OnCounter: %w", err)
	} else {
		val.OnCounter = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-ErrorCounter: %w", err)
	} else {
		val.ErrorCounter = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusCounter-SwitchStatus: %w", err)
	} else {
		val.SwitchStatus = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
type MaretronSwitchStatusTimer struct {
	Info MessageInfo
	ManufacturerCode ManufacturerCodeConst
	IndustryCode IndustryCodeConst
	Instance *uint8
	IndicatorNumber *uint8
	StartDate *uint16
	StartTime *float32
	AccumulatedOffPeriod *uint32
	AccumulatedOnPeriod *uint32
	AccumulatedErrorPeriod *uint32
	SwitchStatus OffOnConst
}
func (p MaretronSwitchStatusTimer ) Marshal() ([]byte, error) {
	var pre, post []byte
	pre = []byte("{ \"MaretronSwitchStatusTimer\":")
	post = []byte("}")
	ret, err :=  json.Marshal(p)
	if err != nil {
		return nil, err
		}
	pre = append(pre, ret...)
	pre = append(pre, post...)
	 return pre, nil
}
func (p MaretronSwitchStatusTimer ) Encode(stream *DataStream) (*MessageInfo, error) {
	var err error
	err = stream.putNumberRaw(uint64(p.ManufacturerCode), 11, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(2, 11)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.IndustryCode), 3, 13)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.Instance, 8, 16)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint8(p.IndicatorNumber, 8, 24)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint16(p.StartDate, 16, 32)
	if err != nil {
		return nil, err
	}
	err = stream.writeUnsignedResolution32(p.StartTime, 32, 0.0001, 48, 0)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.AccumulatedOffPeriod, 32, 80)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.AccumulatedOnPeriod, 32, 112)
	if err != nil {
		return nil, err
	}
	err = stream.writeUint32(p.AccumulatedErrorPeriod, 32, 144)
	if err != nil {
		return nil, err
	}
	err = stream.putNumberRaw(uint64(p.SwitchStatus), 2, 176)
	if err != nil {
		return nil, err
	}
	err = stream.writeReserved(6, 178)
	if err != nil {
		return nil, err
	}
	return &p.Info, err
}
func DecodeMaretronSwitchStatusTimer(Info MessageInfo, stream *DataStream) (any, error) {
	var val MaretronSwitchStatusTimer
	val.Info = Info
	if v, err := stream.readLookupField(11); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-ManufacturerCode: %w", err)
	} else {
		if v != 137 {
			return nil, fmt.Errorf("match failed for MaretronSwitchStatusTimer-ManufacturerCode: Expected %d != %d", 137, v)
		}
		val.ManufacturerCode = ManufacturerCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(2)
	if stream.isEOF() {
		return val, nil
		}
	if v, err := stream.readLookupField(3); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-IndustryCode: %w", err)
	} else {
		if v != 4 {
			return nil, fmt.Errorf("match failed for MaretronSwitchStatusTimer-IndustryCode: Expected %d != %d", 4, v)
		}
		val.IndustryCode = IndustryCodeConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-Instance: %w", err)
	} else {
		val.Instance = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt8(8); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-IndicatorNumber: %w", err)
	} else {
		val.IndicatorNumber = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt16(16); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-StartDate: %w", err)
	} else {
		val.StartDate = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUnsignedResolution(32, 0.0001, 0); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-StartTime: %w", err)
	} else {
		val.StartTime = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedOffPeriod: %w", err)
	} else {
		val.AccumulatedOffPeriod = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedOnPeriod: %w", err)
	} else {
		val.AccumulatedOnPeriod = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readUInt32(32); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-AccumulatedErrorPeriod: %w", err)
	} else {
		val.AccumulatedErrorPeriod = v

		if stream.isEOF() {
			return val, nil
		} 
	}
	if v, err := stream.readLookupField(2); err != nil {
		return nil, fmt.Errorf("parse failed for MaretronSwitchStatusTimer-SwitchStatus: %w", err)
	} else {
		val.SwitchStatus = OffOnConst(v)

		if stream.isEOF() {
			return val, nil
		} 
	}
	stream.skipBits(6)
	if stream.isEOF() {
		return val, nil
		}	
	return val, nil
}
