// Code generated by "cmd/pgngen"; DO NOT EDIT.
package pgn
{{$forDebug := eq (env "PGNGEN_DEBUG") "1"}}

import (
	"fmt"
	
	"github.com/boatkit-io/tugboat/pkg/units"
)

func nullableUnit[T any, U any, V float32|uint16|int16|uint32](u U, v *V, newer func(u U, v float32) T) *T {
	if v == nil {
		return nil
	}
	ov := newer(u, float32(*v))
	return &ov
}

// PgnInfo instances describe known NMEA 2000 messages.
type PgnInfo struct {
	// Id needed to distinguish pgns with KeyValue fields
	Id string
	// PGN (Parameter Group Number) identifies the Message
	PGN uint32
	// Description of the message.
	Description string
	// Fast if not single.
	Fast bool
	// ManId identifies the Manufacturer for Proprietary PGNs
	ManId ManufacturerCodeConst
	// Decoder is a function that generates golang data from the messsage data.
	Decoder func(MessageInfo, *DataStream) (any, error)
	// Instance is a zero instance of the struct used for testing
	// Fields is a map of field descriptions needed at runtime to deal with variable pgn fields
	Fields map[int]*FieldDescriptor

    {{- if $forDebug}}
	// The following fields are used for testing only.
	// Instance is a zero instance of the struct used for testing
	Instance             any
	// Repeating1CountField is the field that contains the count of repeating1 fields
	Repeating1CountField uint8
	// Repeating2CountField is the field that contains the count of repeating2 fields
	Repeating2CountField uint8
	{{end}}
}

// FieldDescriptor instances describe a PGN field.
type FieldDescriptor struct {
	Name              string
	BitLength         uint16
	BitOffset         uint16
	BitLengthVariable bool
	CanboatType       string
	Resolution        float32
	Unit              string
	BitLookupName     string

	{{if $forDebug}}
	// The following fields are used for testing only. Uncomment to use.
	Id                string
	GolangType        string
	RangeMax          float64
	RangeMin          float64
	DomainMin         float64
	DomainMax         float64
	Signed            bool
	Match             int
	Offset            int64
	Order             uint8
	{{end}}
}

// Spit out global consts
{{- range .PGNDoc.Enums }}
{{- $name := .Name  }}

type {{ $name }} {{ constSize .MaxValue }}
const (
{{- range .Values }}
	{{ toVarName .Text }}	{{ $name }} = {{ .Value }}
{{- end }}
)

func (e {{ $name }}) GoString() string {return e.String() }
func (e {{ $name }}) String() string {
	switch e {
{{- range  .Values }}
		case {{ .Value }}:
			return "{{ .Text }}"
{{- end }}
	default:
		return fmt.Sprintf("%s(%d)", "{{ $name }}", int(e))
	}
}
{{- end }}

{{ range .PGNDoc.IndirectEnums }}
type {{ .Name }} uint16
var {{ .Name  }}Map = map[int]map[int]string{
{{- range $key, $value := makeIndirectMap . -}}
	{{- $key }}: {
	{{- range $k, $v := $value -}}
		{{- $k }}: " {{- $v }}",
	{{ end }} },
{{ end }}
}

{{ end }}



{{ range .PGNDoc.FieldTypeEnums }}


type {{ .Name }} uint16
var {{ .Name  }}Map = map[int]FieldDescriptor{
{{- range .EnumFieldTypeValues -}}
	{{- .Value }}: {
		Name: "{{ .Name }}",
		CanboatType: "{{ .FieldType }}",
		Resolution: {{ .Resolution }},
		Unit: "{{ .Unit }}",
		BitLength: {{ .BitLength }},
		BitLookupName: "{{ .BitLookupName }}",
		},
	{{ end }} 
}
{{ end }}

{{- range .PGNDoc.BitEnums }}
{{- $name := .Name  }}

type {{ $name }} uint16
const (
{{- range .EnumBitValues }}
	{{ toVarName .Label }}	{{ $name }} = {{ .Bit }}
{{- end }}
)

func (e {{ $name }}) GoString() string {return e.String() }
func (e {{ $name }}) String() string {
	switch e {
{{- range  .EnumBitValues }}
		case {{ .Bit }}:
			return "{{ .Label }}"
{{- end }}
	default:
		return fmt.Sprintf("%s(%d)", "{{ $name }}", int(e))
	}
}
{{- end }}

var unseenList = []PgnInfo{
{{- range .PGNDoc.NeverSeenPGNs }}
	{
		PGN: {{ .PGN }},
		Description: {{ quote .Description }},
		Fast: {{ if eq .Type "Fast" }}true{{ else }}false{{ end }},
		ManId: {{ matchManufacturer . }},
	},
{{- end }}
}

{{- range .PGNDoc.PGNs }}
{{- if eq .PGN 126208 }}

    // Define the partial type and its methods
    type {{ .Id }}Partial struct {
        Info MessageInfo
        {{- range .Fields }}
        {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
        {{ .Id }} {{ convertFieldType . }}
        {{- end }}
        {{- end }}
        // Raw data for variable length fields in proprietary group function messages
        RawData []uint8
    }

    // Decode function that returns error for Partial types
    func Decode{{ .Id }}Partial(Info MessageInfo, stream *DataStream) (any, error) {
        return nil, fmt.Errorf("cannot decode {{ .Id }}Partial directly - use {{ .Id }} for decoding")
    }

    // Encode returns an error for partial variants
    func (p {{ .Id }}Partial) Encode(stream *DataStream) (*MessageInfo, error) {
        return nil, fmt.Errorf("cannot encode partial variant of {{ .Id }} - use {{ .Id }} for encoding")
    }
{{- end }}
{{- end }}

var PgnList = pgnList
var pgnList = []PgnInfo{
{{- range .PGNDoc.PGNs }}
    {
        Id: "{{ .Id }}",
        PGN: {{ .PGN }},
        Description: {{ quote .Description }},
        Fast: {{ if eq .Type "Fast" }}true{{ else }}false{{ end }},
        ManId: {{ matchManufacturer . }},
        Decoder: Decode{{ .Id }},
        {{- if $forDebug }}
        Instance: &{{ .Id }} {},
        {{- if .RepeatingFieldSet1CountField }}
        Repeating1CountField: {{ .RepeatingFieldSet1CountField }},
        {{- end }}
        {{- if .RepeatingFieldSet2CountField }}
        Repeating2CountField: {{ .RepeatingFieldSet2CountField }},
        {{- end }}
        {{- end }}
        Fields: map[int]*FieldDescriptor{
        {{- range .Fields }}
        {{ .Order }}: { 
            BitLength: {{ .BitLength }},
            BitOffset: {{ .BitOffset }},
            BitLengthVariable: {{ .BitLengthVariable }},
            CanboatType: "{{ .FieldType }}",
            Resolution: {{- if .Resolution -}}
            {{ .Resolution }}
            {{- else -}}
            1
            {{- end }},
            {{- if $forDebug }}
            Id: "{{ .Id }}",
            GolangType: {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") -}}
            "{{- convertFieldType . }}",
            {{- else -}}    
                "",
            {{- end }}
            Signed: {{ .Signed }},
            RangeMin: {{ .RangeMin }},
            RangeMax: {{ .RangeMax }},
            DomainMin: {{ .DomainMin }},
            DomainMax: {{ .DomainMax }},
            {{- if .Match }} 
            Match: {{ .Match }},
            {{- else }}
            Match: -1,
            {{- end }}
            {{- if .Offset }} 
            Offset: {{ .Offset }},
            {{- end }}
            Order: {{ .Order }},
            {{- end }}
            },
        {{- end }}
        },
    },
{{- end }}
}

// Build structs for each PGN
{{- range .PGNDoc.PGNs }}
{{- $pgn := . }}

{{- if $pgn.RepeatingFieldSet1Size }}
type {{ .Id }}Repeating1 struct {
    {{- range $pgn.FieldsRepeating1 }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
}
{{- end }}

{{- if $pgn.RepeatingFieldSet2Size }}
type {{ .Id }}Repeating2 struct {
    {{- range $pgn.FieldsRepeating2 }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
}
{{- end }}

type {{ .Id }} struct {
    Info MessageInfo
    {{- range $pgn.Fields }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
    {{- if $pgn.RepeatingFieldSet1Size }}
    Repeating1 []{{ .Id }}Repeating1
    {{- end }}
    {{- if $pgn.RepeatingFieldSet2Size }}
    Repeating2 []{{ .Id }}Repeating2
    {{- end }}
}

{{- $funcName := concat "Decode" .Id }}
func {{ $funcName }}(Info MessageInfo, stream *DataStream) (any, error) {
    var val {{ .Id }}
    val.Info = Info
	{{- $repeat1 :=  $pgn.RepeatingFieldSet1Size }}
    {{- if and $repeat1 (not (eq .RepeatingFieldSet1CountField -1)) }}
    var repeat1Count uint16 = 0
    {{- end }}
    {{- if and (eq .PGN 126208) (gt $repeat1 1) }}
    var fieldIndex uint8
    {{- end }}
	{{- $binaryLengthField :=  $pgn.BitLengthField }}
	{{- if  $binaryLengthField }}
		var binaryLength uint16 = 0
	{{- end }}
	{{- $isKeyValue := or (eq .Id "SimnetParameterSet") (eq .Id "SimnetKeyValue" ) (eq .Id "BGKeyValueData" ) }}
	{{- if $isKeyValue }}
		var valueLength uint16
	{{ end }}

    // Decode all non-repeating fields
    {{- range $idx, $field := $pgn.Fields }}
    {{- if or (eq $field.FieldType "RESERVED") (eq $field.FieldType "SPARE") }}
    stream.skipBits({{ $field.BitLength }})
    {{- else }}
    if v, err := {{ index (getFieldDeserializer $pgn $field) 0 }}; err != nil {
        return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ $field.Id }}: %w", err)
    } else {
        val.{{ $field.Id }} = {{ if ne (index (getFieldDeserializer $pgn $field) 1) "" }}{{ index (getFieldDeserializer $pgn $field) 1 }}{{ else }}v{{ end }}
        {{- if and $repeat1 (eq $field.Order $pgn.RepeatingFieldSet1CountField) }}
        if v != nil {
            repeat1Count = uint16(*v)
        }
        {{- end }}
		{{- if and $binaryLengthField (eq $idx (subtract $pgn.BitLengthField 1)) }}
		if v != nil {
			binaryLength = uint16(*v)
		}
	{{- end }}
	{{- if and $isKeyValue (eq $field.Name "MinLength") }}
		if v != nil {
			valueLength = uint16(*v) * 8
		}
	{{ end }}

        {{- if and (eq $pgn.PGN 126208) (eq $field.FieldType "FIELD_INDEX") }}
        if v != nil {
            fieldIndex = uint8(*v)
        }
        {{- end }}
    }
    {{- end }}
    {{- end }}

    {{- if eq .PGN 126208 }}
    // For PGN 126208, check if commanded PGN is proprietary
    if IsProprietaryPGN(*val.Pgn) {
        var partial {{ .Id }}Partial
        partial.Info = Info
        {{- range $pgn.Fields }}
        {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
        partial.{{ .Id }} = val.{{ .Id }}
        {{- end }}
        {{- end }}
        if v, err := stream.readBinaryData(stream.remainingLength() * 8); err != nil {
            return nil, fmt.Errorf("failed to read remaining bytes: %w", err)
        } else {
            partial.RawData = v
        }
        return partial, nil
    }
    {{- end }}

    {{- if gt .RepeatingFieldSet1StartField 0 }}
    val.Repeating1 = make([]{{ .Id }}Repeating1, repeat1Count)
    for i := range val.Repeating1 {
        {{- range .FieldsRepeating1 }}
        {{- if or (eq .FieldType "RESERVED") (eq .FieldType "SPARE") }}
        stream.skipBits({{ .BitLength }})
        {{- else }}
        if v, err := {{ index (getFieldDeserializer $pgn .) 0 }}; err != nil {
            return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
        } else {
            val.Repeating1[i].{{ .Id }} = {{ if ne (index (getFieldDeserializer $pgn .) 1) "" }}{{ index (getFieldDeserializer $pgn .) 1 }}{{ else }}v{{ end }}
        }
        {{- end }}
        {{- end }}
    }
    {{- end }}

    return val, nil
}

// Encode implementation for complete variant
func (p {{ .Id }}) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
	{{- $binaryLengthField :=  $pgn.BitLengthField }}
	{{- if  $binaryLengthField }}
		var binaryLength uint16
		if p.NumberOfBitsInBinaryDataField != nil {
			binaryLength = *p.NumberOfBitsInBinaryDataField
		}
	{{- end }}
    {{- range $idx, $field := .Fields }}
    {{- $func := getFieldSerializer $field "" }}
    {{- if ne $func "" }}
    {{ $func }}
    if err != nil {
        return nil, err
    }
    {{- end }}
    {{- end }}
    {{- if  (gt .RepeatingFieldSet1StartField 0) }}
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    {{- end }}
    {{- if  (gt .RepeatingFieldSet2StartField 0) }}
    err = p.encodeRepeating2(stream)
    if err != nil {
        return nil, err
    }
    {{- end }}
    return &p.Info, err
}

{{- if gt .RepeatingFieldSet1StartField 0 }}
func (p {{ .Id }}) encodeRepeating1(stream *DataStream) error {
     var err error
 	{{- $isKeyValue := or (eq .Id "SimnetParameterSet") (eq .Id "SimnetKeyValue" ) (eq .Id "BGKeyValueData" ) }}
	{{- if $isKeyValue }}
		var valueLength uint16
	{{- end }}
		
  for index, _ := range p.Repeating1 {
        {{- range .FieldsRepeating1 }}
		{{- if and $isKeyValue (eq .Name "Length") }}
		if p.Repeating1[index].Length != nil {
			valueLength = uint16(*p.Repeating1[index].Length) * 8
		}
		{{- end }}
        {{- $func := getFieldSerializer . "Repeating1[index]." }}
        {{- if ne $func "" }}
        {{ $func }}
        if err != nil {
            return err
        }
        {{- end }}
        {{- end }}
    }
    return nil
}
{{- end }}

{{- if gt .RepeatingFieldSet2StartField 0 }}
func (p {{ .Id }}) encodeRepeating2(stream *DataStream) error {
     var err error
   for index, _ := range p.Repeating2 {
        {{- range .FieldsRepeating2 }}
 		{{- $substruct := "Repeating2[index]." }}
       	{{- $func := getFieldSerializer . $substruct }}
        {{- if ne $func "" }}
        {{ $func }}
        if err != nil {
            return err
        }
        {{- end }}
        {{- end }}
    }
    return nil
}
{{- end }}

{{- else }}
{{- if .RepeatingFieldSet1Size }}
type {{ .Id }}Repeating1 struct {
    {{- range .FieldsRepeating1 }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
}
{{- end }}

{{- if .RepeatingFieldSet2Size }}
type {{ .Id }}Repeating2 struct {
    {{- range .FieldsRepeating2 }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
}
{{- end }}
{{- end }}


