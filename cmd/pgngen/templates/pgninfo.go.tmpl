// Code generated by "cmd/pgngen"; DO NOT EDIT.

package n2k

import "fmt"



// Spit out global consts
{{- range .PGNDoc.Enums }}
{{- $name := .Name  }}

type {{ $name }} {{ constSize .MaxValue }}
const (
{{- range .Values }}
	{{ toVarName .Text }}	{{ $name }} = {{ .Value }}
{{- end }}
)

func (e {{ $name }}) GoString() string {return e.String() }
func (e {{ $name }}) String() string {
	switch e {
{{- range  .Values }}
		case {{ .Value }}:
			return "{{ .Text }}"
{{- end }}
	default:
		return fmt.Sprintf("%s(%d)", "{{ $name }}", int(e))
	}
}
{{- end }}

{{ range .PGNDoc.IndirectEnums }}
type {{ .Name }} uint16
var {{ .Name  }}Map = map[int]map[int]string{
{{- range $key, $value := makeIndirectMap . -}}
	{{- $key }}: {
	{{- range $k, $v := $value -}}
		{{- $k }}: " {{- $v }}",
	{{ end }} },
{{ end }}
}

{{ end }}

{{- range .PGNDoc.BitEnums }}
{{- $name := .Name  }}

type {{ $name }} uint16
const (
{{- range .EnumBitValues }}
	{{ toVarName .Label }}	{{ $name }} = {{ .Bit }}
{{- end }}
)

func (e {{ $name }}) GoString() string {return e.String() }
func (e {{ $name }}) String() string {
	switch e {
{{- range  .EnumBitValues }}
		case {{ .Bit }}:
			return "{{ .Label }}"
{{- end }}
	default:
		return fmt.Sprintf("%s(%d)", "{{ $name }}", int(e))
	}
}
{{- end }}
		
var pgnList = []PgnInfo{
{{- range .PGNDoc.PGNs }}
	{
		PGN: {{ .PGN }},
		Description: {{ quote .Description }},
		Fast: {{ if eq .Type "Fast" }}true{{ else }}false{{ end }},
		ManId: {{ matchManufacturer . }},
		Decoder: Decode{{ .Id }},
		FieldInfo: map[int]FieldDescriptor{
		{{- range .Fields }}
		{{ if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") -}}
		{{ .Order }}: { {{ .BitLength }},
			{{ .BitLengthVariable }},
			"{{ convertFieldType . }}",
			{{- if .Resolution }}
			{{ .Resolution }}
			{{- else }}
			1
			{{- end }},
			{{ .Signed }},
			},
		{{- end }}
		{{- end }}
		},
	},
{{- end }}
}
// Build structs for each PGN
{{- range .PGNDoc.PGNs }}
{{- $pgn := . }}
type {{ .Id }} struct {
	Info PacketInfo
	{{- range .Fields }}
	{{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
	{{ .Id }} {{ convertFieldType . }}
	{{- end }}
	{{- end }}
	{{- if  $pgn.RepeatingFieldSet1Size }}
	Repeating1 []{{ $pgn.Id }}Repeating1
	{{- end }}
	{{- if $pgn.RepeatingFieldSet2Size  }}
	Repeating2 []{{ $pgn.Id }}Repeating2
	{{- end }}
}
{{- if $pgn.RepeatingFieldSet1Size }}
type {{ $pgn.Id }}Repeating1 struct {
	{{- range $pgn.FieldsRepeating1 }}
	{{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
	{{ .Id }} {{ convertFieldType . }}
	{{- end }}
	{{- end }}
}
{{- end }}
{{- if $pgn.RepeatingFieldSet2Size }}
type {{ .Id }}Repeating2 struct {
	{{- range $pgn.FieldsRepeating2 }}
	{{- if ne .Id "Reserved" }}
	{{ .Id }} {{ convertFieldType . }}
	{{- end }}
	{{- end }}
}
{{- end }}
{{- $funcName := concat "Decode" .Id }}
func {{ $funcName }}(Info PacketInfo, stream *pGNDataStream) (interface{}, error) {
	var val {{ .Id }}
	val.Info = Info
	{{- $binaryLengthField :=  $pgn.BitLengthField }}
	{{- if  $binaryLengthField }}
		var binaryLength uint16 = 0
	{{- end }}
	{{- $repeat1 :=  $pgn.RepeatingFieldSet1Size }}
	{{- if  $repeat1 }}
		var repeat1Count uint16 = 0
	{{- end }}
	{{- $repeat2 :=  $pgn.RepeatingFieldSet2Size }}
	{{- if $repeat2 }}
		var repeat2Count uint16
	{{- end }}
	{{- range $idx, $field := $pgn.Fields }}
	{{- if or (eq $field.FieldType "RESERVED") (eq $field.FieldType "SPARE") }}
	stream.skipBits({{ $field.BitLength }})
	if stream.isEOF() {
		return val, nil
		}
	{{- else }}	
	{{- if and $repeat2 (eq $idx 2) }}
	if isProprietaryPGN( *val.Pgn) {
	{{- end }}
	{{- if and $repeat2  (eq $idx 5) }}
	} 
	{{- end }}
{{- $funcs := getFieldDeserializer $pgn . }}
	if v, err := {{ index $funcs 0 }}; err != nil {
		return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
	} else {
	{{- if not (isNil .Match) }}
	{{- if isPointerFieldType  . }}
		if v != nil && *v != {{ derefInt .Match }} {
			return nil, fmt.Errorf("match failed for {{ $pgn.Id }}-{{ .Id }}: Expected %d != %d", {{ .Match }}, *v)
		} 
	{{- else }}
		if v != {{ .Match }} {
			return nil, fmt.Errorf("match failed for {{ $pgn.Id }}-{{ .Id }}: Expected %d != %d", {{ .Match }}, v)
		} 
	{{- end }}
	{{- end }}
		val.{{ .Id }} = {{ if ne (index $funcs 1) "" }}{{ index $funcs 1 }}(v){{ else }}v{{ end }}
	{{- if and $repeat1 (eq $idx (subtract $pgn.RepeatingFieldSet1CountField 1)) }}
		if v != nil {
			repeat1Count = uint16(*v)
		}
	{{- end }}
	{{- if and $repeat2 (eq $idx (subtract $pgn.RepeatingFieldSet2CountField 1)) }}
		if v != nil {
			repeat2Count = uint16(*v)
		}
	{{- end }}
	{{- if and $binaryLengthField (eq $idx (subtract $pgn.BitLengthField 1)) }}
		if v != nil {
			binaryLength = uint16(*v)
		}
	{{- end }}
		if stream.isEOF() {
			return val, nil
		} 
	} 
	{{- end }}
{{- end }}
	{{- if $repeat1 }}
	{{- if gt $pgn.RepeatingFieldSet1CountField 0 }}
		if repeat1Count == 0 {
			return val, nil
		}
	{{- end }}
	val.Repeating1 = make([]{{ $pgn.Id }}Repeating1, 0)
	i := 0 
	for {
		var rep {{ $pgn.Id }}Repeating1
		{{- range $pgn.FieldsRepeating1 }}
		{{- if eq .FieldType "RESERVED" }}
		stream.skipBits({{ .BitLength }})
		{{- else if eq .FieldType "VARIABLE"}}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else  if v != nil {
			rep.{{- .Id }} = v
		}
		{{- else }}
		{{- $funcs := getFieldDeserializer $pgn . }}
		if v, err := {{ index $funcs 0 }}; err != nil {
			return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
		} else {
			rep.{{ .Id }} = {{ if ne (index $funcs 1) "" }}{{ index $funcs 1 }}(v){{ else }}v{{ end }}
		} 
		{{- end }}
		{{- end }}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
	} 
	{{- end }}
	{{- if $repeat2 }}
	{{- if gt $pgn.RepeatingFieldSet2CountField 0 }}
		if repeat2Count == 0 {
			return val, nil
		}
	{{- end }}	
	val.Repeating2 = make([]{{ $pgn.Id }}Repeating2, 0)
	i = 0
	for {
		var rep {{ $pgn.Id }}Repeating2
		{{- range $pgn.FieldsRepeating2 }}
		{{- if eq .FieldType "RESERVED" }}
		stream.skipBits({{ .BitLength }})
		{{- else if eq .FieldType "VARIABLE" }}
		if v, err := stream.readVariableData(*val.Pgn, *rep.Parameter); err != nil {
			return nil, fmt.Errorf("parse failed for variable read, %d, %d",*val.Pgn, *rep.Parameter)
		} else if v != nil {
			rep.{{- .Id }} = v
		}
		{{- else }}
		{{- $funcs := getFieldDeserializer $pgn . }}
		if v, err := {{ index $funcs 0 }}; err != nil {
			return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
		} else {
			rep.{{ .Id }} = {{ if ne (index $funcs 1) "" }}{{ index $funcs 1 }}(v){{ else }}v{{ end }}
		}  
		{{- end }}
		{{- end }}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	} 
	{{- end }}	
	return val, nil
}
{{- end }}
