// Code generated by "cmd/pgngen"; DO NOT EDIT.
package pgn
{{$forDebug := eq (env "PGNGEN_DEBUG") "1"}}

import (
	"fmt"
	
	"github.com/boatkit-io/tugboat/pkg/units"
)

func nullableUnit[T any, U any, V float32|uint16|int16|uint32](u U, v *V, newer func(u U, v float32) T) *T {
	if v == nil {
		return nil
	}
	ov := newer(u, float32(*v))
	return &ov
}

// PgnInfo instances describe known NMEA 2000 messages.
type PgnInfo struct {
	// Id needed to distinguish pgns with KeyValue fields
	Id string
	// PGN (Parameter Group Number) identifies the Message
	PGN uint32
	// Description of the message.
	Description string
	// Fast if not single.
	Fast bool
	// ManId identifies the Manufacturer for Proprietary PGNs
	ManId ManufacturerCodeConst
	// Decoder is a function that generates golang data from the messsage data.
	Decoder func(MessageInfo, *DataStream) (any, error)
	// Instance is a zero instance of the struct used for testing
	// Fields is a map of field descriptions needed at runtime to deal with variable pgn fields
	Fields map[int]*FieldDescriptor

    {{- if $forDebug}}
	// The following fields are used for testing only.
	// Instance is a zero instance of the struct used for testing
	Instance             any
	// Repeating1CountField is the field that contains the count of repeating1 fields
	Repeating1CountField uint8
	// Repeating2CountField is the field that contains the count of repeating2 fields
	Repeating2CountField uint8
	{{end}}
}

// FieldDescriptor instances describe a PGN field.
type FieldDescriptor struct {
	Name              string
	BitLength         uint16
	BitOffset         uint16
	BitLengthVariable bool
	CanboatType       string
	Resolution        float32
	Unit              string
	BitLookupName     string
    Match             int

	{{if $forDebug}}
	// The following fields are used for testing only. Uncomment to use.
	Id                string
	GolangType        string
	RangeMax          float64
	RangeMin          float64
	DomainMin         float64
	DomainMax         float64
	Signed            bool
	Offset            int64
	Order             uint8
	{{end}}
}

// Spit out global consts
{{- range .PGNDoc.Enums }}
{{- $name := .Name  }}

type {{ $name }} {{ constSize .MaxValue }}
const (
{{- range .Values }}
	{{ toVarName .Text }}	{{ $name }} = {{ .Value }}
{{- end }}
)

func (e {{ $name }}) GoString() string {return e.String() }
func (e {{ $name }}) String() string {
	switch e {
{{- range  .Values }}
		case {{ .Value }}:
			return "{{ .Text }}"
{{- end }}
	default:
		return fmt.Sprintf("%s(%d)", "{{ $name }}", int(e))
	}
}
{{- end }}

{{ range .PGNDoc.IndirectEnums }}
type {{ .Name }} uint16
var {{ .Name  }}Map = map[int]map[int]string{
{{- range $key, $value := makeIndirectMap . -}}
	{{- $key }}: {
	{{- range $k, $v := $value -}}
		{{- $k }}: " {{- $v }}",
	{{ end }} },
{{ end }}
}

{{ end }}



{{ range .PGNDoc.FieldTypeEnums }}


type {{ .Name }} uint16
var {{ .Name  }}Map = map[int]FieldDescriptor{
{{- range .EnumFieldTypeValues -}}
	{{- .Value }}: {
		Name: "{{ .Name }}",
		CanboatType: "{{ .FieldType }}",
		Resolution: {{ .Resolution }},
		Unit: "{{ .Unit }}",
		BitLength: {{ .BitLength }},
		BitLookupName: "{{ .BitLookupName }}",
		},
	{{ end }} 
}
{{ end }}

{{- range .PGNDoc.BitEnums }}
{{- $name := .Name  }}

type {{ $name }} uint16
const (
{{- range .EnumBitValues }}
	{{ toVarName .Label }}	{{ $name }} = {{ .Bit }}
{{- end }}
)

func (e {{ $name }}) GoString() string {return e.String() }
func (e {{ $name }}) String() string {
	switch e {
{{- range  .EnumBitValues }}
		case {{ .Bit }}:
			return "{{ .Label }}"
{{- end }}
	default:
		return fmt.Sprintf("%s(%d)", "{{ $name }}", int(e))
	}
}
{{- end }}

var unseenList = []PgnInfo{
{{- range .PGNDoc.NeverSeenPGNs }}
	{
		PGN: {{ .PGN }},
		Description: {{ quote .Description }},
		Fast: {{ if eq .Type "Fast" }}true{{ else }}false{{ end }},
		ManId: {{ matchManufacturer . }},
	},
{{- end }}
}

{{- range .PGNDoc.PGNs }}
{{- if eq .PGN 126208 }}

    // Define the partial type and its methods
    type {{ .Id }}Partial struct {
        Info MessageInfo
        {{- range .Fields }}
        {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
        {{ .Id }} {{ convertFieldType . }}
        {{- end }}
        {{- end }}
        // Raw data for variable length fields in proprietary group function messages
        RawData []uint8
    }

    // Decode function that returns error for Partial types
    func Decode{{ .Id }}Partial(Info MessageInfo, stream *DataStream) (any, error) {
        return nil, fmt.Errorf("cannot decode {{ .Id }}Partial directly - use {{ .Id }} for decoding")
    }

    // Encode returns an error for partial variants
    func (p {{ .Id }}Partial) Encode(stream *DataStream) (*MessageInfo, error) {
        return nil, fmt.Errorf("cannot encode partial variant of {{ .Id }} - use {{ .Id }} for encoding")
    }
{{- end }}
{{- end }}

var PgnList = pgnList
var pgnList = []PgnInfo{
{{- range .PGNDoc.PGNs }}
    {
        Id: "{{ .Id }}",
        PGN: {{ .PGN }},
        Description: {{ quote .Description }},
        Fast: {{ if eq .Type "Fast" }}true{{ else }}false{{ end }},
        ManId: {{ matchManufacturer . }},
        Decoder: Decode{{ .Id }},
        {{- if $forDebug }}
        Instance: &{{ .Id }} {},
        {{- if .RepeatingFieldSet1CountField }}
        Repeating1CountField: {{ .RepeatingFieldSet1CountField }},
        {{- end }}
        {{- if .RepeatingFieldSet2CountField }}
        Repeating2CountField: {{ .RepeatingFieldSet2CountField }},
        {{- end }}
        {{- end }}
        Fields: map[int]*FieldDescriptor{
        {{- range .Fields }}
        {{ .Order }}: { 
            BitLength: {{ .BitLength }},
            BitOffset: {{ .BitOffset }},
            BitLengthVariable: {{ .BitLengthVariable }},
            CanboatType: "{{ .FieldType }}",
            Resolution: {{- if .Resolution -}}
            {{ .Resolution }}
            {{- else -}}
            1
            {{- end }},
            {{- if .Match }}
            Match: {{ .Match }},
            {{- end }}
            {{- if $forDebug }}
            Id: "{{ .Id }}",
            GolangType: {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") -}}
            "{{- convertFieldType . }}",
            {{- else -}}    
                "",
            {{- end }}
            Signed: {{ .Signed }},
            RangeMin: {{ .RangeMin }},
            RangeMax: {{ .RangeMax }},
            DomainMin: {{ .DomainMin }},
            DomainMax: {{ .DomainMax }},
            {{- if isNil .Match }} 
            Match: -1,
            {{- end }}
            {{- if .Offset }} 
            Offset: {{ .Offset }},
            {{- end }}
            Order: {{ .Order }},
            {{- end }}
            },
        {{- end }}
        },
    },
{{- end }}
}

// Build structs for each PGN
{{- range .PGNDoc.PGNs }}
{{- $pgn := . }}

{{- if $pgn.RepeatingFieldSet1Size }}
type {{ .Id }}Repeating1 struct {
    {{- range $pgn.FieldsRepeating1 }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
}
{{- end }}

{{- if $pgn.RepeatingFieldSet2Size }}
type {{ .Id }}Repeating2 struct {
    {{- range $pgn.FieldsRepeating2 }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
}
{{- end }}

type {{ .Id }} struct {
    Info MessageInfo
    {{- range $pgn.Fields }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
    {{- if $pgn.RepeatingFieldSet1Size }}
    Repeating1 []{{ .Id }}Repeating1
    {{- end }}
    {{- if $pgn.RepeatingFieldSet2Size }}
    Repeating2 []{{ .Id }}Repeating2
    {{- end }}
}

{{- $funcName := concat "Decode" .Id }}
func {{ $funcName }}(Info MessageInfo, stream *DataStream) (any, error) {
    var val {{ .Id }}
    val.Info = Info
	{{- $repeat1 :=  $pgn.RepeatingFieldSet1Size }}
    {{- if $repeat1 }}
    var repeat1Count uint16 = 0
    {{- end }}
 	{{- $repeat2 :=  $pgn.RepeatingFieldSet2Size }}
    {{- if $repeat2 }}
    var repeat2Count uint16 = 0
    {{- end }}
   {{- if and (eq .PGN 126208) (gt $repeat1 1) }}
    var fieldIndex uint8
    {{- end }}
	{{- $binaryLengthField :=  $pgn.BitLengthField }}
	{{- if  $binaryLengthField }}
		var binaryLength uint16 = 0
	{{- end }}
	{{- $isKeyValue := or (eq .Id "SimnetParameterSet") (eq .Id "SimnetKeyValue" ) (eq .Id "BGKeyValueData" ) }}
	{{- if $isKeyValue }}
		var valueLength uint16
	{{ end }}

    // Decode all non-repeating fields
    {{- range $idx, $field := $pgn.Fields }}
    {{- if or (eq $field.FieldType "RESERVED") (eq $field.FieldType "SPARE") }}
    stream.skipBits({{ $field.BitLength }})
    {{- else }}
    if v, err := {{ index (getFieldDeserializer $pgn $field) 0 }}; err != nil {
        return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ $field.Id }}: %w", err)
    } else {
        val.{{ $field.Id }} = {{ if ne (index (getFieldDeserializer $pgn $field) 1) "" }}{{ index (getFieldDeserializer $pgn $field) 1 }}{{ else }}v{{ end }}
        {{- if and $repeat1 (eq $field.Order $pgn.RepeatingFieldSet1CountField) }}
        if v != nil {
            repeat1Count = uint16(*v)
        }
        {{- end }}
		{{- if and $binaryLengthField (eq $idx (subtract $pgn.BitLengthField 1)) }}
		if v != nil {
			binaryLength = uint16(*v)
		}
	{{- end }}
	{{- if and $isKeyValue (eq $field.Name "MinLength") }}
		if v != nil {
			valueLength = uint16(*v) * 8
		}
	{{ end }}

        {{- if and (eq $pgn.PGN 126208) (eq $field.FieldType "FIELD_INDEX") }}
        if v != nil {
            fieldIndex = uint8(*v)
        }
        {{- end }}
        {{- if not (isNil .Match) }}
        {{- if ne (int .Match) -1 }}
        {{- if isPointerFieldType $field }}
        if v != nil && *v != {{ derefInt .Match }} {
            return nil, fmt.Errorf("match failed for {{ $pgn.Id }}-{{ $field.Id }}: Expected %d != %d", {{ .Match }}, *v)
        }
        {{- else }}
        if v != {{ $field.Match }} {
            return nil, fmt.Errorf("match failed for {{ $pgn.Id }}-{{ $field.Id }}: Expected %d != %d", {{ $field.Match }}, v)
        }
        {{- end }}
        {{- end }}
        {{- end }}
    }
    {{- end }}
    {{- end }}

    {{- if eq .PGN 126208 }}
    // For PGN 126208, check if commanded PGN is proprietary or unknown
    if IsProprietaryPGN(*val.Pgn) || GetPgnInfo(*val.Pgn) == nil {
        var partial {{ .Id }}Partial
        partial.Info = Info
        {{- range $pgn.Fields }}
        {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
        partial.{{ .Id }} = val.{{ .Id }}
        {{- end }}
        {{- end }}
        if v, err := stream.readBinaryData(stream.remainingLength() / 8); err != nil {
            return nil, fmt.Errorf("failed to read remaining bytes: %w", err)
        } else {
            partial.RawData = v
        }
        return partial, nil
    }
    {{- end }}

    {{- if $repeat1 }}
    val.Repeating1 = make([]{{ .Id }}Repeating1, 0)
	{{- if gt $pgn.RepeatingFieldSet1CountField 0 }}
    if repeat1Count == 0 {
        return val, nil
    }
    {{- else }}
    if stream.isEOF() {
        return val, nil
    }
	{{- end }}

    i := 0 
	for {
		var rep {{ $pgn.Id }}Repeating1
		{{- range $pgn.FieldsRepeating1 }}
		{{- if eq .FieldType "RESERVED" }}
		stream.skipBits({{ .BitLength }})
		{{- else }}
		{{- $funcs := getFieldDeserializer $pgn . }}
		if v, err := {{ index $funcs 0 }}; err != nil {
			return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
		} else {
			rep.{{ .Id }} = {{ if ne (index $funcs 1) "" }}{{ index $funcs 1 }}{{ else }}v{{ end }}
		{{- if eq .FieldType "FIELD_INDEX" }}
			if v != nil {
				fieldIndex = *v
			}
		{{- end }}
		{{- if and $isKeyValue (eq .Name "Length") }}
			if v != nil {
				valueLength = uint16(*v) * 8
			}
		{{ end }}
		} 
		{{- end }}
		{{- end }}
		val.Repeating1 = append(val.Repeating1, rep)
		if int(repeat1Count) == 0 {
			if stream.isEOF() {
				return val, nil
			} 
		} else {
			i++
			if i == int(repeat1Count) {
				break
			} 
		} 
    }
    {{- end }}
	{{- if $repeat2 }}
	{{- if gt $pgn.RepeatingFieldSet2CountField 0 }}
		if repeat2Count == 0 {
			return val, nil
		}
	{{- end }}	
	val.Repeating2 = make([]{{ $pgn.Id }}Repeating2, 0)
	i = 0
	for {
		var rep {{ $pgn.Id }}Repeating2
		{{- range $pgn.FieldsRepeating2 }}
		{{- if eq .FieldType "RESERVED" }}
		stream.skipBits({{ .BitLength }})
		{{- else }}
		{{- $funcs := getFieldDeserializer $pgn . }}
		if v, err := {{ index $funcs 0 }}; err != nil {
			return nil, fmt.Errorf("parse failed for {{ $pgn.Id }}-{{ .Id }}: %w", err)
		} else {
			rep.{{- .Id }} = {{ if ne (index $funcs 1) "" }}{{ index $funcs 1 }}{{ else }}v{{ end }}
		{{- if and (eq $pgn.RepeatingFieldSet2CountField 2) (eq .FieldType "FIELD_INDEX") }}
			if v != nil {
				fieldIndex = *v
			}
		{{- end }}
		}  
		{{- end }}
	{{- end }}
		val.Repeating2 = append(val.Repeating2, rep)
		if int(repeat2Count) == 0 {
			if stream.isEOF() {
				return val, nil
			}  
		} else {
			i++
			if i == int(repeat2Count) {
				break
			} 
		} 
	} 
	{{- end }}	
    return val, nil
}

// Encode implementation for complete variant
func (p {{ .Id }}) Encode(stream *DataStream) (*MessageInfo, error) {
    var err error
	{{- $binaryLengthField :=  $pgn.BitLengthField }}
	{{- if  $binaryLengthField }}
		var binaryLength uint16
		if p.NumberOfBitsInBinaryDataField != nil {
			binaryLength = *p.NumberOfBitsInBinaryDataField
		}
	{{- end }}
    {{- range $idx, $field := .Fields }}
    {{- $func := getFieldSerializer $field "" }}
    {{- if ne $func "" }}
    {{ $func }}
    if err != nil {
        return nil, err
    }
    {{- end }}
    {{- end }}
    {{- if  (gt .RepeatingFieldSet1StartField 0) }}
    err = p.encodeRepeating1(stream)
    if err != nil {
        return nil, err
    }
    {{- end }}
    {{- if  (gt .RepeatingFieldSet2StartField 0) }}
    err = p.encodeRepeating2(stream)
    if err != nil {
        return nil, err
    }
    {{- end }}
    return &p.Info, err
}

{{- if gt .RepeatingFieldSet1StartField 0 }}
func (p {{ .Id }}) encodeRepeating1(stream *DataStream) error {
     var err error
 	{{- $isKeyValue := or (eq .Id "SimnetParameterSet") (eq .Id "SimnetKeyValue" ) (eq .Id "BGKeyValueData" ) }}
	{{- if $isKeyValue }}
		var valueLength uint16
	{{- end }}
	if len(p.Repeating1) == 0 {
		return nil
	}
    for index, _ := range p.Repeating1 {
        {{- range .FieldsRepeating1 }}
		{{- if and $isKeyValue (eq .Name "Length") }}
		if p.Repeating1[index].Length != nil {
			valueLength = uint16(*p.Repeating1[index].Length) * 8
		}
		{{- end }}
        {{- $func := getFieldSerializer . "Repeating1[index]." }}
        {{- if ne $func "" }}
        {{ $func }}
        if err != nil {
            return err
        }
        {{- end }}
        {{- end }}
    }
    return nil
}
{{- end }}

{{- if gt .RepeatingFieldSet2StartField 0 }}
func (p {{ .Id }}) encodeRepeating2(stream *DataStream) error {
    var err error
	if len(p.Repeating2) == 0 {
		return nil
	}
    for index, _ := range p.Repeating2 {
        {{- range .FieldsRepeating2 }}
 		{{- $substruct := "Repeating2[index]." }}
       	{{- $func := getFieldSerializer . $substruct }}
        {{- if ne $func "" }}
        {{ $func }}
        if err != nil {
            return err
        }
        {{- end }}
        {{- end }}
    }
    return nil
}
{{- end }}

{{- else }}
{{- if .RepeatingFieldSet1Size }}
type {{ .Id }}Repeating1 struct {
    {{- range .FieldsRepeating1 }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
}
{{- end }}

{{- if .RepeatingFieldSet2Size }}
type {{ .Id }}Repeating2 struct {
    {{- range .FieldsRepeating2 }}
    {{- if and (ne .FieldType "RESERVED") (ne .FieldType "SPARE") }}
    {{ .Id }} {{ convertFieldType . }}
    {{- end }}
    {{- end }}
}
{{- end }}
{{- end }}


